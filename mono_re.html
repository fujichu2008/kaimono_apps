<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Monochrome Rebirth – Rhythm of Colors</title>
<style>
  :root{
    --gray: 1;
    --bg-top:#0b0f15;
    --bg-bot:#0e1220;
    --yellow:#ffd166; --green:#5af38f; --blue:#6ab8ff; --red:#ff6b6b;
    --hit-top: 75%;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(var(--bg-top),var(--bg-bot));color:#e9eefc;font-family:system-ui,-apple-system,"Hiragino Sans","Noto Sans JP",sans-serif}
  .wrap{height:100%;display:flex;align-items:center;justify-content:center;filter:grayscale(var(--gray));transition:filter .8s ease}
  .game{width:min(980px,100%);max-width:980px;padding:12px}
  .topbar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px}
  .stat{display:flex;gap:12px;font-size:14px;color:#bcd1ff;flex-wrap:wrap}
  .badge{padding:4px 10px;border:1px solid #283248;border-radius:999px;background:rgba(255,255,255,.04)}
  .title{font-weight:800;letter-spacing:.6px;color:#e9eefc;text-transform:uppercase}
  .stage{font-weight:600;opacity:.75}

  .board{
    position:relative;border:1px solid #243049;border-radius:16px;overflow:hidden;background:
      radial-gradient(1000px 400px at 50% 20%, rgba(255,255,255,.04), transparent 60%),
      linear-gradient(180deg, var(--bg-top),var(--bg-bot));
    height:70vh;min-height:460px;touch-action:none;
  }
  canvas{position:absolute;inset:0;display:block;width:100%;height:100%}

  .centerHud{position:absolute;left:0;right:0;top:8px;display:flex;justify-content:center;gap:8px;pointer-events:none;flex-wrap:wrap}
  .chip{font-size:12px;border:1px solid #3a455d;background:rgba(255,255,255,.05);padding:6px 10px;border-radius:999px}
  .chip strong{color:#fff}

  .hitLine{position:absolute; left:0; right:0; top: var(--hit-top, 75%); border-top:2px dashed rgba(255,255,255,.28);}

  .controls{position:absolute;left:0;right:0;bottom:10px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  .btn{
    -webkit-tap-highlight-color:transparent;
    border:1px solid #33415f;background:linear-gradient(180deg,#1a2234,#151b29);
    color:#e9eefc;border-radius:12px;padding:10px 14px;font-weight:700;letter-spacing:.3px;cursor:pointer;
    box-shadow:0 10px 28px rgba(0,0,0,.28), inset 0 1px 0 rgba(255,255,255,.06);
    text-transform:uppercase;
  }
  .btn:active{transform:translateY(1px)}
  .btn.primary{border-color:#6470ff;background:linear-gradient(180deg,#2b36aa,#20297e)}
  .btn.wide{min-width:160px}

  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(4,7,14,.6);backdrop-filter:blur(3px)}
  .card{width:min(680px,92%);background:linear-gradient(180deg,#0f1422,#0a0f1b);border:1px solid #2a3552;border-radius:16px;padding:20px 18px;box-shadow:0 16px 40px rgba(0,0,0,.45)}
  .card h1{margin:0 0 4px;font-size:26px;letter-spacing:.8px;text-transform:uppercase}
  .card p{margin:8px 0 0;color:#cfe0ff;font-size:14px}
  .bar{height:10px;background:#111827;border:1px solid #26324b;border-radius:999px;overflow:hidden}
  .bar > span{display:block;height:100%;width:0;background:linear-gradient(90deg,#ffd166,#5af38f,#6ab8ff,#ff6b6b)}

  .logo{display:flex;align-items:center;justify-content:center;gap:14px;margin-bottom:14px;letter-spacing:1.2px;text-transform:uppercase;font-weight:900;font-size:28px}
  .logo .dot{width:10px;height:10px;border-radius:50%;background:#fff;opacity:.12;box-shadow:0 0 20px rgba(255,255,255,.25)}
  .logo .word{opacity:.95}
  .sub{font-size:12px;opacity:.65;letter-spacing:.35px;text-transform:uppercase}

  .floatText{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-weight:800;letter-spacing:1px;pointer-events:none;text-shadow:0 2px 10px rgba(0,0,0,.45)}
  .ft-perfect{color:#fff}
  .ft-good{color:#cfe0ff}
  .ft-miss{color:#fda4af}

  /* Ending credits 強化：常時背景アニメ＋手前スクロール */
  .creditsWrap{position:absolute;inset:0;display:none;align-items:flex-end;justify-content:center;pointer-events:none}
  .credits{width:min(700px,92%);max-height:82%;overflow:hidden;position:relative}
  .scroll{display:block;white-space:pre-line;line-height:1.9;letter-spacing:.6px;font-weight:800;text-align:center;text-shadow:0 2px 16px rgba(0,0,0,.65);animation:roll 30s linear forwards; filter: drop-shadow(0 6px 18px rgba(0,0,0,.6));}
  .credits::after{
    content:""; position:absolute; inset:0;
    background:linear-gradient(180deg, rgba(0,0,0,.8), transparent 18%, transparent 82%, rgba(0,0,0,.8));
    pointer-events:none;
  }
  @keyframes roll{from{transform:translateY(100%)}to{transform:translateY(-108%)}}

  /* 画面フラッシュ（コンボ演出） */
  .flash{position:absolute;inset:0;background:rgba(255,255,255,.0);pointer-events:none}
  .flash.show{animation:flashFx .45s ease}
  @keyframes flashFx{0%{background:rgba(255,255,255,.0)}30%{background:rgba(255,255,255,.28)}100%{background:rgba(255,255,255,.0)}}

  @media (max-width:560px){.btn.wide{min-width:140px}}

  /* iOS用 “Tap to enable sound” オーバレイ */
  .unlock{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.65);color:#fff;font-weight:800;letter-spacing:.6px}
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="game">
    <div class="topbar">
      <div class="title">MONOCHROME REBIRTH <span class="stage">/ Rhythm of Colors</span></div>
      <div class="stat">
        <div class="badge">LEVEL: <span id="lv">1</span></div>
        <div class="badge">SCORE: <span id="sc">0</span></div>
        <div class="badge">COMBO: <span id="co">0</span></div>
        <div class="badge">ACC: <span id="ac">100%</span></div>
        <div class="badge">WORLD: <span id="wp">0%</span></div>
        <div class="badge" id="modeBadge" style="display:none">MODE: <span>WA</span></div>
        <div class="badge">VSF: <span id="vfxNow">-</span></div>
      </div>
    </div>

    <div class="board" id="board">
      <canvas id="cv"></canvas>

      <div class="centerHud">
        <div class="chip">BPM: <strong id="bpmTxt">80</strong></div>
        <div class="chip">LANES: <strong id="lanesTxt">4</strong></div>
        <div class="chip">WINDOW: <strong>±50ms / ±150ms</strong></div>
      </div>

      <div class="hitLine"></div>

      <div class="controls">
        <button class="btn" id="tapBtn" title="中央レーン（Spaceでも可）">Tap / Space</button>
        <button class="btn primary wide" id="startBtn">Start</button>
      </div>

      <div class="overlay" id="ov"><div class="card" id="card"></div></div>
      <div class="flash" id="flashFx"></div>

      <!-- Ending credits（背景＝Canvas、前面＝スクロール） -->
      <div class="creditsWrap" id="creditsWrap">
        <div class="credits"><div class="scroll" id="creditsText"></div></div>
      </div>

      <div class="unlock" id="unlock"><div>Tap to enable sound</div></div>
    </div>

    <p style="margin:8px 2px 0;font-size:12px;color:#9fb3df">操作：各レーンをタップ（スマホOK）／Space=中央付近。音が出ない場合は一度「Start」を押してください。</p>
  </div>
</div>

<script>
(() => {
  // ====== Level / Mode ======
  let LEVEL = 1;
  const MAX_LEVEL = 5;
  let isWaMode = false; // Lv2〜5で各50%抽選

  // ====== Constants ======
  const MAX_LANES = 5;
  const BASE_BPM = 80;
  const BPM_STEP = 4;

  let BPM = BASE_BPM, SEC_PER_BEAT = 60/BASE_BPM;
  const LEADIN = 1.0;
  let NOTE_TRAVEL = 2.0;
  const PERFECT = 0.050, GOOD = 0.150;

  const COLOR_ORDER = ['yellow','green','blue','red'];
  const HITS_PER_COLOR = 12;

  let LANE_COUNT = 4;
  const SCALE4 = [261.63, 293.66, 329.63, 392.00];           // C D E G
  const SCALE5 = [246.94, 277.18, 329.63, 369.99, 440.0];    // B C# E F# A
  const SCALE4_WA = [261.63, 293.66, 349.23, 392.00];        // C D F G
  const SCALE5_WA = [261.63, 293.66, 349.23, 392.00, 440.00];// C D F G A

  const HIT_LINE_RATIO = 0.75, SPAWN_RATIO=0.10, BOTTOM_RATIO=0.92;

  // ====== DOM ======
  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  const boardEl = document.getElementById('board');

  const scEl = document.getElementById('sc'), coEl = document.getElementById('co'), acEl = document.getElementById('ac'), wpEl = document.getElementById('wp'), lvEl = document.getElementById('lv');
  const startBtn = document.getElementById('startBtn'), tapBtn = document.getElementById('tapBtn');
  const ov = document.getElementById('ov'), card = document.getElementById('card');
  const bpmTxt = document.getElementById('bpmTxt'), lanesTxt = document.getElementById('lanesTxt'), modeBadge = document.getElementById('modeBadge');
  const vfxNow = document.getElementById('vfxNow');
  const creditsWrap = document.getElementById('creditsWrap'), creditsText = document.getElementById('creditsText');
  const flashFx = document.getElementById('flashFx');
  const unlock = document.getElementById('unlock');

  // ====== Resize ======
  let DPR = window.devicePixelRatio || 1;
  function fitCanvas(){
    const r=canvas.getBoundingClientRect();
    DPR = window.devicePixelRatio || 1;
    canvas.width=(r.width*DPR)|0; canvas.height=(r.height*DPR)|0;
    document.documentElement.style.setProperty('--hit-top',(HIT_LINE_RATIO*100).toFixed(1)+'%');
  }
  addEventListener('resize', fitCanvas, {passive:true}); fitCanvas();

  // ====== State ======
  let audioCtx=null, masterGain=null;
  let layers={}, melodyBus=null, delayNode=null, panNodes=[];
  let bgm=null;
  let particles=[], windStreaks=[], petals=[], lanterns=[];
  let running=false, endingMode=false;

  let chart=[], songStartTime=0, score=0, combo=0, hits=0, judgedCount=0;
  let unlockedIndex=-1, goodHitsForColor=0;
  let targetScore=8000;

  // VSF検出用（今使っている演出だけ表示するために、フレーム毎に収集）
  let vfxUsedFrame = [];

  // ====== Swipe（スワイプで同時ヒット）補助 ======
  let isSwiping=false;
  let swipeLastLane=-1;
  let swipeHitCooldownMs=70;                 // 同じレーンを連打しすぎないよう簡易クールダウン
  const swipeLaneLastHit = new Map();        // lane -> last time (ms)
  const SWIPE_Y_TOL = 48;                    // ヒットライン付近の縦許容(px, 物理)
  function pointerPosToCanvas(e){
    const r=canvas.getBoundingClientRect();
    const cx=(e.clientX - r.left) * DPR;
    const cy=(e.clientY - r.top)  * DPR;
    return {cx,cy};
  }

  // ====== Helpers ======
  const clamp=(v,min=0,max=1)=>Math.max(min,Math.min(max,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const hsl=(h,s,l,a=1)=>`hsla(${h},${(s*100).toFixed(1)}%,${(l*100).toFixed(1)}%,${a})`;
  const colorOf=c=>({'yellow':'#ffd166','green':'#5af38f','blue':'#6ab8ff','red':'#ff6b6b'}[c]||'#ffffff');
  function addAlpha(hex,a){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return hex; const r=parseInt(m[1],16), g=parseInt(m[2],16), b=parseInt(m[3],16); return `rgba(${r},${g},${b},${a})`; }

  // ====== Level params ======
  function applyLevelParams(){
    if(LEVEL>MAX_LEVEL) LEVEL=MAX_LEVEL;
    BPM = BASE_BPM + (LEVEL-1)*BPM_STEP;
    SEC_PER_BEAT = 60 / BPM;
    NOTE_TRAVEL = Math.max(1.5, 2.0 - (LEVEL-1)*0.15);
    LANE_COUNT = (LEVEL>=3)?5:4;

    // ★ Lv2〜Lv5は各50%で和風（Lv1はモノクロ無BGM）
    isWaMode = (LEVEL>=2) ? (Math.random()<0.5) : false;

    bpmTxt.textContent = Math.round(BPM);
    lanesTxt.textContent = LANE_COUNT;
    lvEl.textContent = LEVEL;
    modeBadge.style.display = isWaMode ? 'inline-block' : 'none';
  }

  // ====== Lanes ======
  function laneCenters(){ const W=canvas.width, pad=60*DPR, inner=W-pad*2, gap=inner/LANE_COUNT; return Array.from({length:LANE_COUNT},(_,i)=> pad + gap*(i+0.5)); }
  function laneFromCanvasX(cx){ const cs=laneCenters(); let b=0,m=1e9; for(let i=0;i<cs.length;i++){ const d=Math.abs(cx-cs[i]); if(d<m){m=d;b=i} } return b; }

  // ====== Audio ======
  async function ensureAudioUnlocked(){
    if(!audioCtx){
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
    }
    try{ if(audioCtx.state !== 'running'){ await audioCtx.resume(); } }catch(e){}
    unlock.style.display = (audioCtx.state === 'running') ? 'none' : 'flex';
    return audioCtx.state === 'running';
  }

  function initAudio(){
    if(masterGain) return; // 初期化は一度きり（※resume後に呼ぶ）
    masterGain = audioCtx.createGain(); masterGain.gain.value=0.9; masterGain.connect(audioCtx.destination);

    const amb = makePad({freqs:[110,220,330], gain:0.05}); amb.connect(masterGain);

    layers.yellow=makeLayerGain(); layers.green=makeLayerGain(); layers.blue=makeLayerGain(); layers.red=makeLayerGain();

    melodyBus = audioCtx.createGain(); melodyBus.gain.value=0.8;
    delayNode = audioCtx.createDelay(); delayNode.delayTime.value=0.18;
    const fb=audioCtx.createGain(); fb.gain.value=clamp(0.15+(LEVEL-1)*0.05,0.15,0.5);
    melodyBus.connect(delayNode).connect(fb).connect(delayNode);
    const mix=audioCtx.createGain(); mix.gain.value=0.35+(LEVEL-1)*0.05;
    delayNode.connect(mix).connect(masterGain);
    melodyBus.connect(masterGain);

    panNodes = Array.from({length:MAX_LANES},(_,i)=>{
      const panVal = lerp(-0.8,0.8, i/(Math.max(1,MAX_LANES-1)));
      try{
        if(audioCtx.createStereoPanner){
          const p=audioCtx.createStereoPanner(); p.pan.value=panVal; return p;
        }
        else if(typeof StereoPannerNode!=='undefined'){ return new StereoPannerNode(audioCtx,{pan:panVal}); }
      }catch(e){}
      const g=audioCtx.createGain(); return g;
    });
    panNodes.forEach(p=>p.connect(melodyBus));

    bgm=createBgmEngine();
  }
  function makeLayerGain(){ const g=audioCtx.createGain(); g.gain.value=0; g.connect(masterGain); return g; }
  function makePad({freqs,gain}){ const g=audioCtx.createGain(); g.gain.value=gain;
    freqs.forEach(f=>{ const o=audioCtx.createOscillator(), env=audioCtx.createGain(); env.gain.value=0.0008; o.type='sine'; o.frequency.value=f; o.connect(env).connect(g); o.start();
      const lfo=audioCtx.createOscillator(), lfog=audioCtx.createGain(); lfo.frequency.value=0.07; lfog.gain.value=f*0.015; lfo.connect(lfog).connect(o.frequency); lfo.start(); }); return g; }
  function makePanner(panValue){
    try{ if(audioCtx.createStereoPanner){ const p=audioCtx.createStereoPanner(); p.pan.value=panValue; return p; }
      else if(typeof StereoPannerNode!=='undefined'){ return new StereoPannerNode(audioCtx,{pan:panValue}); } }catch(e){}
    const g=audioCtx.createGain(); return g;
  }

  function playLaneTone(time, lane){
    const scale = isWaMode
      ? ((LANE_COUNT===4)?SCALE4_WA:SCALE5_WA)
      : ((LANE_COUNT===4)?SCALE4:SCALE5);
    const freq=scale[Math.max(0,Math.min(scale.length-1,lane))];

    const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter();
    f.type='lowpass'; f.frequency.value = isWaMode? (1600 + LEVEL*220) : (1800 + LEVEL*300);
    const lfo=audioCtx.createOscillator(), lg=audioCtx.createGain(); lfo.frequency.value=isWaMode? 5: (2+LEVEL*0.5); lg.gain.value=isWaMode? 6: (3+LEVEL*2);
    lfo.connect(lg).connect(o.frequency); lfo.start(time);

    o.type='sine'; o.frequency.value=freq;
    g.gain.setValueAtTime(0.0001,time);
    g.gain.exponentialRampToValueAtTime( (isWaMode?0.28:0.22)+LEVEL*0.02, time+0.015);
    g.gain.exponentialRampToValueAtTime(0.0001, time+ (isWaMode?0.6:0.45) );

    o.connect(f).connect(g).connect(panNodes[lane]||melodyBus);
    o.start(time); o.stop(time+(isWaMode?0.7:0.6));

    if(isWaMode){
      const n=audioCtx.createBuffer(1, audioCtx.sampleRate*0.2, audioCtx.sampleRate);
      const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.exp(-i/(audioCtx.sampleRate*0.02)); }
      const s=audioCtx.createBufferSource(); s.buffer=n;
      const ng=audioCtx.createGain(); ng.gain.setValueAtTime(0.0006,time); ng.gain.exponentialRampToValueAtTime(0.06,time+0.02); ng.gain.exponentialRampToValueAtTime(0.0001,time+0.12);
      s.connect(ng).connect(panNodes[lane]||melodyBus); s.start(time);
    }
  }

  // SFX by color（和／洋切替）
  function colorSfx(t){
    const name=COLOR_ORDER[Math.max(0,unlockedIndex)]; if(!name) return;
    if(isWaMode){
      if(name==='yellow'){ taikoLow(t); woodClap(t+0.03); }
      if(name==='green'){ kotoPluck(t); }
      if(name==='blue'){ shinobue(t); }
      if(name==='red'){ shakuhachiFall(t); }
      return;
    }
    if(name==='yellow'){ softKick(t); bell(t+0.02); }
    if(name==='green'){ arp(t); }
    if(name==='blue'){ bass(t); }
    if(name==='red'){ lead(t); }
  }
  // --- Western SFX
  function softKick(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(140,t); o.frequency.exponentialRampToValueAtTime(55,t+0.12);
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.28+LEVEL*0.02,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.2);}
  function bell(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=660+LEVEL*10;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16+LEVEL*0.01,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.5); o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.6);}
  function bass(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter(); o.type='sawtooth'; o.frequency.value=55; f.type='lowpass'; f.frequency.value=200+LEVEL*40;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.20+LEVEL*0.02,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.3); o.connect(f).connect(g).connect(layers.blue); o.start(t); o.stop(t+0.35);}
  function arp(t){ [440,523.25,587.33,659.25].forEach((fr,i)=>{ const tt=t+i*(0.07-LEVEL*0.003); const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='sine'; o.frequency.value=fr+LEVEL*3; g.gain.setValueAtTime(0.001,tt); g.gain.exponentialRampToValueAtTime(0.12+LEVEL*0.01,tt+0.01); g.gain.exponentialRampToValueAtTime(0.001,tt+0.18);
      o.connect(g).connect(layers.green); o.start(tt); o.stop(tt+0.22); });}
  function lead(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter(); o.type='sine'; o.frequency.value=880+LEVEL*12; f.type='lowpass'; f.frequency.value=1800+LEVEL*120;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16+LEVEL*0.01,t+0.015); g.gain.exponentialRampToValueAtTime(0.0001,t+0.5); o.connect(f).connect(g).connect(layers.red); o.start(t); o.stop(t+0.52);}

  // --- Wa SFX
  function taikoLow(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(100,t); o.frequency.exponentialRampToValueAtTime(45,t+0.14);
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.35,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.22); o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.25); }
  function woodClap(t){ const n=audioCtx.createBuffer(1, audioCtx.sampleRate*0.05, audioCtx.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.exp(-i/(audioCtx.sampleRate*0.005)); }
    const s=audioCtx.createBufferSource(), g=audioCtx.createGain(); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.18,t+0.005); g.gain.exponentialRampToValueAtTime(0.0001,t+0.05);
    s.buffer=n; s.connect(g).connect(layers.yellow); s.start(t); }
  function kotoPluck(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter(); o.type='triangle'; f.type='bandpass'; f.frequency.value=1800;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16,t+0.008); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2);
    o.connect(f).connect(g).connect(layers.green); o.start(t); o.stop(t+0.22); }
  function shinobue(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.value=523.25;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.10,t+0.03); g.gain.exponentialRampToValueAtTime(0.0001,t+0.25);
    o.connect(g).connect(layers.blue); o.start(t); o.stop(t+0.3); }
  function shakuhachiFall(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(880,t); o.frequency.exponentialRampToValueAtTime(660,t+0.28);
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.14,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.45); o.connect(g).connect(layers.red); o.start(t); o.stop(t+0.5); }

  // ====== BGM Engine ======
  function createBgmEngine(){
    const bus={drum:audioCtx.createGain(), bass:audioCtx.createGain(), pad:audioCtx.createGain(), arp:audioCtx.createGain(), lead:audioCtx.createGain(), mix:audioCtx.createGain(),
      stop(){}, start(startTime){ this.scheduleAll(startTime);} };
    [bus.drum,bus.bass,bus.pad,bus.arp,bus.lead].forEach(n=> n.gain.value=0);
    bus.drum.connect(bus.mix); bus.bass.connect(bus.mix); bus.pad.connect(bus.mix); bus.arp.connect(bus.mix); bus.lead.connect(bus.mix); bus.mix.gain.value=0.8; bus.mix.connect(masterGain);

    bus.scheduleAll=(startTime)=>{
      const beatsTotal=64;
      const useDrum=LEVEL>=2, useBass=LEVEL>=3, usePad=LEVEL>=4;
      const useArp = LEVEL>=5, useLead=LEVEL>=5;

      const now=audioCtx.currentTime;
      const fade=(node,target)=>{ node.gain.cancelScheduledValues(now); node.gain.setValueAtTime(node.gain.value,now); node.gain.linearRampToValueAtTime(target, now+1.2); };

      // Lvごとバランス（和はドラム強・アルペジオ前面）
      if(isWaMode){
        fade(bus.drum, useDrum?0.95:0);
        fade(bus.bass, useBass?0.6:0);
        fade(bus.pad , usePad ?0.55:0);
        fade(bus.arp , useArp ?0.55:(LEVEL>=3?0.35:0));
        fade(bus.lead, useLead?0.42:0);
      }else{
        fade(bus.drum,useDrum?0.9:0); fade(bus.bass,useBass?0.7:0); fade(bus.pad,usePad?0.55:0); fade(bus.arp,useArp?0.5:0); fade(bus.lead,useLead?0.4:0);
      }

      const beatToTime=(beat)=> startTime + LEADIN + beat*SEC_PER_BEAT;

      if(isWaMode){
        for(let m=0;m<beatsTotal;m+=8){
          // 太鼓／拍子木（Lv2〜段階的に）
          if(LEVEL>=2){ [0,2,4,6].forEach(off=> taiko(beatToTime(m+off))); }
          if(LEVEL>=3){ [1.5,5.5].forEach(off=> wood(beatToTime(m+off))); }
          // 琴アルペジオ（Lv3〜）
          if(LEVEL>=3){ for(let i=0;i<8;i++){ const t=beatToTime(m)+i*(SEC_PER_BEAT/2); kotoArp(t); } }
        }
        // 尺八リード（Lv5）
        if(LEVEL>=5){ for(let m=8;m<beatsTotal;m+=8){ [0,3.5,6].forEach(off=> shakuhachi(beatToTime(m+off))); } }
      }else{
        if(useDrum){
          [0,2,4,6].forEach(b=> kick(beatToTime(b)));
          [2,6].forEach(b=> snare(beatToTime(b)));
          for(let i=0;i<beatsTotal*2;i++) hat(beatToTime(i*0.5));
          for(let m=0;m<beatsTotal;m+=8){ hat(beatToTime(m+7.5),1.5); }
        }
        if(useBass){
          const root=55;
          for(let m=0;m<beatsTotal;m+=8){
            [0,2,4,6].forEach(off=> bassEv(beatToTime(m+off),root));
            [1,5].forEach(off=> bassEv(beatToTime(m+off),root*1.5));
            [3,7].forEach(off=> bassEv(beatToTime(m+off),root*2));
          }
        }
        if(usePad){
          const prog=[[0,4,7],[2,5,9],[4,7,11],[5,9,12]];
          for(let s=0;s<beatsTotal;s+=8){ const ch=prog[(s/8)%prog.length]; padEv(beatToTime(s),ch,8*SEC_PER_BEAT); }
        }
        if(useArp){
          for(let m=0;m<beatsTotal;m+=8){ for(let b=0;b<8;b+=2){ for(let i=0;i<8;i++){ arpEv(beatToTime(m+b)+i*(SEC_PER_BEAT/4)); } } }
        }
        if(useLead){
          for(let m=16;m<beatsTotal;m+=8){ [0,1.5,3,4.5,6].forEach(off=> leadEv(beatToTime(m+off))); }
        }
      }

      // ---- Western subs ----
      function kick(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(140,t); o.frequency.exponentialRampToValueAtTime(55,t+0.12);
        g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.28+(LEVEL-2)*0.02,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g).connect(bus.drum); o.start(t); o.stop(t+0.2);}
      function snare(t){ const n=audioCtx.createBuffer(1, audioCtx.sampleRate*0.2, audioCtx.sampleRate); const d=n.getChannelData(0);
        for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.exp(-i/(audioCtx.sampleRate*0.03)); }
        const s=audioCtx.createBufferSource(), g=audioCtx.createGain(); g.gain.setValueAtTime(0.001,t); g.gain.exponentialRampToValueAtTime(0.22+(LEVEL-2)*0.02,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2);
        s.buffer=n; s.connect(g).connect(bus.drum); s.start(t);}
      function hat(t,m=1){ const n=audioCtx.createBuffer(1, audioCtx.sampleRate*0.08, audioCtx.sampleRate); const d=n.getChannelData(0);
        for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.exp(-i/(audioCtx.sampleRate*0.01)); }
        const s=audioCtx.createBufferSource(), g=audioCtx.createGain(); g.gain.setValueAtTime(0.0008*m,t); g.gain.exponentialRampToValueAtTime(0.08*m,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.06);
        s.buffer=n; s.connect(g).connect(bus.drum); s.start(t);}
      function bassEv(t,f0){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter(); o.type='sawtooth'; o.frequency.setValueAtTime(f0,t);
        f.type='lowpass'; f.frequency.setValueAtTime(220+LEVEL*40,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.25+(LEVEL-3)*0.02,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.32);
        o.connect(f).connect(g).connect(bus.bass); o.start(t); o.stop(t+0.36);}
      function padEv(t,semis,dur){ const g=audioCtx.createGain(); g.gain.value=0.0; g.connect(bus.pad); g.gain.linearRampToValueAtTime(0.35,t+0.3); g.gain.linearRampToValueAtTime(0.0,t+dur-0.2);
        semis.forEach(se=>{ const o=audioCtx.createOscillator(), f=audioCtx.createBiquadFilter(); o.type='sine'; o.frequency.value=220*Math.pow(2,se/12); f.type='lowpass'; f.frequency.value=1200+LEVEL*200; o.connect(f).connect(g); o.start(t); o.stop(t+dur); });}
      function arpEv(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=440*Math.pow(2, ((Math.random()<0.5?0:7))/12);
        g.gain.setValueAtTime(0.0008,t); g.gain.exponentialRampToValueAtTime(0.08+(LEVEL-5)*0.01,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.14); o.connect(g).connect(bus.arp); o.start(t); o.stop(t+0.16);}
      function leadEv(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.value=660+LEVEL*8;
        g.gain.setValueAtTime(0.0008,t); g.gain.exponentialRampToValueAtTime(0.12+(LEVEL-5)*0.01,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.28); o.connect(g).connect(bus.lead); o.start(t); o.stop(t+0.3);}

      // ---- Wa subs ----
      function taiko(t){ taikoLow(t); }
      function wood(t){ woodClap(t); }
      function kotoArp(t){
        const scale = SCALE5_WA;
        const idxs=[0,2,3,4,2,1,0];
        idxs.forEach((si,i)=>{
          const tt=t+i*(SEC_PER_BEAT/4);
          const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter(); o.type='triangle';
          f.type='bandpass'; f.frequency.value=1800;
          o.frequency.value = scale[si];
          g.gain.setValueAtTime(0.0001,tt); g.gain.exponentialRampToValueAtTime(0.12, tt+0.01); g.gain.exponentialRampToValueAtTime(0.0001, tt+0.18);
          o.connect(f).connect(g).connect(bus.arp); o.start(tt); o.stop(tt+0.2);
        });
      }
      function shakuhachi(t){
        const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine';
        o.frequency.setValueAtTime(880, t); o.frequency.exponentialRampToValueAtTime(660, t+0.28);
        g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.14,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.45);
        o.connect(g).connect(bus.lead); o.start(t); o.stop(t+0.5);
      }
    };
    return bus;
  }

  // ====== Chart ======
  function buildChart(){
    chart = [];
    const blocks=8;
    const chordProb=clamp(0.10+(LEVEL-1)*0.06,0.1, isWaMode?0.45:0.5);
    const extraNotes=(LEVEL-1)*2;

    const slotCapPerLane=3, SLOT_Q=0.25;
    const laneSlotCount=new Map();

    let beat=0;
    for(let b=0;b<blocks;b++){
      const base=beat;
      const patt=(b%2===0)
        ? [0,0,2, 2,1, 3, 4, 5.5, 6, 7.5]
        : [0,1, 1.75, 2.5, 3.25, 4.0,5.0, 6.0, 7.0];

      patt.forEach(off=>{
        const lanes=[randLane()];
        if(Math.random()<chordProb){ let l2=randLane(); if(l2===lanes[0]) l2=(l2+1)%LANE_COUNT; lanes.push(l2); }
        pushWithCap(base+off, lanes);
      });
      for(let i=0;i<extraNotes;i++){ pushWithCap(base+randRange(0,8,true), [randLane()]); }
      beat+=8;
    }
    chart.forEach(n=> n.time = LEADIN + n.beat*SEC_PER_BEAT);

    if(chart.length===0){
      for(let i=0;i<16;i++){ chart.push({beat:i*0.5, time:0, notes:[{lane:(i%LANE_COUNT)}], judged:false, hitCount:0, missed:false}); }
      chart.forEach(n=> n.time = LEADIN + n.beat*SEC_PER_BEAT);
    }
    const approx = chart.reduce((s,n)=> s+n.notes.length, 0);
    targetScore = Math.max(10000, Math.floor(approx*900*0.75));

    function pushWithCap(beat, lanes){
      const outLanes=[]; const slot=Math.round(beat/SLOT_Q)*SLOT_Q;
      for(const lane of lanes){
        if(tryPlace(lane, slot)){ outLanes.push(lane); continue; }
        const alt=(lane+1)%LANE_COUNT;
        if(tryPlace(alt, slot)){ outLanes.push(alt); continue; }
        const slot2=slot+SLOT_Q;
        if(tryPlace(lane, slot2)){ chart.push({beat:slot2, time:0, notes:[{lane}], judged:false, hitCount:0, missed:false}); continue; }
      }
      if(outLanes.length){ chart.push({beat, time:0, notes:outLanes.map(l=>({lane:l})), judged:false, hitCount:0, missed:false}); }
    }
    function tryPlace(lane, slot){ const key=`${lane}@${slot.toFixed(2)}`; const cur=laneSlotCount.get(key)||0; if(cur<slotCapPerLane){ laneSlotCount.set(key, cur+1); return true; } return false; }
    function randLane(){ return (Math.random()*LANE_COUNT)|0; }
    function randRange(a,b,half){ return half ? (a + Math.round(Math.random()*(b-a)*2)/2) : (a + Math.random()*(b-a)); }
  }

  // ====== VFX ======
  function addBurst(x,y,color,count=20,speed=2){ for(let i=0;i<count;i++){ const ang=Math.random()*Math.PI*2, sp=(Math.random()*0.8+0.2)*speed;
    particles.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,life:1,color,type:'burst'}) } }
  function addFireworks(x,y,colors){ const rings=3+Math.min(LEVEL,3); for(let r=0;r<rings;r++){ const c=colors[r%colors.length]; addBurst(x,y,c,28+r*10,2.5+r*0.8); } }
  function addConfetti(n=20){ const W=canvas.width,H=canvas.height, cols=unlockedColors();
    for(let i=0;i<n;i++){ const c=cols[i%cols.length]||'#fff'; particles.push({x:Math.random()*W,y:-20,vx:(Math.random()*2-1)*1.5,vy:Math.random()*2+1,life:1.2,color:c,type:'confetti',rot:Math.random()*Math.PI*2}); } }
  function unlockedColors(){ const arr=[]; for(let i=0;i<=unlockedIndex;i++) arr.push(colorOf(COLOR_ORDER[i])); return arr.length?arr:['#ffffff']; }
  function spawnWind(){ const W=canvas.width,H=canvas.height,n=2+LEVEL; for(let i=0;i<n;i++){ windStreaks.push({x:-50,y:Math.random()*H*0.8,vx:3+LEVEL*0.8+combo*0.01,vy:(Math.random()*2-1)*0.2,alpha:0.03+0.02*LEVEL,life:1}); } }

  // 和風追加：桜と提灯
  function spawnSakura(count=6){
    const W=canvas.width, H=canvas.height;
    for(let i=0;i<count;i++){
      petals.push({ x:Math.random()*W, y:-20, vx:-0.6-Math.random()*1.2, vy:1.2+Math.random()*1.2, rot:Math.random()*Math.PI*2, vr:0.02+Math.random()*0.04, life:1.8 });
    }
  }
  function drawSakura(){
    const H=canvas.height, W=canvas.width;
    for(const p of petals){
      p.x+=p.vx; p.y+=p.vy; p.rot+=p.vr; p.life-=0.006;
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.globalAlpha = Math.max(0, p.life*0.9);
      ctx.fillStyle = 'rgba(255,182,193,0.9)';
      ctx.beginPath();
      ctx.ellipse(0,0,6*DPR,3*DPR, Math.PI/4, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    petals = petals.filter(p=> p.y < H+30 && p.x > -40 && p.life>0);
    if(Math.random()<0.05) spawnSakura(3+((LEVEL>=5)?4:0));
  }
  function spawnLanterns(){
    const W=canvas.width, H=canvas.height;
    for(let i=0;i<2;i++){
      lanterns.push({x:Math.random()*W, y:H+20, vy:-0.4-Math.random()*0.6, sway:(Math.random()*0.8+0.3), t:Math.random()*Math.PI*2});
    }
  }
  function drawLanterns(){
    const W=canvas.width;
    for(const l of lanterns){
      l.t+=0.02; l.x += Math.sin(l.t)*l.sway; l.y += l.vy;
      ctx.save(); ctx.translate(l.x,l.y);
      const grd = ctx.createRadialGradient(0,0,2*DPR, 0,0,16*DPR);
      grd.addColorStop(0,'rgba(255,180,80,0.95)');
      grd.addColorStop(1,'rgba(255,120,40,0.0)');
      ctx.fillStyle=grd; ctx.fillRect(-20*DPR,-20*DPR,40*DPR,40*DPR);
      ctx.restore();
    }
    lanterns = lanterns.filter(l=> l.y>-30 && l.x>-30 && l.x< (canvas.width+30));
    if(Math.random()<0.02) spawnLanterns();
  }

  // ====== World progress ======
  function colorProgress(){ const total=COLOR_ORDER.length*HITS_PER_COLOR; return clamp(((unlockedIndex+1)*HITS_PER_COLOR+goodHitsForColor)/total); }
  const scoreProgress=()=> clamp(score/targetScore);
  const worldProgress=()=> clamp(0.4*colorProgress()+0.6*scoreProgress());
  function applyWorldVisuals(){
    const p=worldProgress();
    wrap.style.setProperty('--gray',(1-p).toFixed(3));

    if(isWaMode){
      const top = hsl(30+30*p, 0.8, 0.28+0.12*p, 1);
      const bot = hsl(210-30*p, 0.6+0.25*p, 0.15+0.25*p, 1);
      document.documentElement.style.setProperty('--bg-top', top);
      document.documentElement.style.setProperty('--bg-bot', bot);
    }else{
      const topHue=lerp(220,200,p), topSat=lerp(0.20,0.70,p), topLum=lerp(0.05,0.25,p);
      const botHue=lerp(220,45,p), botSat=lerp(0.18,0.85,p), botLum=lerp(0.08,0.42,p);
      document.documentElement.style.setProperty('--bg-top',hsl(topHue,topSat,topLum,1));
      document.documentElement.style.setProperty('--bg-bot',hsl(botHue,botSat,botLum,1));
    }
    wpEl.textContent=Math.round(p*100)+'%';
  }

  // ====== Game control ======
  function startGame(){
    endingMode=false; creditsWrap.style.display='none';
    applyLevelParams(); buildChart();
    running=true; score=0; combo=0; hits=0; judgedCount=0; unlockedIndex=-1; goodHitsForColor=0; updateStats();
    ov.style.display='none'; particles.length=0; windStreaks.length=0; petals.length=0; lanterns.length=0;
    const now=audioCtx.currentTime; Object.values(layers).forEach(g=>{ g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(0,now); }); melodyBus.gain.setValueAtTime(0.8, now);
    songStartTime = now + 0.10; applyWorldVisuals();
    if(bgm){ /*noop*/ } if(LEVEL>=2){ bgm.start(songStartTime); }
    requestAnimationFrame(loop);
  }

  function unlockNextColor(){
    if(unlockedIndex>=COLOR_ORDER.length-1) return;
    unlockedIndex++; goodHitsForColor=0;
    const name=COLOR_ORDER[unlockedIndex], now=audioCtx.currentTime, g=layers[name]; if(g){ g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(g.gain.value,now); g.gain.linearRampToValueAtTime(0.7+0.05*LEVEL, now+1.0); }
    const cx=canvas.width/2, cy=canvas.height*0.35;
    const cols=isWaMode? ['#ffd166','#ff8fab','#c0ffaa','#88ccff'] : unlockedColors();
    addFireworks(cx,cy,cols); addConfetti(25+LEVEL*8);
    floatText(isWaMode? '+ 彩 解放' : `+ ${name.toUpperCase()}`,'ft-perfect'); applyWorldVisuals();
  }

  // ====== Input / Swipe support ======
  function withinHitY(cy){
    const r=canvas.getBoundingClientRect();
    const hitY = r.height * HIT_LINE_RATIO; // 物理px
    return Math.abs((cy/DPR) - hitY) <= SWIPE_Y_TOL;
  }
  function onTapAtCanvas(clientX){ if(!running||!audioCtx||endingMode) return; const r=canvas.getBoundingClientRect(); const cx=(clientX-r.left)*DPR; judgeTap(laneFromCanvasX(cx), false); }
  function onTapButton(){ judgeTap(Math.floor(LANE_COUNT/2), false); }

  boardEl.addEventListener('pointerdown', e=>{
    e.preventDefault();
    if(e.pointerType==='mouse'&&e.button!==0) return;
    isSwiping=true;
    const {cx,cy}=pointerPosToCanvas(e);
    swipeLastLane = laneFromCanvasX(cx);
    if(withinHitY(cy)){
      const now=performance.now();
      const last=swipeLaneLastHit.get(swipeLastLane)||0;
      if(now-last>swipeHitCooldownMs){ judgeTap(swipeLastLane, true); swipeLaneLastHit.set(swipeLastLane, now); }
    }else{
      onTapAtCanvas(e.clientX);
    }
  }, {passive:false});

  boardEl.addEventListener('pointermove', e=>{
    if(!isSwiping) return;
    const {cx,cy}=pointerPosToCanvas(e);
    const lane = laneFromCanvasX(cx);
    if(lane===swipeLastLane) return;

    // スワイプ方向の全レーンを一気にヒット（一直線でなぞる要件）
    const step = lane>swipeLastLane ? 1 : -1;
    for(let l=swipeLastLane+step; l!==lane+step; l+=step){
      if(!withinHitY(cy)) break;
      const now=performance.now();
      const last=swipeLaneLastHit.get(l)||0;
      if(now-last>swipeHitCooldownMs){
        judgeTap(l, true);
        swipeLaneLastHit.set(l, now);
      }
    }
    swipeLastLane = lane;
  }, {passive:true});

  addEventListener('pointerup', ()=>{ isSwiping=false; }, {passive:true});
  addEventListener('pointercancel', ()=>{ isSwiping=false; }, {passive:true});

  addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); onTapButton(); }}, {passive:false});
  tapBtn.addEventListener('click', onTapButton);
  startBtn.addEventListener('click', () => { showStartOverlay(); });

  // ====== Hit / Stats & Combo演出 ======
  function judgeTap(lane, fromSwipe){
    const t=audioCtx.currentTime - songStartTime;
    let best=null,bestAdt=1e9,bestIdx=-1;
    for(let i=0;i<chart.length;i++){
      const n=chart[i];
      if(n.judged && n.hitCount>=n.notes.length) continue;
      if(!n.notes.some(nt=>nt.lane===lane && !nt.hit)) continue;
      const dt=n.time - t, adt=Math.abs(dt);
      if(adt<bestAdt){ bestAdt=adt; best=n; bestIdx=i; }
      if(dt<-GOOD && !n.missed){ n.missed=true; n.judged=true; judgedCount++; combo=0; updateStats(); }
    }
    if(!best) return;
    const adiff=Math.abs(best.time - t);
    if(adiff<=PERFECT) applyHit(bestIdx,lane,'PERFECT', fromSwipe);
    else if(adiff<=GOOD) applyHit(bestIdx,lane,'GOOD', fromSwipe);
    else { if(!fromSwipe){ floatText('MISS','ft-miss'); combo=0; updateStats(); } }
  }

  function applyHit(noteIndex,lane,grade, fromSwipe){
    const n=chart[noteIndex]; const part=n.notes.find(nt=>nt.lane===lane && !nt.hit); if(!part) return;
    // 通常ヒット
    doHit(n, part, grade);

    // スワイプ時：同時刻の同一ノート内の残りレーンも、なぞれば個別に判定されるが、
    // 「一直線なぞり」で通過した瞬間にまとめて拾えるよう、近接レーンを補助的にヒット
    if(fromSwipe){
      const neighbors = n.notes.filter(nt=>!nt.hit && Math.abs(nt.lane-lane)<=1);
      for(const nb of neighbors){ doHit(n, nb, grade==='PERFECT'?'GOOD':grade); }
    }

    if(n.hitCount>=n.notes.length){ n.judged=true; judgedCount++; }
    updateStats(); applyWorldVisuals();
  }

  function doHit(n, part, grade){
    part.hit=true; n.hitCount++;
    const now=audioCtx.currentTime;
    const add=(grade==='PERFECT'?1000:650)*(1+Math.floor(combo/25)*0.1); score+=add; combo++; hits++; goodHitsForColor++;
    if(goodHitsForColor>=HITS_PER_COLOR){ unlockNextColor(); }
    playLaneTone(now,part.lane); colorSfx(now);

    // 視覚演出
    const centers=laneCenters(), x=centers[part.lane], y=canvas.height*HIT_LINE_RATIO;
    const c = isWaMode
      ? ['#ffd166','#ff8fab','#c0ffaa','#88ccff'][part.lane % 4]
      : (unlockedColors()[(part.lane+n.notes.length)%unlockedColors().length]||'#ffffff');
    addBurst(x,y,c, Math.round(16+worldProgress()*24)+(n.notes.length>1?6:0), 2.1);

    // 判定テキスト（スワイプ時は控えめ）
    if(combo%5===0 || !arguments[3]){ floatText(grade, grade==='PERFECT'?'ft-perfect':'ft-good'); }

    // コンボ演出
    if(combo===10){ flashOnce(0.18); }
    else if(combo===25){ addConfetti(20+LEVEL*6); }
    else if(combo===50){
      addFireworks(canvas.width*0.5, canvas.height*0.32, isWaMode?['#ffd166','#ff8fab','#c0ffaa','#88ccff']:unlockedColors());
      flashOnce(0.28);
      spawnLanterns();
    }else if(combo===100){
      addFireworks(canvas.width*0.3, canvas.height*0.28, isWaMode?['#ffd166','#ff8fab','#c0ffaa','#88ccff']:unlockedColors());
      addFireworks(canvas.width*0.7, canvas.height*0.28, isWaMode?['#ffd166','#ff8fab','#c0ffaa','#88ccff']:unlockedColors());
      flashOnce(0.36);
      spawnLanterns();
    }
  }

  function updateStats(){ scEl.textContent=score|0; coEl.textContent=combo|0; const acc=judgedCount?(hits/judgedCount):1; acEl.textContent=(acc*100).toFixed(0)+'%'; wpEl.textContent=Math.round(worldProgress()*100)+'%'; }
  function flashOnce(power=0.25){ flashFx.classList.remove('show'); void flashFx.offsetWidth; flashFx.style.setProperty('opacity', power); flashFx.classList.add('show'); }

  function floatText(txt, cls){
    const d=document.createElement('div'); d.className=`floatText ${cls}`; d.textContent=txt; d.style.opacity='0'; boardEl.appendChild(d);
    d.animate([{transform:'translate(-50%,-10%) scale(0.9)',opacity:0},{transform:'translate(-50%,-50%) scale(1.0)',opacity:1,offset:.35},{transform:'translate(-50%,-70%) scale(1.1)',opacity:0}], {duration:900,easing:'ease-out'}).onfinish=()=>d.remove();
  }

  // ====== Render ======
  let waveTime=0, auroraTime=0, raysT=0;
  function loop(){
    if(!running || endingMode) return;
    const W=canvas.width,H=canvas.height; ctx.clearRect(0,0,W,H);
    const p=worldProgress();

    // 背景
    const usedVfx = []; // このフレームで実際に使った演出のみ収集
    if(isWaMode){
      const g0=ctx.createLinearGradient(0,0,0,H);
      g0.addColorStop(0, hsl(35, 0.8, 0.35+0.15*p, 0.8));
      g0.addColorStop(1, hsl(200, 0.6, 0.20+0.20*p, 0.9));
      ctx.fillStyle=g0; ctx.fillRect(0,0,W,H);
      usedVfx.push('Gold Clouds');

      // 光芒
      raysT += 0.005+0.01*p;
      for(let i=0;i<12;i++){
        const ang = (i/12)*Math.PI*2 + raysT;
        const x = W/2 + Math.cos(ang)*40*DPR, y = H*0.3 + Math.sin(ang)*20*DPR;
        const grd=ctx.createRadialGradient(x,y,10*DPR, x,y, W*0.8);
        grd.addColorStop(0, 'rgba(255,220,120,0.08)');
        grd.addColorStop(1, 'rgba(255,220,120,0.00)');
        ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);
      }
      usedVfx.push('Sunrays');
    }else{
      const baseHue=lerp(220,60,p), baseCol=hsl(baseHue,lerp(0.25,0.85,p),lerp(0.25,0.55,p), lerp(0.10,0.35,p));
      const g0=ctx.createRadialGradient(W/2,H*0.25,10, W/2,H*0.25, Math.max(W,H)*0.9); g0.addColorStop(0,baseCol); g0.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=g0; ctx.fillRect(0,0,W,H);
    }

    drawLanes( isWaMode ? lerp(0.02,0.06,p) : lerp(0.03,0.08,p) );

    // 風
    if(Math.random()<0.01+LEVEL*0.004) spawnWind();
    ctx.lineCap='round';
    windStreaks.forEach(w=>{ ctx.globalAlpha=w.alpha; ctx.strokeStyle=isWaMode?'rgba(255,230,170,0.9)':'white'; ctx.lineWidth=3*DPR; ctx.beginPath(); ctx.moveTo(w.x,w.y); ctx.lineTo(w.x+60,w.y+8); ctx.stroke(); w.x+=w.vx; w.y+=w.vy; w.life-=0.01; });
    windStreaks=windStreaks.filter(w=> w.x<W+80 && w.life>0); ctx.globalAlpha=1;
    usedVfx.push('Wind');

    if(isWaMode){
      drawSakura(); if(petals.length) usedVfx.push('Sakura');
      drawLanterns(); if(lanterns.length) usedVfx.push('Lanterns');
      if(p>0.4){
        const waveAmp=10*DPR;
        for(let li=0; li<3; li++){
          const yy = H*(0.62 + 0.04*li);
          ctx.globalAlpha=0.05+0.05*p;
          ctx.fillStyle='rgba(200,230,255,0.6)';
          ctx.beginPath();
          ctx.moveTo(0,H);
          for(let x=0;x<=W;x+=12*DPR){
            const y= yy + Math.sin((x/(80*DPR))+waveTime*(0.5+li*0.1))*waveAmp*(0.5+li*0.2);
            ctx.lineTo(x,y);
          }
          ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
        }
        ctx.globalAlpha=1;
        usedVfx.push('Seigaiha');
      }
    }else{
      // 洋：波
      if(unlockedIndex>=2){
        waveTime += 0.016 + p*0.008;
        const amp=8*DPR+16*DPR*p, layers=3+LEVEL;
        for(let li=0; li<layers; li++){
          const yy=H*(0.62+0.03*li); ctx.globalAlpha=0.05+0.05*p; ctx.fillStyle=colorOf('blue'); ctx.beginPath(); ctx.moveTo(0,H);
          for(let x=0;x<=W;x+=12*DPR){ const y=yy + Math.sin((x/(80*DPR))+waveTime*(0.6+li*0.1))*amp*(0.5+li*0.2); ctx.lineTo(x,y); }
          ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
        }
        ctx.globalAlpha=1;
        usedVfx.push('Waves');
      }
      if(p>0.55){
        auroraTime += 0.005 + 0.01*p;
        const bands=2+Math.floor(p*3), cols=unlockedColors().length?unlockedColors():['#a8b6ff'];
        for(let b=0;b<bands;b++){
          const yy=H*(0.18+0.18*b), grad=ctx.createLinearGradient(0,yy,W,yy);
          grad.addColorStop(0, addAlpha(cols[b%cols.length],0.08)); grad.addColorStop(0.5, addAlpha(cols[(b+1)%cols.length],0.18)); grad.addColorStop(1, addAlpha(cols[(b+2)%cols.length],0.08));
          ctx.fillStyle=grad; ctx.globalAlpha=0.5*p; ctx.fillRect(0, yy + Math.sin(auroraTime*1.1+b)*8*DPR, W, 12*DPR); ctx.globalAlpha=1;
        }
        usedVfx.push('Aurora');
      }
    }

    // 判定ライン
    const lineY=H*HIT_LINE_RATIO; ctx.globalAlpha=0.28; ctx.fillStyle=isWaMode?'rgba(255,230,170,0.9)':'#ffffff'; ctx.fillRect(W*0.1,lineY-2*DPR, W*0.8,4*DPR); ctx.globalAlpha=1;

    // 時刻
    const t = audioCtx ? (audioCtx.currentTime - songStartTime) : 0;
    const spawnY=H*SPAWN_RATIO, bottomY=H*BOTTOM_RATIO;

    // ノーツ
    for(const n of chart){
      if(!n.judged && (t - n.time) > GOOD){ n.missed=true; n.judged=true; judgedCount++; combo=0; updateStats(); }
      const progress = 1 - ((n.time - t) / NOTE_TRAVEL);
      if(progress < -0.2 || progress > 1.3) continue;
      let y; if(progress<=1){ y = spawnY + (lineY - spawnY) * Math.max(0, Math.min(1, progress)); } else { const p2 = Math.min(1,(progress-1)/0.3); y = lineY + (bottomY - lineY) * p2; }
      const centers=laneCenters(); for(const part of n.notes){
        const x=centers[part.lane];
        const r=16*DPR*(1+0.12*Math.cos(n.beat*0.7))*(n.notes.length>1?1.1:1);
        const cMix = isWaMode
          ? ['#ffd166','#ff8fab','#c0ffaa','#88ccff'][ (part.lane+n.notes.length) % 4 ]
          : (unlockedColors()[(part.lane + n.notes.length)%unlockedColors().length] || '#d0d7ea');
        ctx.save();
        ctx.shadowColor = addAlpha(cMix, 0.6); ctx.shadowBlur = r*0.8;
        ctx.fillStyle = addAlpha(cMix, 0.92);
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0; ctx.fillStyle = addAlpha('#ffffff', isWaMode?0.75:0.85);
        ctx.beginPath(); ctx.arc(x, y, r*0.45, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    // 粒子
    for(const ptl of particles){
      ptl.x+=ptl.vx; ptl.y+=ptl.vy; ptl.vy+=0.05; ptl.life-=0.02;
      ctx.globalAlpha = Math.max(0,ptl.life);
      ctx.fillStyle = ptl.color; ctx.beginPath(); ctx.arc(ptl.x,ptl.y,3*DPR,0,Math.PI*2); ctx.fill();
    }
    particles = particles.filter(p=>p.life>0); ctx.globalAlpha=1;

    // VSF（このフレームで実際に使ったものだけ表示）
    vfxNow.textContent = usedVfx.length ? usedVfx.join(' / ') : '-';

    // 終了判定
    const lastTime=chart.length?chart[chart.length-1].time:0;
    if(t > lastTime + 3){ endSong(); return; }

    requestAnimationFrame(loop);
  }
  function drawLanes(alpha=0.05){ const W=canvas.width,H=canvas.height, cs=laneCenters(); const laneW=(cs[1]-cs[0])||(W*0.6/LANE_COUNT), w=laneW*0.9;
    cs.forEach(cx=>{ const grad=ctx.createLinearGradient(cx-w/2,0,cx+w/2,0); grad.addColorStop(0,`rgba(255,255,255,${alpha})`); grad.addColorStop(0.5,`rgba(255,255,255,${alpha*1.8})`); grad.addColorStop(1,`rgba(255,255,255,${alpha})`); ctx.fillStyle=grad; ctx.fillRect(cx-w/2,0,w,H); });
  }

  // ====== Results / Ending ======
  function endSong(){
    running=false; wrap.style.setProperty('--gray','0'); applyWorldVisuals();
    const acc = judgedCount?(hits/judgedCount):1; const worldPct=Math.round(worldProgress()*100);
    if(LEVEL>=MAX_LEVEL){
      showResultCard(true, acc, worldPct);
      // ★Lv5：結果表示を少し長め（従来300ms → 1600ms）
      setTimeout(()=> playEnding(score, acc, worldPct), 1600);
    }else{
      showResultCard(false, acc, worldPct);
    }
  }

  function showResultCard(isFinal, acc, worldPct){
    const title = isFinal ? `Final Results — Lv.${LEVEL} (MAX${isWaMode?' / WA':''})` : `Results — Lv.${LEVEL}${isWaMode?' / WA':''}`;
    const nextBtnLabel = isFinal ? 'Watch Ending' : 'Next Level';
    card.innerHTML = `
      <div class="logo"><span class="dot"></span><span class="word">MONOCHROME REBIRTH</span><span class="dot"></span></div>
      <h1>${title}</h1>
      <p>SCORE: <b>${score|0}</b></p>
      <p>COMBO: <b>${combo|0}</b> &nbsp; ACC: <b>${(acc*100).toFixed(1)}%</b></p>
      <p>WORLD: <b>${worldPct}%</b></p>
      <div class="bar" style="margin:12px 0 14px"><span style="width:${worldPct}%"></span></div>
      <div style="display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap">
        <button class="btn" id="retryBtn">Retry</button>
        <button class="btn primary" id="nextBtn">${nextBtnLabel}</button>
        <button class="btn" id="closeBtn">Close</button>
      </div>
    `;
    ov.style.display='flex';
    document.getElementById('retryBtn').onclick = ()=>{ ov.style.display='none'; startGame(); };
    document.getElementById('nextBtn').onclick  = ()=>{
      ov.style.display='none';
      if(LEVEL>=MAX_LEVEL){ playEnding(score, acc, worldPct); }
      else { LEVEL++; startGame(); }
    };
    document.getElementById('closeBtn').onclick = ()=> ov.style.display='none';
  }

  // ====== Ending（同時：背景アニメ＋即時エンドロール） ======
  function playEnding(finalScore, acc, worldPct){
    endingMode=true; particles.length=0; windStreaks.length=0; petals.length=0; lanterns.length=0;
    ov.style.display='none';

    // クレジット本文
    const body =
`PRODUCER
Hisashi Fujinaka

DIRECTOR
Hisashi Fujinaka

ART DIRECTOR
Hisashi Fujinaka

SOUND DIRECTOR
Hisashi Fujinaka

GAME DESIGN
Hisashi Fujinaka

ENGINEERING LEAD
Hisashi Fujinaka

CODING DIRECTOR
ChatGPT

SPECIAL THANKS
All Players

SCORE ${finalScore|0}  /  ACC ${(acc*100).toFixed(1)}%  /  WORLD ${worldPct}%

MONOCHROME REBIRTH
© Hisashi Fujinaka`;
    creditsText.textContent = body;
    creditsWrap.style.display='flex';

    // 背景アニメ & BGM
    const accPct = acc*100;
    const tier = (finalScore>30000 && accPct>95 && worldPct>90) ? 'AURORA'
               : (finalScore>22000 && accPct>90) ? 'WAVE'
               : 'BLOOM';
    startEndingBgm(isWaMode?('WA_'+tier):tier);

    const duration = 30000;
    const startMs = performance.now();
    const colsAll = isWaMode ? ['#ffcd6b','#ff8fab','#c6ffb2','#9dd6ff'] : ['#ffd166','#5af38f','#6ab8ff','#ff6b6b'];

    function renderEnding(nowMs){
      const W=canvas.width,H=canvas.height;
      ctx.clearRect(0,0,W,H);
      const t = (nowMs - startMs)/1000;

      if(isWaMode){
        const g0=ctx.createLinearGradient(0,0,0,H);
        g0.addColorStop(0, hsl(35, 0.85, 0.35, 0.9));
        g0.addColorStop(1, hsl(210, 0.6, 0.35, 0.9));
        ctx.fillStyle=g0; ctx.fillRect(0,0,W,H);
        for(let li=0; li<5; li++){
          const yy = H*(0.65 + 0.03*li);
          ctx.globalAlpha = 0.08 + 0.04*Math.sin(t*0.8+li);
          ctx.fillStyle = addAlpha(colsAll[li%colsAll.length], 0.7);
          ctx.beginPath(); ctx.moveTo(0,H);
          for(let x=0;x<=W;x+=10*DPR){
            const y = yy + Math.sin((x/(70*DPR))+t*(0.9+li*0.12))*(10*DPR)*(0.6+li*0.2);
            ctx.lineTo(x,y);
          }
          ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
        }
        drawSakura(); drawLanterns();
      }else{
        const hueBase = 45 + Math.sin(t*0.15)*25;
        const top = hsl(hueBase, 0.8, 0.35, 0.6);
        const bot = hsl(hueBase+120, 0.85, 0.45, 0.85);
        const gbg = ctx.createLinearGradient(0,0,0,H); gbg.addColorStop(0, top); gbg.addColorStop(1, bot); ctx.fillStyle=gbg; ctx.fillRect(0,0,W,H);
        const bands = tier==='AURORA'? 6 : (tier==='WAVE'?4:3);
        for(let i=0;i<bands;i++){
          const c = colsAll[i%colsAll.length];
          const amp = (tier==='AURORA'? 80: 60) * DPR;
          const y0 = H*0.3 + Math.sin(t*0.4 + i)*amp*0.1;
          const y1 = H*0.5 + Math.sin(t*0.6 + i*0.7)*amp*0.15;
          const y2 = H*0.7 + Math.sin(t*0.8 + i*1.1)*amp*0.12;
          ctx.globalAlpha = 0.14 + 0.06*Math.sin(t*1.2+i);
          ctx.strokeStyle = addAlpha(c, 0.85);
          ctx.lineWidth = (12 + i*4) * DPR;
          ctx.beginPath();
          ctx.moveTo(0, y0);
          ctx.bezierCurveTo(W*0.33, y1, W*0.66, y2, W, H*0.5 + Math.sin(t*0.5+i)*amp*0.05);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }

      if(nowMs - startMs < duration){ requestAnimationFrame(renderEnding); }
      else{
        // 終了UI
        ov.style.display='flex';
        card.innerHTML = `
          <div class="logo"><span class="dot"></span><span class="word">MONOCHROME REBIRTH</span><span class="dot"></span></div>
          <h1>Thank You for Playing</h1>
          <p>${isWaMode?'彩は巡り、音は還る。':'The colors return, the rhythm remains.'}</p>
          <div style="display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;margin-top:10px">
            <button class="btn" id="again">Play Again (Lv1)</button>
            <button class="btn primary" id="stay">Stay</button>
          </div>
        `;
        document.getElementById('again').onclick = ()=>{ creditsWrap.style.display='none'; LEVEL=1; startGame(); };
        document.getElementById('stay').onclick = ()=>{ creditsWrap.style.display='none'; ov.style.display='none'; };
      }
    }
    requestAnimationFrame(renderEnding);
  }

  function startEndingBgm(tier){
    if(!audioCtx) return;
    const pad = audioCtx.createGain(); pad.gain.value=0; pad.connect(masterGain);
    const bell= audioCtx.createGain(); bell.gain.value=0; bell.connect(masterGain);
    const rev  = audioCtx.createDelay(); rev.delayTime.value=0.28;
    const fb   = audioCtx.createGain(); fb.gain.value=0.45;
    bell.connect(rev).connect(fb).connect(rev); rev.connect(masterGain);

    const now=audioCtx.currentTime;
    const isWa = String(tier).startsWith('WA_');

    const chord = isWa ? [[0,5,7],[2,7,9],[5,9,12],[7,12,14]] : [[0,4,7],[2,5,9],[4,7,11],[5,9,12]];
    chord.forEach((ch,idx)=>{
      const t = now + 0.6 + idx*2.6;
      const g=audioCtx.createGain(); g.gain.value=0; g.connect(pad);
      g.gain.linearRampToValueAtTime(isWa?0.5:0.45, t+0.8); g.gain.linearRampToValueAtTime(0.0, t+2.3);
      ch.forEach(se=>{ const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=220*Math.pow(2,se/12); o.connect(g); o.start(t); o.stop(t+2.5); });
    });
    pad.gain.linearRampToValueAtTime(0.6, now+1.0);

    const speedMod = /AURORA|WA_AURORA/.test(tier)? 0.08 : /WAVE|WA_WAVE/.test(tier)? 0.06 : 0.0;
    for(let i=0;i<30;i++){
      const t = now + 1.0 + i*(0.45 - speedMod) + Math.random()*0.12;
      const f = 660 * Math.pow(2, (Math.random()<0.5?0:7)/12);
      const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type = 'triangle';
      o.frequency.value=f;
      g.gain.setValueAtTime(0.0008,t); g.gain.exponentialRampToValueAtTime(0.09, t+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t+0.20);
      o.connect(g).connect(bell); o.start(t); o.stop(t+0.25);
    }
    bell.gain.linearRampToValueAtTime(0.55, now+1.2);
  }

  // ====== Minimal Start overlay（iOS解放順：ensure → init → start） ======
  function showStartOverlay(){
    card.innerHTML = `
      <div class="logo"><span class="dot"></span><span class="word">MONOCHROME REBIRTH</span><span class="dot"></span></div>
      <div class="sub">Tap the rhythm — bring back the colors</div>
      <div style="display:flex;gap:10px;justify-content:center;margin-top:16px;flex-wrap:wrap">
        <button class="btn primary wide" id="ovStart">Start</button>
        <button class="btn" id="ovLvUp" title="難易度を1上げる">Lv+1</button>
      </div>
    `;
    ov.style.display='flex';
    document.getElementById('ovStart').onclick = async ()=>{
      const ok = await ensureAudioUnlocked();
      if(!ok){ unlock.style.display='flex'; return; }
      initAudio(); ov.style.display='none'; startGame();
    };
    document.getElementById('ovLvUp').onclick = ()=>{ if(LEVEL<MAX_LEVEL){ LEVEL++; lvEl.textContent=LEVEL; } };
  }

  // “どこでも解放”保険（iOS）
  ['touchstart','mousedown','keydown'].forEach(ev=>{
    document.addEventListener(ev, async ()=>{
      if(!audioCtx || audioCtx.state!=='running'){
        const ok = await ensureAudioUnlocked();
        if(ok){ unlock.style.display='none'; }
      }
    }, {passive:true, once:false});
  });

  // ====== Boot ======
  showStartOverlay();

})();
</script>
</body>
</html>
