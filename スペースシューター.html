<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>スペースシューター</title>
  <!-- Pixel-like retro font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    *{margin:0;padding:0;box-sizing:border-box;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
    body{overflow:hidden;background:#000;font-family:Arial,Helvetica,sans-serif;touch-action:none}
    #gameCanvas{display:block;background:linear-gradient(to bottom,#000428,#004e92);margin:0 auto;touch-action:none}
    #ui{position:absolute;top:20px;left:20px;color:#fff;font-size:20px;text-shadow:2px 2px 4px rgba(0,0,0,.8);z-index:10;pointer-events:none}
    #ui .row{display:flex;gap:18px;align-items:center}
    #stageBadge{padding:4px 10px;border-radius:10px;background:rgba(0,0,0,.45);font-family:'Press Start 2P', monospace;font-size:12px;letter-spacing:1px}
    #powerupStatus{position:absolute;top:20px;right:140px;color:#fff;font-size:18px;text-shadow:2px 2px 4px rgba(0,0,0,.8);z-index:10;pointer-events:none;background:rgba(0,0,0,.5);padding:10px 16px;border-radius:10px;display:none}
    #gameOver{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.9);padding:40px 60px;border-radius:20px;text-align:center;color:#fff;display:none;z-index:20}
    #gameOver h1{font-size:48px;margin-bottom:20px;color:#ff4444}
    #gameOver p{font-size:28px;margin-bottom:30px}
    #restartBtn{font-size:22px;padding:14px 30px;background:#4CAF50;border:none;border-radius:10px;color:#fff;cursor:pointer;font-weight:bold}
    #restartBtn:active{background:#45a049}

    /* ===== Title / Stage Panel ===== */
    #titleScreen{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(1200px 800px at 50% -20%, rgba(0,30,80,.6), rgba(0,0,0,.95)), #000;z-index:30}
    .title{font-family:'Press Start 2P', monospace; font-size:34px; line-height:1.3; color:#7ee3ff; text-align:center; letter-spacing:2px; text-shadow:0 0 6px rgba(0,255,255,.8), 0 0 18px rgba(0,180,255,.6), 3px 3px 0 #00243a}
    .subtitle{margin-top:12px; color:#b8e8ff; font-size:14px; font-family:'Press Start 2P', monospace; opacity:.8}
    .startBtn{margin-top:36px; font-family:'Press Start 2P', monospace; font-size:18px; color:#001e2a; background:#7ee3ff; border:none; padding:16px 28px; border-radius:12px; cursor:pointer; box-shadow:0 0 10px rgba(126,227,255,.7), inset 0 -4px 0 rgba(0,0,0,.15)}
    .startBtn:active{transform:translateY(1px)}
    .tips{position:absolute;bottom:28px;color:#8ddcff;font-size:12px;font-family:'Press Start 2P', monospace;opacity:.7;text-align:center}
    .starfield{position:absolute;inset:0;pointer-events:none;overflow:hidden}
    .dot{position:absolute;width:3px;height:3px;border-radius:50%;background:#bdf4ff;opacity:.8;animation:twinkle 2.2s infinite ease-in-out}
    @keyframes twinkle{0%,100%{opacity:.2;transform:scale(.8)}50%{opacity:1;transform:scale(1)}}

    #stagePanel{
      position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:25;
      background: radial-gradient(900px 600px at 50% 40%, rgba(0,0,0,.0), rgba(0,0,0,.8));
      color:#9ee7ff; font-family:'Press Start 2P', monospace; letter-spacing:2px; text-shadow:0 0 8px rgba(126,227,255,.6);
    }
    #stagePanel .box{
      padding:22px 34px; border-radius:14px; background:rgba(0,25,45,.6); border:1px solid rgba(126,227,255,.4); font-size:22px;
    }

    /* BGMミュートボタン */
    #muteBtn{
      position:absolute; top:20px; right:20px; z-index:15;
      font: 12px 'Press Start 2P', monospace; padding:10px 12px;
      border-radius:10px; border:none; cursor:pointer;
      background:#222; color:#9ee7ff; box-shadow:0 0 8px rgba(0,200,255,.3);
    }
  </style>
</head>
<body>
  <!-- Title Screen -->
  <div id="titleScreen">
    <div class="starfield" id="starfield"></div>
    <h1 class="title">SPACE SHOOTER<br>スペースシューター</h1>
    <div class="subtitle">タップで移動 / 自動ショット</div>
    <button class="startBtn" id="startBtn">START</button>
    <div class="tips">ⓘ STAGE 1：基本操作とボス｜STAGE 2：難易度UP＆無敵アイテム＆タコ型ボス</div>
  </div>

  <!-- Stage transition panel -->
  <div id="stagePanel"><div class="box">STAGE 2</div></div>

  <!-- In-Game UI -->
  <div id="ui">
    <div class="row">
      <div>スコア: <span id="score">0</span></div>
      <div>ライフ: <span id="lives">3</span></div>
      <div>時間: <span id="timer">3:00</span></div>
      <div id="stageBadge">STAGE <span id="stageNo">1</span> / 2</div>
    </div>
  </div>
  <div id="powerupStatus"></div>
  <button id="muteBtn">BGM: ON</button>

  <div id="gameOver">
    <h1>ゲームオーバー</h1>
    <p>最終スコア: <span id="finalScore">0</span></p>
    <button id="restartBtn">もう一度プレイ</button>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){ canvas.width = innerWidth; canvas.height = innerHeight; }
    resizeCanvas(); addEventListener('resize', resizeCanvas);

    // ===== Title starfield =====
    (function buildDots(){
      const sf = document.getElementById('starfield');
      const n = 120;
      for(let i=0;i<n;i++){
        const d = document.createElement('div');
        d.className='dot';
        d.style.left = Math.random()*100+'%';
        d.style.top = Math.random()*100+'%';
        d.style.animationDelay = (Math.random()*2)+'s';
        d.style.opacity = (Math.random()*0.8+0.2).toFixed(2);
        d.style.transform = `scale(${(Math.random()*0.8+0.4).toFixed(2)})`;
        sf.appendChild(d);
      }
    })();

    // === SFX (Web Audio) ===
    let audioCtx = null;
    const sfx = {
      resume(){ try{ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); }catch(e){} },
      now(){ return audioCtx ? audioCtx.currentTime : 0; },
      beep({freq=440,dur=0.1,type='square',vol=0.2,slideTo=null,attack=0.005,decay=0.1}){
        if(!audioCtx) return; const t0=this.now();
        const osc=audioCtx.createOscillator(); const gain=audioCtx.createGain();
        osc.type=type; osc.frequency.setValueAtTime(freq,t0);
        if(slideTo){ try{ osc.frequency.exponentialRampToValueAtTime(Math.max(1,slideTo), t0+dur); }catch(_){} }
        gain.gain.setValueAtTime(0.0001,t0);
        gain.gain.exponentialRampToValueAtTime(vol, t0+attack);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0+Math.max(dur, attack+decay));
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(t0); osc.stop(t0+Math.max(dur, attack+decay)+0.02);
      },
      noise({dur=0.3,vol=0.2,decay=0.3}){
        if(!audioCtx) return; const t0=this.now();
        const size=Math.floor((audioCtx.sampleRate||44100)*dur);
        const buf=audioCtx.createBuffer(1,size,audioCtx.sampleRate); const data=buf.getChannelData(0);
        for(let i=0;i<size;i++){ data[i]=Math.random()*2-1; }
        const src=audioCtx.createBufferSource(); src.buffer=buf;
        const gain=audioCtx.createGain(); gain.gain.setValueAtTime(vol,t0);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0+decay);
        src.connect(gain).connect(audioCtx.destination);
        src.start(t0); src.stop(t0+dur+decay);
      },
      shoot(){ this.beep({freq:900, slideTo:400, dur:0.07, type:'square', vol:0.12}); },
      explosion(kind='small'){
        if(kind==='big' || kind==='bomb'){
          this.noise({dur:0.6, vol:0.3, decay:0.5});
          this.beep({freq:80, dur:0.3, type:'sine', vol:0.25});
        } else {
          this.noise({dur:0.3, vol:0.2, decay:0.25});
          this.beep({freq:120, dur:0.12, type:'sine', vol:0.15});
        }
      },
      powerup(){ const t=this; t.beep({freq:600,dur:0.06,type:'triangle',vol:0.12}); setTimeout(()=>t.beep({freq:900,dur:0.06,type:'triangle',vol:0.12}),70); setTimeout(()=>t.beep({freq:1200,dur:0.08,type:'triangle',vol:0.12}),140); },
      powerupShield(){ const t=this; t.beep({freq:700,dur:0.07,type:'triangle',vol:0.13}); setTimeout(()=>t.beep({freq:1000,dur:0.07,type:'triangle',vol:0.13}),70); setTimeout(()=>t.beep({freq:1400,dur:0.10,type:'triangle',vol:0.13}),140); },
      hit(){ this.beep({freq:120, dur:0.08, type:'square', vol:0.18}); },
      bossMorph(){ this.beep({freq:300, slideTo:900, dur:0.6, type:'sawtooth', vol:0.15}); },
      flash(){ this.beep({freq:1500, dur:0.12, type:'triangle', vol:0.12}); },
      click(){ this.beep({freq:500, dur:0.05, type:'square', vol:0.1}); },
      clear(){ this.powerup(); },
      gameover(){ this.beep({freq:400, dur:0.15, type:'square', vol:0.15}); setTimeout(()=>this.beep({freq:260, dur:0.2, type:'square', vol:0.15}),140); }
    };
    ['touchstart','mousedown','keydown'].forEach(evt=>{
      window.addEventListener(evt, ()=>sfx.resume(), {once:true, passive:true});
    });

    /* === BGM (stage-aware: normal/boss/boss2 per stage) === */
    const bgm = {
      playing:false, gain:null, vol:0.06,
      _timer:null, _step:0, _ahead:0.12, _interval:25, _nextEventTime:0,
      _mode:'normal',     // 'normal' | 'boss' | 'boss2'
      _stage:1,           // 1 | 2
      _tempo:120,
      _patterns:{
        1:{
          normal: [
            [48,55],null,[52,55],null,[55,60],null,[52,55],null,
            [44,51],null,[48,51],null,[51,56],null,[48,51],null,
            [41,48],null,[45,48],null,[48,53],null,[45,48],null,
            [43,50],null,[47,50],null,[50,55],null,[47,50],null,
          ],
          boss: [
            [48,60],[55,67],[51,63],[55,67],[48,60],[55,67],[51,63],[55,67],
            [46,58],[53,65],[49,61],[53,65],[46,58],[53,65],[49,61],[53,65],
          ],
          boss2: [
            [48,55],[null,null],[50,57],[null,null],[51,58],[null,null],[53,60],[null,null],
            [55,62],[null,null],[56,63],[null,null],[58,65],[null,null],[60,67],[null,null],
          ],
          tempos:{normal:120, boss:138, boss2:180}
        },
        2:{
          normal: [
            [50,57],null,[53,57],null,[55,62],null,[53,57],null,
            [47,54],null,[50,54],null,[52,59],null,[50,54],null,
            [52,59],null,[55,62],null,[57,64],null,[60,67],null,
            [55,62],null,[53,60],null,[50,57],null,[48,55],null,
          ],
          boss: [
            [52,64],[59,71],[55,67],[59,71],[52,64],[59,71],[55,67],[59,71],
            [50,62],[57,69],[53,65],[57,69],[50,62],[57,69],[53,65],[57,69],
          ],
          boss2: [
            [52,59],[null,null],[55,62],[null,null],[57,64],[null,null],[59,66],[null,null],
            [60,67],[null,null],[62,69],[null,null],[64,71],[null,null],[67,74],[null,null],
          ],
          tempos:{normal:132, boss:150, boss2:190}
        }
      },
      _midiToFreq(n){ return 440 * Math.pow(2,(n-69)/12); },
      _makeDistortionCurve(amount=260){
        const n=44100, curve=new Float32Array(n), deg=Math.PI/180;
        for(let i=0;i<n;i++){ const x=i*2/n-1; curve[i]=(3+amount)*x*20*deg/(Math.PI+amount*Math.abs(x)); }
        return curve;
      },
      _ensureNodes(){
        if(!audioCtx) return;
        if(!this.gain){
          this.gain = audioCtx.createGain();
          this.gain.gain.value = 0.8;
          this.gain.connect(audioCtx.destination);
        }
      },
      _lead(freq,t,dur=0.16){
        if(!audioCtx) return;
        const osc=audioCtx.createOscillator(), amp=audioCtx.createGain();
        const type = this._mode==='normal' ? 'square' : (this._mode==='boss' ? 'sawtooth' : 'square');
        osc.type=type; osc.frequency.setValueAtTime(freq,t);
        const peak = (this._mode==='boss2') ? this.vol*1.1 : this.vol;
        amp.gain.setValueAtTime(0.0001,t);
        amp.gain.exponentialRampToValueAtTime(peak,t+0.01);
        amp.gain.exponentialRampToValueAtTime(0.0001,t+dur);
        osc.connect(amp);
        let last=amp;
        if(this._mode==='boss2'){
          const sh=audioCtx.createWaveShaper();
          sh.curve=this._makeDistortionCurve(260); sh.oversample='2x';
          last.connect(sh); last=sh;
        }
        last.connect(this.gain);
        osc.start(t); osc.stop(t+dur+0.02);
      },
      _bass(freq,t,dur=0.10){
        if(!audioCtx) return;
        const osc=audioCtx.createOscillator(), amp=audioCtx.createGain();
        osc.type='square'; osc.frequency.setValueAtTime(freq,t);
        amp.gain.setValueAtTime(0.0001,t);
        amp.gain.exponentialRampToValueAtTime(this.vol*0.9,t+0.008);
        amp.gain.exponentialRampToValueAtTime(0.0001,t+dur);
        osc.connect(amp).connect(this.gain);
        osc.start(t); osc.stop(t+dur+0.01);
      },
      _kick(t){
        const osc=audioCtx.createOscillator(), amp=audioCtx.createGain();
        osc.type='sine';
        osc.frequency.setValueAtTime(190,t);
        osc.frequency.exponentialRampToValueAtTime(50,t+0.08);
        amp.gain.setValueAtTime(0.0001,t);
        amp.gain.exponentialRampToValueAtTime(0.30,t+0.004);
        amp.gain.exponentialRampToValueAtTime(0.0001,t+0.12);
        osc.connect(amp).connect(this.gain);
        osc.start(t); osc.stop(t+0.14);
      },
      _snare(t){
        const dur=0.12, sr=audioCtx.sampleRate||44100, size=Math.floor(sr*dur);
        const buf=audioCtx.createBuffer(1,size,sr), data=buf.getChannelData(0);
        for(let i=0;i<size;i++) data[i]=Math.random()*2-1;
        const src=audioCtx.createBufferSource(); src.buffer=buf;
        const bpf=audioCtx.createBiquadFilter(); bpf.type='bandpass'; bpf.frequency.setValueAtTime(1800,t); bpf.Q.value=0.8;
        const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(700,t);
        const amp=audioCtx.createGain(); amp.gain.setValueAtTime(0.22,t); amp.gain.exponentialRampToValueAtTime(0.0001,t+dur);
        src.connect(bpf).connect(hp).connect(amp).connect(this.gain);
        src.start(t); src.stop(t+dur+0.02);
      },
      _hat(t){
        const dur=0.04, sr=audioCtx.sampleRate||44100, size=Math.floor(sr*dur);
        const buf=audioCtx.createBuffer(1,size,sr), data=buf.getChannelData(0);
        for(let i=0;i<size;i++) data[i]=Math.random()*2-1;
        const src=audioCtx.createBufferSource(); src.buffer=buf;
        const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(5000,t);
        const amp=audioCtx.createGain(); amp.gain.setValueAtTime(0.12,t); amp.gain.exponentialRampToValueAtTime(0.0001,t+dur);
        src.connect(hp).connect(amp).connect(this.gain);
        src.start(t); src.stop(t+dur+0.01);
      },
      _schedulePattern(startAt){
        const pat = this._patterns[this._stage][this._mode];
        const tempos = this._patterns[this._stage].tempos;
        this._tempo = tempos[this._mode];
        const spb=60/this._tempo;
        const step=(this._mode==='boss2') ? spb/4 : spb/2;

        const scheduler=()=>{
          if(!this.playing) return;
          const now=audioCtx.currentTime;
          while(this._nextEventTime < now + this._ahead){
            const idx=this._step % pat.length;
            const note=pat[idx];

            if(note){
              this._lead(this._midiToFreq(note[0]), this._nextEventTime, this._mode==='boss2'?0.12:0.15);
              this._lead(this._midiToFreq(note[1]), this._nextEventTime+0.02, this._mode==='boss2'?0.10:0.13);
            }

            if(this._mode==='boss'){
              const beat=this._step % 8;
              if(beat===0) this._kick(this._nextEventTime);
              if(beat===2 || beat===4 || beat===6) this._hat(this._nextEventTime);
            }else if(this._mode==='boss2'){
              const s=this._step % 16;
              this._kick(this._nextEventTime);
              if(s===4 || s===12) this._snare(this._nextEventTime);
              if(s%2===1) this._hat(this._nextEventTime);
              const root = note ? note[0] : 48;
              const bassMidi = root-12;
              this._bass(this._midiToFreq(bassMidi), this._nextEventTime, 0.09);
            }

            this._step++;
            this._nextEventTime += step;
          }
          this._timer=setTimeout(scheduler, this._interval);
        };

        this._nextEventTime=startAt;
        this._timer=setTimeout(scheduler, this._interval);
      },
      start(){
        if(!audioCtx) return; this._ensureNodes();
        if(this.playing) return;
        this.playing=true; this._step=0;
        const startAt=(audioCtx.currentTime||0)+0.05;
        this._schedulePattern(startAt);
      },
      stop(){ this.playing=false; if(this._timer){ clearTimeout(this._timer); this._timer=null; } },
      setMuted(mute){ this._ensureNodes(); if(!this.gain) return; this.gain.gain.setValueAtTime(mute?0:0.8, audioCtx.currentTime); },
      switchMode(mode){
        if(!['normal','boss','boss2'].includes(mode)) return;
        this._mode=mode;
        if(!this.playing || !audioCtx) return;
        this._step=0; this._nextEventTime=audioCtx.currentTime+0.06;
      },
      switchStage(stage){ this._stage = stage; if(this.playing && audioCtx){ this._step=0; this._nextEventTime=audioCtx.currentTime+0.06; } }
    };

    // ===== Game State (2ステージ管理) =====
    let currentStage = 1;          // 1 -> 2
    let gameState = { running:false, score:0, lives:3, startTime:Date.now(), gameTimeLimit:180000 };
    const STAGE_CONFIG = {
      1:{ enemySpawnDelay:1000, bombSpawnDelay:6000, powerupSpawnDelay:8000, speedStep:0.10, speedCap:2.0, bgGradient:['#000428','#004e92'] },
      2:{ enemySpawnDelay:750,  bombSpawnDelay:4200, powerupSpawnDelay:7000, speedStep:0.15, speedCap:2.3, bgGradient:['#0d0318','#3b005e'] }
    };

    // ★ ステージ内スコア（ステージ2はこれが500到達でボス出現）
    let stageScore = 0;
    const STAGE2_BOSS_SCORE = 500;

    const player = { x: innerWidth/2, y: innerHeight-100, width:40, height:50, speed:8, bullets:[], lastShot:0, shootDelay:200 };

    let enemies=[]; let lastEnemySpawn=0; let enemySpawnDelay=STAGE_CONFIG[1].enemySpawnDelay;
    let particles=[];
    let powerups=[]; let lastPowerupSpawn=0; let powerupSpawnDelay=STAGE_CONFIG[1].powerupSpawnDelay;
    let bombs=[]; let lastBombSpawn=0; let bombSpawnDelay=STAGE_CONFIG[1].bombSpawnDelay;

    let activePowerup={ type:null, endTime:0 };
    let invincibleUntil=0;               // 無敵（シールド）用
    let gameSpeed=1.0; let gameStartTime=Date.now();
    let boss=null, bossActive=false, bossDefeated=false, nextBossScore=500;
    let bossIsSecondForm=false, bossDying=false, bossDeathFlashUntil=0, playerInvulnUntil=0;

    // gameplay starfield
    let stars=[]; for(let i=0;i<110;i++){ stars.push({x:Math.random()*innerWidth, y:Math.random()*innerHeight, speed:Math.random()*2+1, size:Math.random()*2}); }

    // Theme（見た目切替）
    const theme = {
      apply(stage){
        currentStage = stage;
        // 背景グラデ
        const [c1,c2] = STAGE_CONFIG[stage].bgGradient;
        document.getElementById('gameCanvas').style.background = `linear-gradient(to bottom, ${c1}, ${c2})`;
        // BGMステージ切替
        bgm.switchStage(stage);
        // UI表示
        document.getElementById('stageNo').textContent = String(stage);
        // スポーンディレイ反映
        enemySpawnDelay   = STAGE_CONFIG[stage].enemySpawnDelay;
        bombSpawnDelay    = STAGE_CONFIG[stage].bombSpawnDelay;
        powerupSpawnDelay = STAGE_CONFIG[stage].powerupSpawnDelay;
      }
    };

    // Touch input
    let touchX=null, touchY=null;
    canvas.addEventListener('touchstart',e=>{e.preventDefault();sfx.resume();const t=e.touches[0];touchX=t.clientX;touchY=t.clientY});
    canvas.addEventListener('touchmove',e=>{e.preventDefault();const t=e.touches[0];touchX=t.clientX;touchY=t.clientY});
    canvas.addEventListener('touchend',e=>{e.preventDefault();touchX=null;touchY=null});

    // UI buttons
    document.getElementById('startBtn').addEventListener('click', ()=>{
      sfx.resume(); sfx.click();
      document.getElementById('titleScreen').style.display='none';
      resetAndPause(false, /*stage*/1); startGame();
    });
    document.getElementById('restartBtn').addEventListener('click', ()=>{
      sfx.click();
      resetAndPause(false, /*stage*/1); startGame();
    });

    // BGMミュートボタン
    const muteBtn = document.getElementById('muteBtn');
    let bgmMuted = false;
    muteBtn.addEventListener('click', ()=>{
      bgmMuted = !bgmMuted;
      bgm.setMuted(bgmMuted);
      muteBtn.textContent = 'BGM: ' + (bgmMuted ? 'OFF' : 'ON');
      sfx.click();
    });

    // --- Draw player (無敵リング対応) ---
    function drawPlayer(){
      const now = Date.now();
      const isInv = now < invincibleUntil;

      ctx.save(); ctx.translate(player.x, player.y);

      // 無敵リング
      if(isInv){
        const t = (now % 600) / 600;
        const r = player.width*0.85 + Math.sin(t*2*Math.PI)*3;
        ctx.shadowBlur=20; ctx.shadowColor='#9cf6ff';
        ctx.strokeStyle='#9cf6ff'; ctx.lineWidth=3; ctx.globalAlpha=0.9;
        ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
        ctx.globalAlpha=1;
      }

      // 本体
      ctx.fillStyle='#4CAF50';
      ctx.beginPath(); ctx.moveTo(0,-player.height/2); ctx.lineTo(-player.width/2, player.height/2); ctx.lineTo(player.width/2, player.height/2); ctx.closePath(); ctx.fill();
      ctx.fillStyle='#81C784'; ctx.beginPath(); ctx.arc(0,0,player.width/4,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#FF5722'; ctx.fillRect(-player.width/4, player.height/2-5, player.width/2, 10);

      ctx.restore();
    }

    // --- Shooting ---
    function shoot(){
      const now=Date.now(); if(now-player.lastShot<=player.shootDelay) return;
      const powered = activePowerup.type && now<activePowerup.endTime;
      if(powered && activePowerup.type==='double'){
        player.bullets.push(
          {x:player.x-15,y:player.y-player.height/2,width:4,height:15,speed:12,vx:0},
          {x:player.x+15,y:player.y-player.height/2,width:4,height:15,speed:12,vx:0}
        );
      }else if(powered && activePowerup.type==='triple'){
        player.bullets.push(
          {x:player.x,y:player.y-player.height/2,width:4,height:15,speed:12,vx:0},
          {x:player.x,y:player.y-player.height/2,width:4,height:15,speed:12,vx:-3},
          {x:player.x,y:player.y-player.height/2,width:4,height:15,speed:12,vx:3}
        );
      }else{
        player.bullets.push({x:player.x,y:player.y-player.height/2,width:4,height:15,speed:12,vx:0});
      }
      sfx.shoot();
      player.lastShot=now;
    }

    function updateBullets(){
      const now=Date.now(); const powered = activePowerup.type && now<activePowerup.endTime;
      ctx.fillStyle = powered ? (activePowerup.type==='double' ? '#FFD700' : '#FF00FF') : '#FFF';
      for(let i=player.bullets.length-1;i>=0;i--){
        const b=player.bullets[i];
        b.y-=b.speed; b.x+=b.vx||0;
        if(b.y<0||b.x<0||b.x>canvas.width){ player.bullets.splice(i,1); continue; }
        ctx.fillRect(b.x-b.width/2,b.y,b.width,b.height);
      }
    }

    // --- Enemies (Stage2強化タイプ実装) ---
    function spawnEnemy(){ 
      if(bossActive) return; 
      const now=Date.now();
      if(now-lastEnemySpawn>enemySpawnDelay/gameSpeed){
        if(currentStage===2){
          const types = ['zigzag','sprinter','armored','ufo'];
          const t = types[Math.floor(Math.random()*types.length)];
          const baseX = Math.random()*(canvas.width-80)+40;
          if(t==='zigzag'){
            enemies.push({
              type:'zigzag',
              x:baseX, y:-50, width:36, height:36,
              speed:(3.2+Math.random()*0.8)*gameSpeed,
              vx:(Math.random()<.5?-1:1)*(1.6+Math.random()*0.6),
              amp: 50 + Math.random()*30, freq: 0.035 + Math.random()*0.02,
              t: 0, health:1, score:12
            });
          }else if(t==='sprinter'){
            enemies.push({
              type:'sprinter',
              x:baseX, y:-60, width:32, height:32,
              speed:(4.2+Math.random()*1.2)*gameSpeed,
              health:1, score:12
            });
          }else if(t==='armored'){
            enemies.push({
              type:'armored',
              x:baseX, y:-60, width:44, height:44,
              speed:(2.4+Math.random()*0.6)*gameSpeed,
              health:2, score:18
            });
          }else{ // ufo
            enemies.push({
              type:'ufo',
              x:baseX, y:-60, width:46, height:34,
              speed:(2.6+Math.random()*0.8)*gameSpeed,
              wob: 0, health:1, score:12
            });
          }
          // 時々2体同時（密度UP）
          if(Math.random()<0.22){
            enemies.push({
              type:'sprinter',
              x:Math.random()*(canvas.width-80)+40, y:-100, width:32, height:32,
              speed:(4.2+Math.random()*1.0)*gameSpeed,
              health:1, score:12
            });
          }
        }else{
          // ステージ1：従来のベーシック
          enemies.push({
            type:'basic',
            x:Math.random()*(canvas.width-60)+30, y:-50,
            width:40, height:40, speed:(Math.random()*2+2)*gameSpeed,
            health:1, score:10
          });
        }
        lastEnemySpawn=now;
      }
    }

    function updateEnemies(){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];

        // === 挙動 ===
        if(e.type==='zigzag'){
          e.t += e.freq;
          e.x += Math.sin(e.t)*e.vx;
          e.y += e.speed;
        }else if(e.type==='sprinter'){
          e.y += e.speed*1.15;
        }else if(e.type==='armored'){
          e.y += e.speed;
          e.x += Math.sin((Date.now()+i*123)%10000/400)*0.8;
        }else if(e.type==='ufo'){
          e.wob = (e.wob||0) + 0.08;
          e.y += e.speed*0.95;
          e.x += Math.sin(e.wob)*1.6;
        }else{ // basic
          e.y += e.speed;
        }

        // 画面外
        if(e.y > canvas.height+60 || e.x < -60 || e.x > canvas.width+60){
          enemies.splice(i,1);
          continue;
        }

        // === デザイン描画 ===
        ctx.save(); ctx.translate(e.x,e.y);

        if(currentStage===2){
          if(e.type==='zigzag'){
            // 菱形（ダイヤ）
            ctx.fillStyle='#00E5FF';
            ctx.beginPath();
            ctx.moveTo(0, -e.height/2);
            ctx.lineTo(e.width/2, 0);
            ctx.lineTo(0, e.height/2);
            ctx.lineTo(-e.width/2, 0);
            ctx.closePath(); ctx.fill();
            ctx.fillStyle='#B3F3FF';
            ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
          }else if(e.type==='sprinter'){
            // 細い三角（弾丸）
            ctx.fillStyle='#FFB300';
            ctx.beginPath();
            ctx.moveTo(0, -e.height/2);
            ctx.lineTo(e.width/2, e.height/2);
            ctx.lineTo(-e.width/2, e.height/2);
            ctx.closePath(); ctx.fill();
          }else if(e.type==='armored'){
            // 六角形（装甲）
            ctx.fillStyle='#FF5252';
            ctx.beginPath();
            for(let k=0;k<6;k++){
              const ang = Math.PI/3*k - Math.PI/6;
              const rx = Math.cos(ang)*e.width/2;
              const ry = Math.sin(ang)*e.width/2;
              k===0?ctx.moveTo(rx,ry):ctx.lineTo(rx,ry);
            }
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle='#FFC1C1'; ctx.lineWidth=2; ctx.stroke();
          }else{ // ufo
            ctx.fillStyle='#CE93D8';
            ctx.beginPath(); ctx.ellipse(0,0,e.width/2,e.height/2,0,0,Math.PI*2); ctx.fill();
            ctx.fillStyle='#F3E5F5';
            ctx.beginPath(); ctx.arc(0,-6,6,0,Math.PI*2); ctx.fill();
          }
        }else{
          // Stage1：従来
          ctx.fillStyle='#F44336';
          ctx.beginPath();
          ctx.moveTo(0,e.height/2);
          ctx.lineTo(-e.width/2,-e.height/2);
          ctx.lineTo(e.width/2,-e.height/2);
          ctx.closePath(); ctx.fill();
          ctx.fillStyle='#FF5252';
          ctx.beginPath(); ctx.arc(0,0,e.width/4,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();
      }
    }

    // --- Bombs ---
    function spawnBomb(){ if(bossActive) return; const now=Date.now();
      if(now-lastBombSpawn>bombSpawnDelay/gameSpeed){
        bombs.push({x:Math.random()*(canvas.width-60)+30,y:-50,width:35,height:35,speed:(Math.random()*1.5+2.5)*gameSpeed,pulse:0,isBossBomb:false});
        // ステージ2：たまに2連投下
        if(currentStage===2 && Math.random()<0.35){
          bombs.push({x:Math.random()*(canvas.width-60)+30,y:-120,width:35,height:35,speed:(Math.random()*1.5+2.6)*gameSpeed,pulse:0,isBossBomb:false});
        }
        lastBombSpawn=now;
      }
    }
    function updateBombs(){
      for(let i=bombs.length-1;i>=0;i--){
        const b=bombs[i]; b.y+=b.speed; b.pulse+=.1;
        if(b.isBossBomb){ b.waveOffset+=b.waveFrequency; b.x+=Math.sin(b.waveOffset)*b.waveAmplitude; }
        if(b.y>canvas.height||b.x<-50||b.x>canvas.width+50){ bombs.splice(i,1); continue; }
        ctx.save(); ctx.translate(b.x,b.y);
        const pulseSize=Math.sin(b.pulse)*5+b.width/2; ctx.shadowBlur=15; ctx.shadowColor='#FF0000';
        ctx.fillStyle='#1a1a1a'; ctx.beginPath(); ctx.arc(0,0,b.width/2,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#FF0000'; ctx.font='bold 24px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('💣',0,0);
        ctx.strokeStyle='#FF0000'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,pulseSize,0,Math.PI*2); ctx.stroke();
        if(b.isBossBomb){ ctx.strokeStyle='#FF8800'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(0,0,pulseSize+5,0,Math.PI*2); ctx.stroke(); }
        ctx.restore();
      }
    }

    // --- Powerups (shield in Stage 2) ---
    function spawnPowerup(){ const now=Date.now();
      if(now-lastPowerupSpawn>powerupSpawnDelay/gameSpeed){
        const types = (currentStage===2) ? ['double','triple','shield'] : ['double','triple'];
        const type = types[Math.floor(Math.random()*types.length)];
        powerups.push({x:Math.random()*(canvas.width-60)+30,y:-30,width:30,height:30,speed:2*gameSpeed,type,rotation:0});
        lastPowerupSpawn=now;
      }
    }
    function updatePowerups(){
      for(let i=powerups.length-1;i>=0;i--){
        const p=powerups[i]; p.y+=p.speed; p.rotation+=.05;
        if(p.y>canvas.height){ powerups.splice(i,1); continue; }
        ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rotation);
        ctx.shadowBlur=20; ctx.shadowColor= p.type==='double' ? '#FFD700' : (p.type==='triple' ? '#FF00FF' : '#9cf6ff');

        if(p.type==='double'){ // ダイヤ
          ctx.fillStyle='#FFD700'; ctx.beginPath(); ctx.moveTo(0,-p.height/2); ctx.lineTo(p.width/2,0); ctx.lineTo(0,p.height/2); ctx.lineTo(-p.width/2,0); ctx.closePath(); ctx.fill();
          ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.arc(0,0,p.width/4,0,Math.PI*2); ctx.fill();
        }else if(p.type==='triple'){ // 星
          ctx.fillStyle='#FF00FF'; ctx.beginPath();
          for(let j=0;j<5;j++){ const ang=j*4*Math.PI/5 - Math.PI/2; const x=Math.cos(ang)*p.width/2; const y=Math.sin(ang)*p.height/2; j===0?ctx.moveTo(x,y):ctx.lineTo(x,y); }
          ctx.closePath(); ctx.fill();
          ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.arc(0,0,p.width/5,0,Math.PI*2); ctx.fill();
        }else{ // shield：六角形
          ctx.fillStyle='#9cf6ff';
          ctx.beginPath();
          for(let k=0;k<6;k++){ const ang = k*Math.PI/3; const x=Math.cos(ang)*p.width/2; const y=Math.sin(ang)*p.height/2; k===0?ctx.moveTo(x,y):ctx.lineTo(x,y); }
          ctx.closePath(); ctx.fill();
          ctx.strokeStyle='#e8fdff'; ctx.lineWidth=2; ctx.stroke();
        }
        ctx.restore();
      }
    }

    // --- Stars / speed ---
    function updateStars(){ ctx.fillStyle='#FFF';
      for(const s of stars){ s.y+=s.speed*gameSpeed; if(s.y>canvas.height){ s.y=0; s.x=Math.random()*canvas.width; } ctx.fillRect(s.x,s.y,s.size,s.size); }
    }
    function updateGameSpeed(){
      const elapsed=(Date.now()-gameStartTime)/1000;
      const step = STAGE_CONFIG[currentStage].speedStep;
      const cap  = STAGE_CONFIG[currentStage].speedCap;
      gameSpeed = Math.min(cap, 1.0 + (Math.floor(elapsed/30)*step));
    }

    // --- Particles ---
    function createExplosion(x,y){ for(let i=0;i<15;i++){ particles.push({x,y,vx:(Math.random()-.5)*8,vy:(Math.random()-.5)*8,life:30,maxLife:30,color:`hsl(${Math.random()*60+10},100%,50%)`}); } }
    function updateParticles(){
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i]; p.x+=p.vx||0; p.y+=p.vy||0; p.life--; if(p.life<=0){particles.splice(i,1);continue;}
        ctx.globalAlpha=p.life/p.maxLife;
        if(p.ring){ ctx.strokeStyle=p.color||'#FFF'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(p.x,p.y,p.ringR,0,Math.PI*2); ctx.stroke(); }
        else{ ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); }
      }
      ctx.globalAlpha=1;
    }

    // --- Timer: bossActive中はタイムアップ無効 ---
    function updateTimer(){
      const elapsed=Date.now()-gameState.startTime;
      const remaining=Math.max(0, gameState.gameTimeLimit - elapsed);
      const m=Math.floor(remaining/60000), s=Math.floor((remaining%60000)/1000);
      document.getElementById('timer').textContent=`${m}:${s.toString().padStart(2,'0')}`;
      if(remaining<=0 && gameState.running && !bossActive){ gameClear('time'); }
    }

    // --- Game Over / Clear ---
    function gameOver(){
      bgm.stop(); sfx.gameover();
      gameState.running=false;
      document.getElementById('finalScore').textContent=gameState.score;
      document.getElementById('gameOver').style.display='block';
    }
    function gameClear(reason){
      // ステージ1のボス撃破なら次ステージへ、ステージ2なら完全クリア
      if(reason==='boss' && currentStage===1){
        goToNextStage();
        return;
      }
      // 完全クリア
      bgm.stop(); sfx.clear();
      gameState.running=false;
      const panel=document.getElementById('gameOver');
      const h=panel.querySelector('h1'); h.textContent='ゲームクリア!🎉'; h.style.color='#4CAF50';
      const p=panel.querySelector('p');
      p.innerHTML=(reason==='boss'?`ボス撃破!<br>最終スコア: <span id="finalScore">${gameState.score}</span>`:`3分生存達成!<br>最終スコア: <span id="finalScore">${gameState.score}</span>`);
      panel.style.display='block';
    }

    // --- Reset / Start helpers ---
    function resetAndPause(pause=true, stage=1){
      currentStage = stage;
      gameState.running=!pause; gameState.score = (stage===1? 0 : gameState.score);
      gameState.lives = (stage===1? 3 : gameState.lives);
      gameState.startTime=Date.now();
      player.x=canvas.width/2; player.y=canvas.height-100; player.bullets=[];
      enemies=[]; powerups=[]; bombs=[]; particles=[]; boss=null; bossActive=false; bossDefeated=false; nextBossScore=500;
      activePowerup.type=null; activePowerup.endTime=0; invincibleUntil=0;
      gameSpeed=1.0; gameStartTime=Date.now();
      bossIsSecondForm=false; bossDying=false; bossDeathFlashUntil=0; playerInvulnUntil=0;

      stageScore = 0; // ★ ステージ内累積スコアをリセット

      document.getElementById('score').textContent=String(gameState.score);
      document.getElementById('lives').textContent=String(gameState.lives);
      document.getElementById('timer').textContent='3:00';
      document.getElementById('powerupStatus').style.display='none';
      const over=document.getElementById('gameOver'); over.style.display='none'; const h=over.querySelector('h1'); h.textContent='ゲームオーバー'; h.style.color='#ff4444'; over.querySelector('p').innerHTML='最終スコア: <span id="finalScore">0</span>';
      lastEnemySpawn=Date.now(); lastPowerupSpawn=Date.now(); lastBombSpawn=Date.now();
      theme.apply(stage);
      if(pause) bgm.stop();
    }
    function startGame(){
      gameState.running=true;
      gameState.startTime=Date.now();
      gameStartTime=Date.now();
      bgm.switchMode('normal'); // 通常BGMから開始
      bgm.start();
    }

    // --- Boss spawn / morph (stage-aware) ---
    function spawnBoss(){
      if(bossActive || bossDefeated) return;

      if(currentStage === 2){
        // ★ ステージ2：このステージ内の獲得スコアが500に到達したら出現
        if(stageScore >= STAGE2_BOSS_SCORE){
          bossActive=true; bossIsSecondForm=false; bossDying=false;
          boss={ type:'octo', x:canvas.width/2, y:-140, targetY:200, width:130, height:120, maxHealth:70, health:70,
                 speed:3.2, direction:1, lastBombDrop:Date.now(), bombDropDelay:1600, phase:1, animationFrame:0, tent:8, rushCooldown:0 };
          bgm.switchMode('boss');
        }
      }else{
        // ステージ1：従来のスコアトリガー
        if(gameState.score >= nextBossScore){
          bossActive=true; bossIsSecondForm=false; bossDying=false;
          boss={ type:'ship', x:canvas.width/2, y:-100, targetY:150, width:120, height:100, maxHealth:50, health:50,
                 speed:3, direction:1, lastBombDrop:Date.now(), bombDropDelay:2000, phase:1, animationFrame:0 };
          bgm.switchMode('boss');
        }
      }
    }

    function morphBossToSecondForm(){
      if(!boss) return;
      sfx.bossMorph();
      bossIsSecondForm=true;

      if(boss.type==='ship'){
        boss.width*=2; boss.height*=2;
        boss.maxHealth=120; boss.health=boss.maxHealth;
        boss.speed=4; boss.bombDropDelay=900; boss.phase=2;
      }else{ // octo
        boss.width*=1.8; boss.height*=1.8;
        boss.maxHealth=140; boss.health=boss.maxHealth;
        boss.speed=3.8; boss.bombDropDelay=900; boss.phase=2;
      }

      bgm.switchMode('boss2'); // 第二形態BGM
      for(let j=0;j<90;j++){ particles.push({x:boss.x,y:boss.y,vx:(Math.random()-.5)*10,vy:(Math.random()-.5)*10,life:50,maxLife:50,color:`hsl(${(Math.random()*40+300)|0},100%,60%)`}); }
    }

    /* ---- ここから先は後半（2/2）：updateBoss（ship/octo）/ 衝突判定（無敵＆装甲＆stageScore加算）/ ステージ遷移 goToNextStage() / メインループ / 起動 ---- */

    // ===== Boss update & rendering（死亡フラッシュと爆発は共通処理） =====
    function updateBoss(){
      if(!boss) return;

      // 1秒フラッシュ → 大爆発
      if(bossDying){
        const now=Date.now();

        // まばゆい白フラッシュ
        ctx.save(); ctx.translate(boss.x,boss.y);
        ctx.shadowBlur=60; ctx.shadowColor='#FFFFFF'; ctx.globalAlpha=.9;
        ctx.fillStyle='#FFFFFF';
        if(boss.type==='ship'){
          ctx.beginPath();
          ctx.moveTo(0,-boss.height/2);
          ctx.lineTo(boss.width/2,boss.height/2);
          ctx.lineTo(-boss.width/2,boss.height/2);
          ctx.closePath(); ctx.fill();
        }else{ // octo
          ctx.beginPath(); ctx.arc(0,0,Math.max(boss.width,boss.height)/2,0,Math.PI*2); ctx.fill();
        }
        ctx.restore();

        if(now>=bossDeathFlashUntil){
          const bodyR=Math.max(boss.width,boss.height)/2;

          // カラフル爆散
          for(let j=0;j<220;j++){
            particles.push({
              x:boss.x,y:boss.y,
              vx:(Math.random()-.5)*22, vy:(Math.random()-.5)*22,
              life:70,maxLife:70,
              color:`hsl(${Math.random()*360},100%,60%)`
            });
          }
          // 体の2倍まで広がるリング
          for(let r=bodyR; r<=bodyR*2; r+=14){
            particles.push({x:boss.x,y:boss.y,vx:0,vy:0,life:24,maxLife:24,ring:true,ringR:r,color:'#FFFFFF'});
          }
          sfx.explosion('big');

          // 爆風ダメージ（無敵は無効）
          const dx=player.x-boss.x, dy=player.y-boss.y, dist=Math.hypot(dx,dy);
          const damageRadius=bodyR;
          if(dist<=damageRadius && Date.now()>=invincibleUntil){
            gameState.lives--;
            gameState.score=Math.max(0, gameState.score-200);
            document.getElementById('lives').textContent=gameState.lives;
            document.getElementById('score').textContent=gameState.score;
            if(navigator.vibrate) navigator.vibrate(200);
            if(gameState.lives<=0){ boss=null; bossActive=false; gameOver(); return; }
          }

          boss=null; bossActive=false; bossIsSecondForm=false; bossDying=false;
          gameClear('boss');
        }
        return;
      }

      // タイプ別更新＆描画
      if(boss.type==='ship') updateBossShip();
      else updateBossOcto();

      // HPバー（共通）
      if(boss){
        const barW=300, barH=20, barX=canvas.width/2-barW/2, barY=50;
        ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(barX-5,barY-5,barW+10,barH+10);
        ctx.fillStyle='#333'; ctx.fillRect(barX,barY,barW,barH);
        const healthW=(boss.health/boss.maxHealth)*barW;
        const g=ctx.createLinearGradient(barX,0,barX+barW,0);
        const baseGrad = bossIsSecondForm ? ['#FF4444','#8B0000'] :
                         (boss.phase===3 ? ['#FF0000','#8B0000'] :
                         (boss.phase===2 ? ['#FFA500','#FF4500'] : ['#9370DB','#4B0082']));
        g.addColorStop(0, baseGrad[0]); g.addColorStop(1, baseGrad[1]);
        ctx.fillStyle=g; ctx.fillRect(barX,barY,healthW,barH);
        ctx.strokeStyle='#FFF'; ctx.lineWidth=2; ctx.strokeRect(barX,barY,barW,barH);

        ctx.fillStyle='#FFF'; ctx.font='bold 24px Arial'; ctx.textAlign='center';
        const title = (boss.type==='octo') ? (bossIsSecondForm?'🐙 OCTO II':'🐙 OCTO') : (bossIsSecondForm?'⚡ BOSS II ⚡':'⚡ BOSS ⚡');
        ctx.fillText(title, canvas.width/2, barY-10);
        if(boss.phase>1 && !bossIsSecondForm){
          ctx.fillStyle=boss.phase===3?'#FF0000':'#FFA500';
          ctx.font='bold 20px Arial';
          ctx.fillText(`PHASE ${boss.phase}!`, canvas.width/2, barY+barH+25);
        }
      }
    }

    // --- Boss: Stage1（戦艦） ---
    function updateBossShip(){
      if(!boss) return;
      boss.animationFrame+=.1;

      // 入場
      if(boss.y<boss.targetY){ boss.y+=2; }
      else{
        let moveSpeed=boss.speed;
        if(boss.phase===2) moveSpeed*=2;
        if(boss.phase===3) moveSpeed*=3;
        boss.x+=boss.direction*moveSpeed;
        if(boss.x<=boss.width/2 || boss.x>=canvas.width-boss.width/2) boss.direction*=-1;

        // 第二形態：緩追尾
        if(bossIsSecondForm){
          const towardX=Math.sign(player.x-boss.x);
          boss.x+=towardX*.8*boss.speed;
          boss.y+=Math.sin(boss.animationFrame*.5)*.8;
          boss.x=Math.max(boss.width/2, Math.min(canvas.width-boss.width/2, boss.x));
          boss.y=Math.max(boss.height/2, Math.min(boss.targetY+40, boss.y));
        }

        // 爆弾（蛇行）
        const now=Date.now();
        if(now-boss.lastBombDrop>boss.bombDropDelay){
          let waveA=2, waveF=.05;
          if(boss.phase===2){waveA=4;waveF=.08;}
          else if(boss.phase===3){waveA=6;waveF=.12;}
          bombs.push({ x:boss.x, y:boss.y+boss.height/2, width:35, height:35,
                       speed:3*gameSpeed, pulse:0, waveAmplitude:waveA, waveFrequency:waveF,
                       waveOffset:0, isBossBomb:true });
          boss.lastBombDrop=now;
        }
      }

      // フェーズ
      const hpPct=boss.health/boss.maxHealth;
      if(hpPct<=.3 && boss.phase<3){ boss.phase=3; boss.bombDropDelay=900; }
      else if(hpPct<=.6 && boss.phase<2){ boss.phase=2; boss.bombDropDelay=1300; }

      // 描画
      ctx.save(); ctx.translate(boss.x,boss.y);
      ctx.shadowBlur=30;
      if(bossIsSecondForm) ctx.shadowColor='#FF2222';
      else if(boss.phase===3) ctx.shadowColor='#FF0000';
      else if(boss.phase===2) ctx.shadowColor='#FF8800';
      else ctx.shadowColor='#8800FF';

      const pulse=Math.sin(boss.animationFrame)*5;
      ctx.fillStyle = bossIsSecondForm?'#8B0000' : (boss.phase===3?'#8B0000' : (boss.phase===2?'#FF4500':'#4B0082'));
      ctx.beginPath(); ctx.moveTo(0,-boss.height/2); ctx.lineTo(boss.width/2,boss.height/2); ctx.lineTo(-boss.width/2,boss.height/2); ctx.closePath(); ctx.fill();

      ctx.fillStyle = bossIsSecondForm?'#FF2222' : (boss.phase===3?'#FF0000' : (boss.phase===2?'#FFA500':'#9370DB'));
      ctx.beginPath(); ctx.arc(0,0,30+pulse,0,Math.PI*2); ctx.fill();

      ctx.fillStyle='#FF0000'; ctx.beginPath(); ctx.arc(-20,-10,8,0,Math.PI*2); ctx.arc(20,-10,8,0,Math.PI*2); ctx.fill();

      ctx.fillStyle = bossIsSecondForm?'#B22222' : (boss.phase===3?'#B22222' : (boss.phase===2?'#FF6347':'#663399'));
      ctx.fillRect(-boss.width/2-10,0,10,30); ctx.fillRect(boss.width/2,0,10,30);
      ctx.restore();
    }

    // --- Boss: Stage2（タコ） ---
    function updateBossOcto(){
      if(!boss) return;
      boss.animationFrame+=.1;

      if(boss.y<boss.targetY){ boss.y+=2.2; }
      else{
        const t=boss.animationFrame;
        const wobbleY = Math.sin(t*0.6)*1.2 + (Math.random()-.5)*0.8;
        const wobbleX = Math.sin(t*0.35)*1.2;
        boss.y += wobbleY;
        boss.x += boss.direction*(boss.speed + wobbleX);
        if(boss.x<=boss.width/2 || boss.x>=canvas.width-boss.width/2) boss.direction*=-1;

        // 体当たりラッシュ
        const now=Date.now();
        if(!bossIsSecondForm){
          if(now>boss.rushCooldown){
            if(Math.random()<0.3){
              boss.rushCooldown = now + 2200;
              const dir = Math.sign(player.x - boss.x) || (Math.random()<.5?-1:1);
              boss._rushEnd = now + 500;
              boss._rushVX  = dir * (4.2*gameSpeed);
              boss._rushVY  = 1.2*gameSpeed;
            }else{
              boss.rushCooldown = now + 900;
            }
          }
          if(boss._rushEnd && now<boss._rushEnd){
            boss.x += boss._rushVX;
            boss.y += boss._rushVY;
            boss.x=Math.max(boss.width/2, Math.min(canvas.width-boss.width/2, boss.x));
            boss.y=Math.max(boss.height/2, Math.min(boss.targetY+80, boss.y));
          }
        }else{
          if(now>boss.rushCooldown){
            boss.rushCooldown = now + 1100;
            const dir = Math.sign(player.x - boss.x) || (Math.random()<.5?-1:1);
            boss._rushEnd = now + 520;
            boss._rushVX  = dir * (5.0*gameSpeed);
            boss._rushVY  = 1.5*gameSpeed;
          }
          if(boss._rushEnd && now<boss._rushEnd){
            boss.x += boss._rushVX;
            boss.y += boss._rushVY;
            boss.x=Math.max(boss.width/2, Math.min(canvas.width-boss.width/2, boss.x));
            boss.y=Math.max(boss.height/2, Math.min(boss.targetY+90, boss.y));
          }
        }

        // 墨弾（蛇行弱め・たまに2個）
        const dropDelay = boss.bombDropDelay;
        if(now-boss.lastBombDrop>dropDelay){
          bombs.push({
            x:boss.x+(Math.random()*40-20), y:boss.y+boss.height/2,
            width:35, height:35, speed:(3.2+Math.random()*0.6)*gameSpeed,
            pulse:0, waveAmplitude:(bossIsSecondForm?4:2), waveFrequency:(bossIsSecondForm?0.1:0.06),
            waveOffset:Math.random()*Math.PI*2, isBossBomb:true
          });
          if(Math.random()<0.35){
            bombs.push({
              x:boss.x+(Math.random()*40-20), y:boss.y+boss.height/2-30,
              width:35, height:35, speed:(3.2+Math.random()*0.6)*gameSpeed,
              pulse:0, waveAmplitude:(bossIsSecondForm?4:2), waveFrequency:(bossIsSecondForm?0.1:0.06),
              waveOffset:Math.random()*Math.PI*2, isBossBomb:true
            });
          }
          boss.lastBombDrop=now;
        }
      }

      // フェーズ管理
      const hpPct=boss.health/boss.maxHealth;
      if(hpPct<=.3 && boss.phase<3){ boss.phase=3; boss.bombDropDelay=800; }
      else if(hpPct<=.6 && boss.phase<2){ boss.phase=2; boss.bombDropDelay=1100; }

      // 描画（胴体＋触手）
      ctx.save(); ctx.translate(boss.x,boss.y);
      const coreR = Math.max(40, boss.width*0.28);
      ctx.shadowBlur=25;
      ctx.shadowColor = bossIsSecondForm ? '#ff1e6e' : '#a000ff';
      ctx.fillStyle   = bossIsSecondForm ? '#7a0022' : '#3a005e';
      ctx.beginPath(); ctx.arc(0,0,coreR,0,Math.PI*2); ctx.fill();

      ctx.fillStyle='#ff3b3b';
      ctx.beginPath(); ctx.ellipse(-coreR*0.28,-coreR*0.18,8,10,0,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse( coreR*0.28,-coreR*0.18,8,10,0,0,Math.PI*2); ctx.fill();

      const pulse=Math.sin(boss.animationFrame*1.2)*4;
      ctx.fillStyle = bossIsSecondForm ? '#ff2a7f' : '#b366ff';
      ctx.beginPath(); ctx.arc(0,0,18+pulse,0,Math.PI*2); ctx.fill();

      const tent=boss.tent||8, segs=6;
      for(let i=0;i<tent;i++){
        const ang=(i/tent)*Math.PI*2 + Math.sin(boss.animationFrame*0.4)*0.15;
        const len=(bossIsSecondForm?70:55) + Math.sin(boss.animationFrame*0.9+i)*6;
        let px=0, py=coreR*0.6;
        ctx.strokeStyle=bossIsSecondForm?'#ff4f9a':'#b380ff';
        ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(px,py);
        for(let s=1;s<=segs;s++){
          const t=s/segs;
          const wob=Math.sin(boss.animationFrame*0.9 + i + t*3)*(bossIsSecondForm?10:7);
          const nx=Math.cos(ang)*t*len + Math.cos(ang+Math.PI/2)*wob;
          const ny=py + Math.sin(ang)*t*len + Math.sin(ang+Math.PI/2)*wob;
          ctx.lineTo(nx,ny);
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    // ===== Collisions（無敵＆装甲＆ステージ2のstageScore加算） =====
    function checkCollisions(){
      // bullets × enemies
      for(let i=player.bullets.length-1;i>=0;i--){
        const b=player.bullets[i];
        let hit=false;
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          if(b.x>e.x-e.width/2 && b.x<e.x+e.width/2 && b.y>e.y-e.height/2 && b.y<e.y+e.height/2){
            createExplosion(e.x,e.y);
            e.health=(e.health||1)-1;
            if(e.health<=0){
              enemies.splice(j,1);
              const gain=(e.score||10);
              gameState.score += gain;
              document.getElementById('score').textContent=gameState.score;
              // ★ ステ2のボス出現用：ステージ内の「獲得スコア」を加算（減点は加算しない）
              if(currentStage===2 && !bossActive && !bossDefeated){
                stageScore += gain;
              }
              sfx.explosion('small');
            }else{
              sfx.hit();
            }
            hit=true; break;
          }
        }
        if(hit){ player.bullets.splice(i,1); }
      }

      // player × enemies
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const dx=player.x-e.x, dy=player.y-e.y, dist=Math.hypot(dx,dy);
        if(dist<(player.width/2+e.width/2)){
          createExplosion(e.x,e.y);
          enemies.splice(i,1);
          if(Date.now()>=invincibleUntil){
            gameState.lives--;
            document.getElementById('lives').textContent=gameState.lives;
            sfx.hit();
            if(gameState.lives<=0){ gameOver(); }
          }
        }
      }

      // player × bombs
      for(let i=bombs.length-1;i>=0;i--){
        const bb=bombs[i];
        const dx=player.x-bb.x, dy=player.y-bb.y, dist=Math.hypot(dx,dy);
        if(dist<(player.width/2+bb.width/2)){
          for(let j=0;j<30;j++){
            particles.push({x:bb.x,y:bb.y,vx:(Math.random()-.5)*12,vy:(Math.random()-.5)*12,life:50,maxLife:50,color:'#FF0000'});
          }
          bombs.splice(i,1);
          if(Date.now()>=invincibleUntil){
            // 減点は stageScore には影響させない
            gameState.score=Math.max(0, gameState.score-50);
            document.getElementById('score').textContent=gameState.score;
            gameState.lives--;
            document.getElementById('lives').textContent=gameState.lives;
            sfx.explosion('bomb'); sfx.hit();
            if(navigator.vibrate) navigator.vibrate(200);
            if(gameState.lives<=0){ gameOver(); }
          }
        }
      }

      // player × powerups（shield対応）
      for(let i=powerups.length-1;i>=0;i--){
        const p=powerups[i];
        const dx=player.x-p.x, dy=player.y-p.y, dist=Math.hypot(dx,dy);
        if(dist<(player.width/2+p.width/2)){
          if(p.type==='shield'){
            invincibleUntil=Date.now()+6000; // 6秒無敵
            activePowerup.type=null; activePowerup.endTime=0; // 表示はリングで
            sfx.powerupShield();
          }else{
            activePowerup.type=p.type; activePowerup.endTime=Date.now()+5000; sfx.powerup();
          }
          for(let j=0;j<20;j++){
            particles.push({x:p.x,y:p.y,vx:(Math.random()-.5)*6,vy:(Math.random()-.5)*6,life:40,maxLife:40,
              color: p.type==='double' ? '#FFD700' : (p.type==='triple' ? '#FF00FF' : '#9cf6ff')});
          }
          powerups.splice(i,1);
        }
      }
    }

    // --- Boss collisions（弾／体当たり） ---
    function checkBossCollisions(){
      if(!boss || boss.health<=0) return;

      // bullets × boss
      for(let i=player.bullets.length-1;i>=0;i--){
        const bl=player.bullets[i];
        const dx=bl.x-boss.x, dy=bl.y-boss.y, dist=Math.hypot(dx,dy);
        const hitR=(boss.type==='ship')?boss.width/2:Math.max(boss.width,boss.height)/2;
        if(dist<hitR){
          for(let j=0;j<5;j++){
            particles.push({
              x:bl.x,y:bl.y,
              vx:(Math.random()-.5)*4, vy:(Math.random()-.5)*4,
              life:20,maxLife:20,
              color: bossIsSecondForm ? '#FF2222' : (boss.phase===3?'#FF0000':(boss.phase===2?'#FFA500':'#9370DB'))
            });
          }
          player.bullets.splice(i,1);
          boss.health--;

          if(boss.health<=0){
            if(!bossIsSecondForm){
              morphBossToSecondForm();
              return;
            }else{
              bossDying=true; sfx.flash(); bossDeathFlashUntil=Date.now()+1000; // 1秒光る
              return;
            }
          }
        }
      }

      // player × boss（体当たりダメージ・短期無敵）
      if(boss && !bossDying){
        const dx=player.x-boss.x, dy=player.y-boss.y, dist=Math.hypot(dx,dy);
        const touchR=(boss.type==='ship')?boss.width/2:Math.max(boss.width,boss.height)/2;
        if(dist<(player.width/2+touchR)){
          const now=Date.now();
          if(now>playerInvulnUntil && now>=invincibleUntil){
            gameState.lives--; document.getElementById('lives').textContent=gameState.lives;
            player.x=canvas.width/2; player.y=canvas.height-120;
            playerInvulnUntil=now+1000; // 1秒被弾無敵
            sfx.hit();
            if(navigator.vibrate) navigator.vibrate(120);
            if(gameState.lives<=0){ gameOver(); return; }
          }
        }
      }
    }

    // ===== Stage transition（1→2） =====
    function goToNextStage(){
      const panel=document.getElementById('stagePanel');
      panel.style.display='flex';
      panel.style.opacity='0';
      panel.offsetHeight;
      panel.style.transition='opacity 250ms ease';
      panel.style.opacity='1';

      setTimeout(()=>{
        bgm.stop();
        resetAndPause(false, /*stage*/2); // ライフ/スコアは持ち越し、stageScoreは0へ
        setTimeout(()=>{
          panel.style.opacity='0';
          setTimeout(()=>{ panel.style.display='none'; }, 250);
        }, 500);
        startGame();
      }, 700);
    }

    // ===== Main loop =====
    function gameLoop(){
      // うっすら残像
      ctx.fillStyle='rgba(0, 4, 40, .3)';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      if(gameState.running){
        updateTimer();
        updateGameSpeed();
        updateStars();

        // タッチ追従＆自動射撃
        if(touchX!==null && touchY!==null){
          const dx=touchX-player.x, dy=touchY-player.y, d=Math.hypot(dx,dy);
          if(d>5){
            player.x += (dx/d)*player.speed;
            player.y += (dy/d)*player.speed;
            player.x=Math.max(player.width/2, Math.min(canvas.width-player.width/2, player.x));
            player.y=Math.max(player.height/2, Math.min(canvas.height-player.height/2, player.y));
          }
          shoot();
        }

        spawnEnemy();
        spawnBoss();      // ★ ステージ2は stageScore>=500 で出現
        spawnPowerup();
        spawnBomb();

        // パワーアップHUD（無敵はリング表示のみ／HUDは火力系のみ）
        const now=Date.now();
        const ps=document.getElementById('powerupStatus');
        if(activePowerup.type && now<activePowerup.endTime){
          const remain=Math.ceil((activePowerup.endTime-now)/1000);
          const name=activePowerup.type==='double' ? '⚡ 二重弾' : '✨ 三方向弾';
          ps.textContent=`${name} (${remain}秒)`;
          ps.style.display='block';
          ps.style.color= activePowerup.type==='double'? '#FFD700' : '#FF00FF';
        }else{
          ps.style.display='none';
          if(now>= (activePowerup.endTime||0)) activePowerup.type=null;
        }

        updateBullets();
        updateEnemies();
        updatePowerups();
        updateBombs();
        updateBoss();
        updateParticles();
        checkCollisions();
        checkBossCollisions();

        drawPlayer();
      }

      requestAnimationFrame(gameLoop);
    }

    // === Boot ===
    resetAndPause(true, 1);
    gameLoop();
  </script>
</body>
</html>


