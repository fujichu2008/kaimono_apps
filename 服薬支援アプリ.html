<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>服薬ミッション：まち育成</title>
<meta name="theme-color" content="#185adb">
<style>
:root{
  --bg:#f4f8ff; --card:#ffffff; --line:#e3ecff; --text:#0f172a; --muted:#5b6b8a;
  --accent:#185adb; --accent-2:#0e49c7; --ok:#16a34a; --warn:#ef4444; --pill:#eaf2ff;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui, -apple-system, "Segoe UI", Roboto, Arial}
button{font:inherit}

/* Header */
header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,#fff 0%,#f6f9ff 100%);border-bottom:1px solid var(--line);padding:10px 14px}
.brand{display:flex;align-items:baseline;gap:10px;flex-wrap:wrap}
.brand h1{font-size:18px;margin:0}
.brand .meta{font-size:12px;color:var(--muted)}

/* Tabs */
.tabs{display:flex;gap:8px;padding:8px 12px;border-bottom:1px solid var(--line);background:#fff;position:sticky;top:56px;z-index:9}
.tab{flex:1}
.tab button{width:100%;padding:10px;border:1px solid var(--line);border-radius:12px;background:#fff}
.tab button.active{border-color:var(--accent);box-shadow:0 0 0 2px #185adb20}

main{padding:12px}
.card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px;margin-bottom:12px}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.badge{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:var(--pill);border:1px solid var(--line);font-size:12px;color:var(--muted)}
.small{font-size:12px;color:var(--muted)}
.kpi{display:flex;gap:10px;align-items:center}
.kpi .big{font-size:26px;font-weight:700}
.kpi .sub{font-size:12px;color:var(--muted)}

/* Big action buttons */
.grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
.bigbtn{position:relative;border:1px solid var(--line);border-radius:14px;padding:12px;background:#fff;min-height:76px}
.bigbtn .title{font-size:13px;color:var(--muted)}
.bigbtn .state{font-size:20px;font-weight:700}
.bigbtn.active{border-color:var(--accent);box-shadow:0 0 0 3px #185adb22}
.bigbtn.done{background:#f5fff7;border-color:#c6f6d5}
.bigbtn.late{background:#fff8f0;border-color:#fed7aa}
.bigbtn .pulse{position:absolute;inset:0;border-radius:16px;pointer-events:none;}

/* City View (home内に統合) */
#cityWrap{position:relative;height:340px;overflow:hidden;border-radius:16px;border:1px solid var(--line);background:linear-gradient(180deg,#a8d1ff 0%,#d7ecff 50%,#d5f0d2 50%,#c9e8c4 100%)}
#sky{position:absolute;inset:0 0 50% 0;overflow:hidden}
#land{position:absolute;inset:50% 0 0 0;overflow:hidden;background:linear-gradient(180deg,#d5f0d2 0%,#c9e8c4 100%)}
/* ★ ミニイベント専用レイヤー：renderCityのクリア対象外 */
#microLayer{position:absolute;inset:0;pointer-events:none}
.obj{position:absolute;user-select:none;line-height:1}
.twinkle{animation:twinkle 2.2s infinite ease-in-out}
@keyframes twinkle{0%,100%{opacity:.15;transform:scale(.9)}50%{opacity:1;transform:scale(1)}}
.cloud{animation:cloud 60s linear infinite}
@keyframes cloud{0%{transform:translateX(-20%)}100%{transform:translateX(120%)}}
.bird{animation:bird 18s linear infinite}
@keyframes bird{0%{transform:translateX(-10vw) translateY(0)}50%{transform:translateX(50vw) translateY(-8px)}100%{transform:translateX(110vw) translateY(0)}}
.plane{animation:plane 25s linear infinite}
@keyframes plane{0%{transform:translateX(110vw)}100%{transform:translateX(-120vw)}}
/* 車は右→左へ反転 */
.car{animation:car 14s linear infinite}
@keyframes car{0%{transform:translateX(20vw)}100%{transform:translateX(-120vw)}}
.slow{animation-duration:22s}
.fast{animation-duration:9s}

/* Celebration */
#celebration{position:fixed;inset:0;pointer-events:none;display:none}
.confetti{position:absolute;will-change:transform;animation:fall linear forwards}
@keyframes fall{to{transform:translateY(100vh) rotate(720deg);opacity:0}}

/* Settings */
label.switch{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border:1px solid var(--line);border-radius:10px;background:#fff}
input[type="date"]{padding:8px;border:1px solid var(--line);border-radius:10px}
.toggle{width:42px;height:24px;border-radius:999px;background:#e5efff;position:relative;transition:.2s}
.toggle::after{content:"";position:absolute;top:2px;left:2px;width:20px;height:20px;border-radius:50%;background:#fff;box-shadow:0 1px 2px #0002;transition:.2s}
input[type="checkbox"].sm:checked + .toggle{background:#b9d3ff}
input[type="checkbox"].sm:checked + .toggle::after{left:20px}
.save{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:12px}
.danger{background:#fff;color:#ef4444;border:1px solid #fecaca;padding:10px 14px;border-radius:12px}
.danger:hover{filter:brightness(0.98)}

/* History */
#historyGrid{display:grid;grid-template-columns:repeat(7,1fr);gap:6px}
.dot{aspect-ratio:1;width:100%;border-radius:6px;background:#edf2ff;border:1px solid var(--line);position:relative}
.dot.m::before,.dot.n::before,.dot.e::before{content:"";position:absolute;left:50%;transform:translateX(-50%);width:6px;height:6px;border-radius:50%;background:#c7d2fe;top:6px}
.dot.n::after{content:"";position:absolute;left:50%;transform:translateX(-50%);width:6px;height:6px;border-radius:50%;background:#93c5fd;top:16px}
.dot.e .tail{position:absolute;left:50%;transform:translateX(-50%);width:6px;height:6px;border-radius:50%;background:#60a5fa;bottom:6px}
.done .dot{background:#dcfce7;border-color:#a7f3d0}

/* 衰退時のやや暗転・しぼみ */
.city-dim{filter:brightness(0.96) saturate(0.92); transform:scale(0.985); transition:.6s}

/* === Chicken glow === */
.glow {
  position: relative;
  animation: glowPulse 1.8s ease-in-out infinite;
  filter:
    drop-shadow(0 0 4px rgba(255,215,0,.85))
    drop-shadow(0 0 9px rgba(255,200,0,.55));
}
@keyframes glowPulse {
  0%,100% { transform: scale(1);   filter: drop-shadow(0 0 3px rgba(255,215,0,.8)) drop-shadow(0 0 7px rgba(255,200,0,.5)); }
  50%     { transform: scale(1.06); filter: drop-shadow(0 0 8px rgba(255,230,120,.95)) drop-shadow(0 0 14px rgba(255,210,80,.65)); }
}

@media (max-width:480px){
  #cityWrap{height:280px}
}
</style>
</head>
<body>
<header>
  <div class="brand">
    <h1>服薬ミッション：まち育成</h1>
    <div class="meta" id="rankBadge">ランク: -</div>
    <div class="meta" id="daysLeft">残り日数: -</div>
  </div>
</header>

<!-- Tabs：先頭を「育成」に -->
<nav class="tabs">
  <div class="tab"><button class="active" data-tab="home">育成</button></div>
  <div class="tab"><button data-tab="history">履歴</button></div>
  <div class="tab"><button data-tab="settings">設定</button></div>
</nav>

<main>
  <!-- Home -->
  <section id="home" class="view">
    <div class="card kpi">
      <div class="big" id="rateVal">--%</div>
      <div>
        <div class="sub">コンプリート率</div>
        <div class="small" id="comment">コメント…</div>
      </div>
      <div style="margin-left:auto" class="badge" id="streakBadge">連続0日</div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="small">今日は… <span id="todaySummary">-</span></div>
        <div class="badge">ミッション終了 <span id="missionEnd">-</span></div>
      </div>
      <div class="grid3" style="margin-top:10px">
        <button class="bigbtn" id="btnM" data-slot="m">
          <div class="title">朝</div>
          <div class="state" data-state>—</div>
          <div class="pulse"></div>
        </button>
        <button class="bigbtn" id="btnN" data-slot="n">
          <div class="title">昼</div>
          <div class="state" data-state>—</div>
          <div class="pulse"></div>
        </button>
        <button class="bigbtn" id="btnE" data-slot="e">
          <div class="title">夕</div>
          <div class="state" data-state>—</div>
          <div class="pulse"></div>
        </button>
      </div>
      <div class="small" style="margin-top:8px">※ 当日内は遅刻完了も可。長押しで取り消し</div>
    </div>

    <!-- 統合した街ビュー -->
    <div class="card" style="margin-top:10px">
      <div id="cityWrap">
        <div id="sky"></div>
        <div id="land"></div>
        <!-- ★ ミニイベント専用レイヤー（クリアされない） -->
        <div id="microLayer"></div>
      </div>
      <div class="small" style="margin-top:6px">期間に合わせて“じわっ”と成長。100%で同じ最終形に到達します。</div>
    </div>
  </section>

  <!-- History -->
  <section id="history" class="view" style="display:none">
    <div class="card">
      <div class="row"><div class="small">直近7日（上:朝 / 中:昼 / 下:夕）</div></div>
      <div id="historyGrid" style="margin-top:10px"></div>
    </div>
  </section>

  <!-- Settings -->
  <section id="settings" class="view" style="display:none">
    <div class="card">
      <div class="row">
        <div>
          <div class="small">開始日</div>
          <input type="date" id="startDate">
        </div>
        <div>
          <div class="small">終了日</div>
          <input type="date" id="endDate">
        </div>
      </div>
      <div class="row" style="margin-top:10px;gap:12px">
        <label class="switch"><input id="freqM" type="checkbox" class="sm"><span class="toggle"></span> 朝</label>
        <label class="switch"><input id="freqN" type="checkbox" class="sm"><span class="toggle"></span> 昼</label>
        <label class="switch"><input id="freqE" type="checkbox" class="sm"><span class="toggle"></span> 夕</label>
      </div>
      <div class="row" style="margin-top:12px;justify-content:space-between;gap:8px">
        <div>
          <button class="save" id="saveSettings">保存</button>
          <span class="small" id="saveMsg" style="margin-left:8px"></span>
        </div>
        <button class="danger" id="resetAll" title="設定と記録を初期化し、起点を今日・終点を1週間後に仮設定">リセット</button>
      </div>
      <div class="small" style="margin-top:8px">※ 個人情報は保持しません。端末内ローカルのみ保存。</div>
    </div>
  </section>
</main>

<div id="celebration"></div>
<footer class="small">v4 保存型×期間正規化×季節×UFO×ミニイベント×ニワトリ物語×2時ロールオーバー</footer>

<script>
/* ========= Storage Keys ========= */
const LS_SETTINGS = 'MEDCITY_settings_v1';
const LS_LOG = 'MEDCITY_log_v1'; // { 'YYYY-MM-DD': {m:true/false, n:..., e:..., ts:{m:epoch,...}} }
const LS_META = 'MEDCITY_meta_v1'; // {streak,bestStreak,seed,celebed?}

/* ========= Utilities ========= */
const $ = sel => document.querySelector(sel);
const $$ = sel => [...document.querySelectorAll(sel)];

/* ★ 2時ロールオーバー対応の日付キー */
function todayStr(d=new Date()){
  const dt = new Date(d);
  if(dt.getHours() < 2){ dt.setDate(dt.getDate() - 1); }
  return dt.toLocaleDateString('sv-SE'); // YYYY-MM-DD
}

function parseDate(str){ const [y,m,dd]=str.split('-').map(Number); return new Date(y, m-1, dd); }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function lerp(a,b,t){ return a+(b-a)*t }
function isWeekend(d=new Date()){ const w=d.getDay(); return w===0||w===6; }

/* PRNG seeded */
function makeRand(seed){ let s = seed|0 || 123456789; return function(){ s ^= s<<13; s ^= s>>>17; s ^= s<<5; return (s>>>0)/4294967296; } }

/* ========= Time Slots ========= */
function slotOf(now=new Date()){
  const h = now.getHours();
  // 日付切替は午前2時：2〜10時=朝 / 11〜16=昼 / それ以外=夕
  if (h>=2 && h<=10) return 'm';
  if (h>=11 && h<=16) return 'n';
  return 'e';
}

/* ========= Load / Save ========= */
function load(k, def){ try{ return JSON.parse(localStorage.getItem(k)) ?? def }catch{ return def } }
function save(k, v){ localStorage.setItem(k, JSON.stringify(v)) }

/* ========= Defaults ========= */
function ensureDefaults(){
  const s = load(LS_SETTINGS);
  if(!s){
    const start = todayStr();
    const end = todayStr(new Date(Date.now()+1000*60*60*24*27)); // 28日後
    save(LS_SETTINGS, {startDate:start, endDate:end, freq:{m:true,n:false,e:true}});
  }
  if(!load(LS_LOG)) save(LS_LOG, {});
  if(!load(LS_META)) save(LS_META, {streak:0,bestStreak:0,seed:Math.floor(Math.random()*1e9)});
}

/* ========= Stats ========= */
function calcStats(upToToday=true){
  const settings = load(LS_SETTINGS, {});
  const log = load(LS_LOG, {});
  if(!settings.startDate||!settings.endDate) return {rate:0, planned:0, done:0, streak:0, best:0};
  const start = parseDate(settings.startDate);
  const end = parseDate(settings.endDate);
  const today = new Date();
  const last = upToToday ? new Date(today.getFullYear(), today.getMonth(), today.getDate()) : end;
  const days = Math.floor((last - start)/86400000) + 1;
  const freqCount = ['m','n','e'].filter(k=>settings.freq[k]).length;
  const planned = clamp(days,0,1e6) * freqCount;
  let done=0;
  Object.entries(log).forEach(([d,val])=>{
    const dt = parseDate(d);
    if(dt<=last){ done += ['m','n','e'].reduce((acc,k)=>acc + (val[k]?1:0),0); }
  });
  const rate = planned? Math.round(done*100/planned) : 0;
  const meta = load(LS_META, {streak:0,bestStreak:0});
  return {rate, planned, done, streak:meta.streak, best:meta.bestStreak};
}

function daysLeft(){
  const {endDate} = load(LS_SETTINGS, {});
  if(!endDate) return '-';
  const t = new Date(); const end = parseDate(endDate);
  const diff = Math.ceil((end - new Date(t.getFullYear(),t.getMonth(),t.getDate()))/86400000);
  return diff>=0? diff : 0;
}
function missionEndStr(){ const s=load(LS_SETTINGS,{}); return s?.endDate||'-' }

/* ========= Progress (for nuanced comments) ========= */
function progressInfo(){
  const s = load(LS_SETTINGS,{});
  if(!s?.startDate || !s?.endDate) return {p:0, isLastDay:false};
  const start = parseDate(s.startDate);
  const end   = parseDate(s.endDate);
  const today = new Date();
  const clampDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const totalDays = Math.max(1, Math.floor((end - start)/86400000) + 1);
  const elapsed   = Math.min(totalDays, Math.max(1, Math.floor((clampDate - start)/86400000) + 1));
  const p = Math.min(1, Math.max(0, elapsed / totalDays));
  const isLastDay = clampDate.toDateString() === end.toDateString();
  return {p, isLastDay, totalDays, elapsed};
}

// 直近3日の完了率(0..1)
function recentScore(){
  const s = load(LS_SETTINGS,{});
  const log = load(LS_LOG,{});
  if(!s?.startDate) return 0;
  const enabled = ['m','n','e'].filter(k=>s.freq?.[k]);
  if(enabled.length===0) return 0;

  let done=0, planned=0;
  for(let i=0;i<3;i++){
    const d = new Date(); d.setDate(d.getDate()-i);
    const key = todayStr(d);
    const rec = log[key] || {};
    planned += enabled.length;
    done += enabled.reduce((a,k)=>a + (rec[k]?1:0), 0);
  }
  return planned? done/planned : 0;
}

// 今日の進捗(0..1)
function todayProgress01(){
  const s = load(LS_SETTINGS,{});
  const {states} = todayState();
  const enabled = ['m','n','e'].filter(k=>s?.freq?.[k]);
  if(enabled.length===0) return 0;
  const done = enabled.filter(k=>states[k]==='完了').length;
  return done / enabled.length;
}

/* ===== 季節イベント判定 ===== */
function getSeasonalFlags(date=new Date()){
  const y = date.getFullYear();
  const m = date.getMonth()+1;
  const d = date.getDate();
  const ymd = (M,D)=> new Date(y, M-1, D);
  const inRange = (fromM,fromD,toM,toD) => {
    const t = new Date(y, m-1, d);
    return t >= ymd(fromM,fromD) && t <= ymd(toM,toD);
  };
  const isHalloween = inRange(10,25,10,31);
  const isChristmas = inRange(12,20,12,26);
  const isNewYear   = inRange(1,1,1,3);
  const isNewFiscal = inRange(3,25,4,7);
  return { isHalloween, isChristmas, isNewYear, isNewFiscal };
}

/* ========= City Health（衰退/回復演出用） ========= */
function cityHealth(){
  const s = load(LS_SETTINGS,{}), log = load(LS_LOG,{});
  const enabled = ['m','n','e'].filter(k=>s?.freq?.[k]);
  if(enabled.length===0) return 0.8;

  // 直近7日の重み付き達成率
  let done=0, planned=0;
  for(let i=0;i<7;i++){
    const d = new Date(); d.setDate(d.getDate()-i);
    const w = 1 - i*0.1; // 最近重視
    const rec = log[todayStr(d)] || {};
    planned += enabled.length * w;
    done    += enabled.reduce((a,k)=>a + (rec[k]?1:0), 0) * w;
  }
  const rate7 = planned>0 ? (done/planned) : 0.8;

  const meta = load(LS_META,{streak:0});
  const streakBoost = Math.min(1, meta.streak/14);

  const {states} = todayState();
  const sdone = enabled.filter(k=>states[k]==='完了').length / enabled.length;

  let penalty = 0;
  const brokeStreakToday = (meta.streak===0);
  if(brokeStreakToday) penalty += 0.15;
  if(sdone < 1)        penalty += (1 - sdone)*0.1;

  let h = Math.max(0, Math.min(1, 0.6*rate7 + 0.3*streakBoost + 0.1*sdone - penalty ));
  const recoveryBoost = Math.min(0.25, meta.streak * 0.02);
  h = Math.min(1, h + recoveryBoost);
  return h;
}

/* ========= Comments & Rank ========= */
function commentFor(rate, p, isLastDay, streak){
  if(rate === 100){
    if(isLastDay) return '完走100%🎉 最高のフィニッシュ！都市に伝説が刻まれました✨';
    if(p < 0.25)  return 'スタートダッシュ100%！このリズムをまずは1週間キープ💪';
    if(p < 0.5)   return '前半100%、素晴らしい！中盤もアラームで安定を📅';
    if(p < 0.9)   return '終盤目前の100%！週末の揺らぎに注意して駆け抜けよう🏁';
    return          'ラストスパートも100%！大花火が見えてきた🎆';
  }
  if(streak>=3 && rate<90) {
    const base = '回復中！この調子で連続服薬を続けよう🔥 ';
    if(rate<40) return base + 'まずは朝固定で波を作ろう👣';
    if(rate<60) return base + '夜の振り返り＋リマインドで安定へ🌙';
    if(rate<75) return base + '食後固定や服薬トレイでリズム維持🍽️';
  }
  if(rate < 40) return p < 0.2 ? 'まずは朝だけ固定で「続ける」を最優先に👣' : 'ここが踏ん張りどころ！小さな仕組み化で巻き返し🔁';
  if(rate < 60) return p < 0.5 ? '半分越えの芽🌱 リマインドで伸ばそう' : '終盤の伸び代大！夜の振り返りで取りこぼしゼロ🌙';
  if(rate < 75) return p < 0.5 ? '良い波！食後固定や服薬トレイで安定🍽️' : '終盤の75%は価値大！休日のパターンを固定⏰';
  if(rate < 90) return p < 0.5 ? '上位帯へ！トリガー習慣とセットで📌' : '90%目前！“遅刻OK”も賢く活用🕒';
  if(rate < 95) return p < 0.75 ? 'ハイレベル帯、油断に注意！チェックリストで確実に✅' : '95%目前！寝る前の最終チェックで仕上げ🌙';
  return 'プロ級！あと僅かで100%。焦らず一つずつ確実に🧭';
}

function rankFor(rate, streak){
  if(rate>=95 && streak>=14) return '知事';
  if(rate>=85 && streak>=7) return '市長';
  if(rate>=70) return '町長';
  return '村長';
}

/* ========= Today state ========= */
function todayState(){
  const settings = load(LS_SETTINGS, {}); const log = load(LS_LOG, {});
  const dStr = todayStr();
  const rec = log[dStr] || {m:false,n:false,e:false,ts:{}};
  const active = slotOf(new Date());
  const states = {m:'—',n:'—',e:'—'};
  ['m','n','e'].forEach(k=>{
    if(!settings.freq[k]) { states[k] = '—'; return; }
    states[k] = rec[k] ? '完了' : '未';
  });
  return {active, states, rec};
}

/* ========= Update UI（上部KPIなど） ========= */
function renderAll(){
  const {rate, streak} = calcStats();
  const {p, isLastDay} = progressInfo();
  $('#rateVal').textContent = rate+"%";
  $('#comment').textContent = commentFor(rate, p, isLastDay, streak);
  const f = getSeasonalFlags();
  if(f.isHalloween) $('#comment').textContent += ' 🎃 ハロウィンWEEK、夜更かしに注意！';
  if(f.isChristmas) $('#comment').textContent += ' 🎄 クリスマスWEEK、予定前に服薬チェック！';
  if(f.isNewYear)   $('#comment').textContent += ' 🎍 三が日は生活リズムが乱れがち。朝固定で！';
  if(f.isNewFiscal) $('#comment').textContent += ' 🌸 新年度は新習慣の作りどき。トリガー行動を決めよう！';

  $('#streakBadge').textContent = `連続${streak}日`;
  $('#rankBadge').textContent = `ランク: ${rankFor(rate, streak)}`;
  $('#daysLeft').textContent = `残り日数: ${daysLeft()}`;
  $('#missionEnd').textContent = missionEndStr();

  const settings = load(LS_SETTINGS, {});
  const {active, states} = todayState();
  const map = {m:'#btnM', n:'#btnN', e:'#btnE'};
  for(const k of ['m','n','e']){
    const el = $(map[k]);
    const stateEl = el.querySelector('[data-state]');
    el.classList.remove('active','done','late');
    el.disabled = !settings.freq[k];
    stateEl.textContent = settings.freq[k] ? states[k] : '対象外';
    if(!settings.freq[k]) continue;
    if(states[k]==='完了') el.classList.add('done');
    else if(k===active) el.classList.add('active');
    else el.classList.add('late');
  }

  renderHistory();
  renderCity();
  updateTodaySummary();
}

function updateTodaySummary(){
  const s = load(LS_SETTINGS,{}); if(!s?.startDate) return;
  const {states} = todayState();
  const enabled = ['m','n','e'].filter(k=>s.freq[k]);
  const done = enabled.filter(k=>states[k]==='完了').length;
  $('#todaySummary').textContent = `${done}/${enabled.length} 完了`;
}

/* ========= Celebration ========= */
function miniCelebrate(count=14){
  const c = $('#celebration'); if(!c) return;
  c.innerHTML=''; c.style.display='block';
  for(let i=0;i<count;i++){
    const s=document.createElement('div'); s.className='confetti';
    s.textContent = ['✨','⭐','💫'][Math.floor(Math.random()*3)];
    s.style.left = (Math.random()*100)+'%'; s.style.top = '-5%';
    s.style.fontSize = (10 + Math.random()*14)+'px';
    s.style.animationDuration = (1.2 + Math.random()*1.2)+'s';
    c.appendChild(s);
  }
  setTimeout(()=>{c.style.display='none'}, 1800);
}

function celebrate(tier){
  const c = $('#celebration'); c.innerHTML=''; c.style.display='block';
  const count = tier>=4? 160 : tier>=3? 100 : tier>=2? 60 : 30;
  for(let i=0;i<count;i++){
    const s=document.createElement('div'); s.className='confetti'; s.textContent = ['✨','🎊','🎉','⭐','💫'][Math.floor(Math.random()*5)];
    s.style.left = (Math.random()*100)+'%'; s.style.top = '-5%'; s.style.fontSize = (12 + Math.random()*20)+'px';
    s.style.animationDuration = (2 + Math.random()*2.5)+'s';
    c.appendChild(s);
  }
  setTimeout(()=>{c.style.display='none'}, 3500);
}

function checkFinishCelebration(){
  const s = load(LS_SETTINGS,{}); if(!s?.endDate) return;
  const today = new Date(); const end = parseDate(s.endDate);
  const meta = load(LS_META,{celebed:false});
  if(today.toDateString() === end.toDateString() && !meta.celebed){
    const {rate} = calcStats(false);
    let tier=1; if(rate<60) tier=1; else if(rate<80) tier=2; else if(rate<95) tier=3; else if(rate<100) tier=4; else tier=5;
    celebrate(tier);
    meta.celebed = true; save(LS_META, meta);
  }
}

/* ========= History ========= */
function renderHistory(){
  const grid = $('#historyGrid'); if(!grid) return;
  grid.innerHTML = '';
  const s = load(LS_SETTINGS,{}); const log = load(LS_LOG,{});
  const enabled = ['m','n','e'].filter(k=>s.freq[k]);
  for(let i=6;i>=0;i--){
    const d = new Date(); d.setDate(d.getDate()-i); const key = todayStr(d);
    const rec = log[key] || {m:false,n:false,e:false};
    const col = document.createElement('div'); col.style.display='grid'; col.style.gridTemplateRows='repeat(3,1fr)'; col.style.gap='6px';
    const mk = (k)=>{
      const wrap = document.createElement('div'); wrap.className = 'dotWrap';
      const dot = document.createElement('div'); dot.className = 'dot ' + k; if(rec[k]) wrap.classList.add('done');
      if(k==='e'){ const t=document.createElement('div'); t.className='tail'; dot.appendChild(t); }
      wrap.appendChild(dot); return wrap;
    }
    if(enabled.includes('m')) col.appendChild(mk('m')); else col.appendChild(document.createElement('div'));
    if(enabled.includes('n')) col.appendChild(mk('n')); else col.appendChild(document.createElement('div'));
    if(enabled.includes('e')) col.appendChild(mk('e')); else col.appendChild(document.createElement('div'));
    grid.appendChild(col);
  }
}

/* ======== 保存型の街データ ======== */
const LS_CITY = 'MEDCITY_city_v1';
function loadCity(def){ try{ return JSON.parse(localStorage.getItem(LS_CITY)) ?? def }catch{ return def } }
function saveCity(v){ localStorage.setItem(LS_CITY, JSON.stringify(v)) }
function seededRand(seed){ let s = seed|0; return ()=>{ s ^= s<<13; s ^= s>>>17; s ^= s<<5; return (s>>>0)/4294967296; }; }
function seededRandN(seed, category, idx){
  let h = 2166136261>>>0;
  for (let i=0;i<category.length;i++){ h ^= category.charCodeAt(i); h = Math.imul(h, 16777619); }
  h ^= idx; h = Math.imul(h, 16777619);
  const r = seededRand((seed ^ h)>>>0);
  return r;
}
function defaultCityState(){
  return {
    dayKey: todayStr(),
    seed: Math.floor(Math.random()*1e9),
    gp: 0,
    counts: { buildings: 4, trees: 18, people: 6, animals: 2, ruins: 0, landmarks: 0 },
    chicken: {         // 🐔 ミニストーリー（光る演出）
      stage: null,     // null | 'egg' | 'chick' | 'hen'
      rare: false,     // カラフル卵→レアひよこ/ニワトリ
      twins: false,    // 双子卵
      pos: null,       // {left:%, bottom:%}
      hatched: 0
    },
    rareUnlocked: []   // レア建造物ID（🗽/🕌/🏟️/🏰/🗼）
  };
}
<!-- ========= ここから 2/3 ブロック目 ========= -->

/* ======== 期間正規化：全期間で最終形は同じに ======== */
function progressOverall(){ // 0..1（2時ロールオーバー対応）
  const s = load(LS_SETTINGS,{});
  if(!s?.startDate || !s?.endDate) return 0;
  const start = parseDate(s.startDate);
  const end   = parseDate(s.endDate);
  const today = new Date();
  const last  = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const totalDays = Math.max(1, Math.floor((end - start)/86400000) + 1);
  const elapsed   = Math.min(totalDays, Math.max(1, Math.floor((last - start)/86400000) + 1));
  return Math.min(1, Math.max(0, elapsed/totalDays));
}

/** その日の完了に応じて“保存型の街”を少しずつターゲットへ寄せる */
function syncCityToProgress(city){
  const p = progressOverall();            // 期間の進行（0..1）
  const { rate } = calcStats();           // コンプリート率（%）
  const health = cityHealth();            // 0..1（衰退/回復）

  // 最終ゴール（100%時）の賑わい設定
  const FINAL = { buildings: 24, trees: 60, people: 34, animals: 10, landmarks: 6 };

  // 期間の進み方に“手前ゆるやか→後半ぐんと”のカーブをかける
  const ease = t => t<0 ? 0 : t>1 ? 1 : (1 - Math.pow(1 - t, 2.2)); // easeOut-ish
  // コンプリート率を重みとして掛け（未達ならゆっくり）、健康度で微調整
  const reach = ease( p * (0.6 + 0.4 * (rate/100)) * (0.8 + 0.2*health) );

  // 現在のcountsを「reach * FINAL」に近づける（保存型：少しずつ吸い寄せ）
  const tgt = {
    buildings: Math.round(FINAL.buildings * reach),
    trees:     Math.round(FINAL.trees     * reach),
    people:    Math.round(FINAL.people    * reach),
    animals:   Math.round(FINAL.animals   * reach),
    landmarks: Math.round(FINAL.landmarks * (0.5*reach + 0.5*reach*reach)) // ランドマークは後半寄り
  };
  const step = (cur, goal, k=0.35)=> Math.round(cur + (goal - cur) * k); // 35%ずつ近づける
  city.counts.buildings = step(city.counts.buildings, tgt.buildings);
  city.counts.trees     = step(city.counts.trees,     tgt.trees);
  city.counts.people    = step(city.counts.people,    tgt.people);
  city.counts.animals   = step(city.counts.animals,   tgt.animals);
  city.counts.landmarks = step(city.counts.landmarks, tgt.landmarks);

  // 失敗時/低健康度で瓦礫少々、連続で回復なら瓦礫減少
  const ruinsGoal = Math.max(0, Math.round(6 * (1 - health)));
  city.counts.ruins = step(city.counts.ruins, ruinsGoal, 0.25);

  saveCity(city);
}

/** 日付キーが変わっていたら街データをロールさせる */
function ensureCityRolledToToday(){
  let city = loadCity() || defaultCityState();
  const todayKey = todayStr();
  if (city.dayKey !== todayKey){
    // 新しい日：シード少し進める
    city.seed = (city.seed|0) + 17;
    city.dayKey = todayKey;
    syncCityToProgress(city);
    saveCity(city);
    // ★ レア建造物・ニワトリ物語：夜のうち進む可能性
    if (Math.random() < 0.05) tryUnlockRareLandmark('rollover');
    if (Math.random() < 0.06) checkChickenStoryEvent('rollover');
  }
  return city;
}

/* ===== レア建造物：条件解放 & 保存 ===== */
const RARE_LANDMARKS = [
  { id:'liberty',    emoji:'🗽', minProgress:0.60, minRate:85, rarity:'R',  weight:0.20 },
  { id:'taj',        emoji:'🕌', minProgress:0.70, minRate:90, rarity:'SR', weight:0.12 },
  { id:'stadium',    emoji:'🏟️', minProgress:0.50, minRate:80, rarity:'R',  weight:0.25 },
  { id:'castle',     emoji:'🏰', minProgress:0.40, minRate:75, rarity:'R',  weight:0.30 },
  { id:'tokyotower', emoji:'🗼', minProgress:0.55, minRate:85, rarity:'SR', weight:0.15 },
];
function emojiOfRare(id){ const f=RARE_LANDMARKS.find(x=>x.id===id); return f?f.emoji:'🏛️'; }
function tryUnlockRareLandmark(reason='manual'){
  const city = loadCity() || defaultCityState();
  const unlocked = new Set(city.rareUnlocked || []);
  const p = progressOverall();
  const { rate } = calcStats();
  const cand = RARE_LANDMARKS.filter(x => !unlocked.has(x.id) && p>=x.minProgress && rate>=x.minRate);
  if(!cand.length) return false;
  const sum = cand.reduce((a,c)=>a+c.weight,0);
  let r = Math.random()*sum, pick=cand[0];
  for(const c of cand){ r -= c.weight; if(r<=0){ pick=c; break; } }
  city.rareUnlocked = [...unlocked, pick.id];
  saveCity(city);
  toast(`レア建造物を発見！ ${emojiOfRare(pick.id)} が解放された✨`);
  return true;
}

/* ===== 建物パレット & サイズ調整 ===== */
function cityTier(rate){
  if(rate>=95) return 6; if(rate>=90) return 5; if(rate>=75) return 4;
  if(rate>=60) return 3; if(rate>=40) return 2; if(rate>=20) return 1;
  return 0;
}
function buildingsForTier(t, health=1){
  const tbl=[
    ['🛖'],
    ['🏠','🏚️'],
    ['🏠','🏡','🏪'],
    ['🏢','🏫','🏬'],
    ['🏢','🏭','🏛️','🏥'],
    ['🗼','🏰','🏟️','🛕'],
    ['🏰','🗽','🕌','⛩️']
  ];
  const base = tbl[Math.min(t, tbl.length-1)].slice();
  // 低健康度で少し“荒れ”を混ぜる
  const decayExtras = ['🏚️','🚧','🧱'];
  const addK = Math.floor((1-health)*3);
  for(let i=0;i<addK;i++) base.push(decayExtras[Math.floor(Math.random()*decayExtras.length)]);
  return base;
}

// サイズ
const SMALL_BUILDINGS = new Set(['🏠','🏡','🏪']);
const MID_BUILDINGS   = new Set(['🏢','🏫','🏬','🏭','🏛️','🏥']);
const BIG_LANDMARKS   = new Set(['🗼','🏰','🏟️','🛕','🗽','🕌','⛩️']);
function buildingFontSizePx(emoji, tier, isForeground){
  let base;
  if (SMALL_BUILDINGS.has(emoji)) base = 18;
  else if (MID_BUILDINGS.has(emoji)) base = 20;
  else if (BIG_LANDMARKS.has(emoji)) base = 22;
  else base = 18;
  const tierScale = 1 + Math.min(0.55, (tier/6) * 0.55);
  const depthScale = isForeground ? 1.10 : 0.90;
  let size = base * tierScale * depthScale;
  const MIN = 14, MAX = 36;
  size = Math.max(MIN, Math.min(MAX, Math.round(size)));
  return size + 'px';
}

/* ===== 空＆季節のランダムイベント ===== */
function addSkyObj(emoji, cls, parent, style){ const el=document.createElement('div'); el.className=cls; el.textContent=emoji; Object.assign(el.style, style); parent.appendChild(el); }
function addLandObj(emoji, cls, parent, style){ const el=document.createElement('div'); el.className=cls; el.textContent=emoji; Object.assign(el.style, style); parent.appendChild(el); }

// 季節デコ
function addSeasonalDecor({ sky, land, rnd, isNight, micro, health, recoveryBoost }){
  const f = getSeasonalFlags();
  if(f.isHalloween){
    addLandObj('🎃','obj',land,{left:'10%',bottom:'24%'}); if(isNight && rnd()<0.4) addSkyObj('🦇','obj plane',sky,{top:'12%',left:'110%'});
  }
  if(f.isChristmas){
    addLandObj('🎄','obj',land,{left:'84%',bottom:'26%'}); if(isNight && rnd()<0.4) addSkyObj('🦌','obj bird',sky,{top:'14%',left:'-10%'}); 
  }
  if(f.isNewYear){
    addLandObj('🎍','obj',land,{left:'50%',bottom:'24%'}); if(rnd()<0.35) addLandObj('🎏','obj',land,{left:'18%',bottom:'28%'});
  }
  if(f.isNewFiscal){
    if(rnd()<0.6) addSkyObj('🌸','obj',sky,{top:(10+rnd()*15)+'%',left:(5+rnd()*80)+'%',animation:'fall 2.2s linear forwards'});
  }
}

// 空イベント抽選
function pickSkyEvents({health, recovery, season, isNight, rnd}){
  const events = [];
  // 稀に巨大UFO（1/200）
  if(rnd()<0.005) events.push('ufo_big');
  // 健康度低＆夜で流星群
  if(isNight && rnd() < 0.15*(health + 0.5*recovery)) events.push('meteor');
  // 鳥の群れ（昼）
  if(!isNight && rnd() < 0.18*(health + 0.5*recovery)) events.push('birds');
  // 飛行機
  if(!isNight && rnd() < 0.12*(health + 0.5*recovery)) events.push('plane');
  return events;
}
function spawnSkyEvent(id, {sky, land, rnd}){
  switch(id){
    case 'ufo_big':
      addSkyObj('🛸','obj plane', sky, {top:(8+rnd()*20)+'%', left:'110%', fontSize:'28px'});
      break;
    case 'meteor':
      addSkyObj('🌠','obj', sky, {top:(10+rnd()*20)+'%', left:'-10%', animation:'plane 8s linear infinite'});
      break;
    case 'birds':
      for(let i=0;i<6;i++) addSkyObj('🐦','obj bird', sky, {top:(8+rnd()*20)+'%', left:'-10%'});
      break;
    case 'plane':
      addSkyObj('✈️','obj plane', sky, {top:(10+rnd()*20)+'%', left:'110%'});
      break;
  }
}

/* ===== ミニイベント（完了時 1/3） & トースト ===== */
function toast(msg){
  const layer = $('#microLayer') || $('#sky');
  const t=document.createElement('div');
  t.className='obj';
  t.textContent=msg;
  Object.assign(t.style,{right:'12px',top:'12px',padding:'6px 10px',borderRadius:'10px',background:'#fff',border:'1px solid #e5e7eb',boxShadow:'0 4px 12px #0002',fontSize:'12px',position:'absolute',zIndex:'20'});
  layer.appendChild(t); setTimeout(()=>t.remove(), 3000);
}
function triggerMicroEvent(){
  const sky = $('#microLayer') || $('#sky');
  const land = $('#microLayer') || $('#land');
  const pick = ['mini_fireworks','balloon_rain','confetti_swirl','mini_parade','sunbreak','cleanup','tree_volunteer','road_fix','souvenir_drop','mini_rainbow','bird_flock','single_meteor','seasonal_petite'];
  const id = pick[Math.floor(Math.random()*pick.length)];
  runMicroEvent(id, sky, land);
}
function runMicroEvent(id, sky, land){
  switch(id){
    case 'mini_fireworks': miniCelebrate(20); toast('小花火があがった🎇'); break;
    case 'balloon_rain': for(let i=0;i<15;i++) addSkyObj('🎈','obj',sky,{top:'-6%',left:(5+Math.random()*90)+'%',animation:'fall 2.5s linear forwards'}); toast('風船が舞い降りた🎈'); break;
    case 'confetti_swirl': for(let i=0;i<20;i++){ const s=document.createElement('div'); s.className='confetti'; s.textContent=['✨','⭐','💫'][i%3]; s.style.left=(50+(Math.cos(i/3)*25))+'%'; s.style.top=(-5)+'%'; s.style.animationDuration=(1.6+Math.random()*0.8)+'s'; $('#celebration').appendChild(s);} $('#celebration').style.display='block'; setTimeout(()=>{$('#celebration').style.display='none';},1600); toast('紙吹雪くるくる✨'); break;
    case 'mini_parade': for(let i=0;i<6;i++) addLandObj(i%2?'🥁':'👯‍♀️','obj slow',land,{bottom:'24%',left:(110+i*6)+'%'}); toast('小さなパレード🥁'); break;
    case 'sunbreak': addSkyObj('☀️','obj',sky,{top:'6%',left:'8%'}); toast('雲間からひかり☀️'); break;
    case 'cleanup': { const city=loadCity()||defaultCityState(); city.counts.ruins=Math.max(0,city.counts.ruins-1); saveCity(city); renderCity(); toast('お掃除隊🧹'); break; }
    case 'tree_volunteer': { const city=loadCity()||defaultCityState(); city.counts.trees+=1; saveCity(city); renderCity(); toast('木を植えた🌱'); break; }
    case 'road_fix': addLandObj('🚧','obj',land,{bottom:'20%',left:'50%'}); setTimeout(()=>renderCity(), 4000); toast('道路補修🛠️'); break;
    case 'souvenir_drop': addLandObj('🧧','obj',land,{bottom:'26%',left:(10+Math.random()*80)+'%'}); toast('お土産を見つけた🧧'); break;
    case 'mini_rainbow': addSkyObj('🌈','obj',sky,{top:'10%',left:'12%'}); toast('小さな虹🌈'); break;
    case 'bird_flock': for(let i=0;i<8;i++) addSkyObj('🐦','obj bird',sky,{top:(8+Math.random()*20)+'%',left:'-10%'}); toast('渡り鳥の群れ🐦'); break;
    case 'single_meteor': addSkyObj('🌠','obj',sky,{top:'14%',left:'-10%',animation:'plane 8s linear infinite'}); toast('流れ星🌠'); break;
    case 'seasonal_petite': {
      const f=getSeasonalFlags();
      if(f.isHalloween) { addLandObj('🕯️','obj',land,{left:'20%',bottom:'26%'}); toast('ハロウィンの灯り🎃'); }
      else if(f.isChristmas){ addLandObj('🧑‍🎄','obj',land,{left:'78%',bottom:'28%'}); toast('サンタの影？🎄'); }
      else if(f.isNewYear){ addLandObj('🎍','obj',land,{left:'50%',bottom:'28%'}); toast('門松が置かれた🎍'); }
      else if(f.isNewFiscal){ addSkyObj('🌸','obj',sky,{top:'12%',left:'18%',animation:'fall 2.2s linear forwards'}); toast('花びらひらり🌸'); }
      break;
    }
  }
}

/* ===== ニワトリ物語（光るエフェクトつき） ===== */
function ensureChickenPos(city, FG_MIN=2, FG_MAX=14){
  if(!city.chicken.pos){
    const r = seededRand((city.seed||1) ^ 0xCE11);
    city.chicken.pos = { left: 8 + Math.floor(r()*84), bottom: FG_MIN + Math.floor(r()*(FG_MAX-FG_MIN)) };
  }
}
function storyChanceByPeriod(){
  const s = load(LS_SETTINGS,{});
  const start = s?.startDate? parseDate(s.startDate) : new Date();
  const end   = s?.endDate?   parseDate(s.endDate)   : new Date();
  const totalDays = Math.max(1, Math.floor((end - start)/86400000)+1);
  if(totalDays <= 14) return { egg2chick:0.5, chick2hen:0.4, lay:0.33 };
  if(totalDays <= 60) return { egg2chick:0.3, chick2hen:0.25, lay:0.25 };
  return                 { egg2chick:0.2, chick2hen:0.2,  lay:0.22 };
}
function checkChickenStoryEvent(trigger='complete'){
  const city = loadCity() || defaultCityState();
  const { rate } = calcStats();
  const p = progressOverall();
  const chances = storyChanceByPeriod();

  ensureChickenPos(city);

  if(!city.chicken.stage && p>=0.10 && rate>=75){
    if(Math.random() < 0.33){
      city.chicken.stage = 'egg';
      if(Math.random() < 0.05) city.chicken.twins = true;
      if(Math.random() < 0.05) city.chicken.rare  = true;
      toast('街の片隅に卵🥚が現れた！');
    }
  } else if(city.chicken.stage === 'egg'){
    if(Math.random() < chances.egg2chick){
      city.chicken.stage = 'chick';
      city.chicken.hatched += city.chicken.twins ? 2 : 1;
      toast(city.chicken.twins ? '双子のひよこ🐣🐣が誕生！' : 'ひよこ🐣が誕生！');
      if(Math.random() < 0.08) miniCelebrate(24);
    }
  } else if(city.chicken.stage === 'chick'){
    if(Math.random() < chances.chick2hen){
      city.chicken.stage = 'hen';
      toast(city.chicken.rare ? '特別なニワトリ🐓✨が育った！' : 'ニワトリ🐓に成長！');
      if(Math.random() < 0.1) triggerMicroEvent();
    }
  } else if(city.chicken.stage === 'hen'){
    if(Math.random() < chances.lay){
      toast('ニワトリが卵を産んだ🥚！');
      const sky = $('#microLayer') || $('#sky');
      addSkyObj('🥚','obj glow', sky, {top:'12%', left:(10+Math.random()*80)+'%'});
      setTimeout(()=>renderCity(), 2800);
    }
  }

  saveCity(city);
}
function renderChicken(city, land, tier){
  if(!city?.chicken?.stage) return;
  const pos = city.chicken.pos || {left:50,bottom:8};
  const cls = 'obj glow';
  const fontBase = { egg:18, chick:18, hen:22 }[city.chicken.stage] || 18;
  const size = Math.min(34, Math.round(fontBase * (1 + 0.1*tier/6)));
  const place = (emoji, dx=0, dy=0)=>{
    addLandObj(emoji, cls, land, {
      left: (pos.left + dx) + '%',
      bottom: (pos.bottom + dy) + '%',
      fontSize: size+'px', lineHeight:'1'
    });
  };
  if(city.chicken.stage === 'egg'){
    if(city.chicken.twins){
      place('🥚', -1.8, 0);
      place(city.chicken.rare ? '🌈🥚' : '🥚', 1.8, 0);
    } else {
      place(city.chicken.rare ? '🌈🥚' : '🥚', 0, 0);
    }
  } else if(city.chicken.stage === 'chick'){
    if(city.chicken.rare){
      place('🐤', 0, 0);
    }else if(city.chicken.twins){
      place('🐣', -1.6, 0); place('🐣', 1.6, 0);
    }else{
      place('🐣', 0, 0);
    }
  } else if(city.chicken.stage === 'hen'){
    place('🐓', 0, 0);
  }
}

/* ===== メイン：街の描画 ===== */
function renderCity(){
  const wrap = $('#cityWrap'); if(!wrap) return;
  const {rate, streak} = calcStats();
  const city = ensureCityRolledToToday();
  syncCityToProgress(city);

  const sky = $('#sky'), land = $('#land');
  sky.innerHTML=''; land.innerHTML=''; // microLayerはクリアしない

  // 時刻グラデーション
  const [t1,t2] = (()=>{
    const h=new Date().getHours();
    if(h>=2 && h<=10) return ['#bfe1ff','#e6f3ff'];   // 朝
    if(h>=11 && h<=16) return ['#9bd1ff','#d6ecff'];  // 昼
    if(h>=17 && h<=23) return ['#ffb38a','#c8cfff'];  // 夕
    return ['#0b1020','#0e1640'];                     // 深夜(〜1:59)
  })();
  wrap.style.background = `linear-gradient(180deg, ${t1} 0%, ${t2} 50%, #d5f0d2 50%, #c9e8c4 100%)`;

  // 健康度・回復
  const health = cityHealth();
  const meta = load(LS_META,{streak:0});
  const recoveryBoost = Math.min(0.25, (meta.streak||0) * 0.02);
  if(health < 0.55 && recoveryBoost < 0.1) wrap.classList.add('city-dim'); else wrap.classList.remove('city-dim');

  // 日替わりシード
  const rnd = makeRand((city.seed||1) + Math.floor(Date.now()/86400000));
  const isNight = (new Date().getHours()>=19 || new Date().getHours()<2);

  // 星/雲
  if(isNight){
    const stars = Math.round(12 + 48 * (0.4 + 0.6*health + 0.8*recoveryBoost));
    for(let i=0;i<stars;i++){
      const s=document.createElement('div'); s.className='obj twinkle'; s.textContent='✦';
      s.style.left = Math.floor(rnd()*100)+'%'; s.style.top = Math.floor(rnd()*48)+'%';
      s.style.opacity = (0.15 + 0.75*(health + recoveryBoost*0.8)).toFixed(2);
      s.style.fontSize = (10 + rnd()*16)+'px'; sky.appendChild(s);
    }
    if(rnd()<0.25*(health + recoveryBoost)) addSkyObj('🌠','obj', sky, {top:(10+rnd()*20)+'%', left:'-10%', animation:'plane 8s linear infinite'});
  }else{
    const clouds = 2 + Math.floor(3*(1.4 - 0.6*health - 0.7*recoveryBoost));
    for(let i=0;i<clouds;i++) addSkyObj('☁️','obj cloud', sky, {top:(5+rnd()*35)+'%', left:(-20 + rnd()*100)+'%'});
    if(rnd()<(0.35*(health + 0.8*recoveryBoost))) addSkyObj('🐦‍⬛','obj bird', sky, {top:(10+rnd()*20)+'%', left:'-10%'});
    if(rnd()<(0.22*(health + 0.8*recoveryBoost))) addSkyObj('✈️','obj plane', sky, {top:(10+rnd()*20)+'%', left:'110%'});
    if(health<0.45 && rnd()<0.12*(1 - recoveryBoost*1.2)) addSkyObj('🌧️','obj', sky, {top:'6%', left:(rnd()*90)+'%'});
    if(health<0.35 && rnd()<0.06*(1 - recoveryBoost*1.2)) addSkyObj('⚡','obj', sky, {top:'8%', left:(rnd()*90)+'%'});
  }

  // 季節 & ランダム空イベント
  const season = getSeasonalFlags();
  addSeasonalDecor({ sky, land, rnd, isNight, micro:progressOverall(), health, recoveryBoost });
  pickSkyEvents({health, recovery:recoveryBoost, season, isNight, rnd})
    .forEach(id => spawnSkyEvent(id, {sky, land, rnd}));

  // 道路（建物は置かない）
  const road = document.createElement('div');
  road.className='obj';
  Object.assign(road.style,{
    left:'-10%', bottom:'18%', width:'120%', height:'40px',
    background:'#9aa3b2', borderTop:'3px solid #cbd5e1', borderBottom:'3px solid #727b88'
  });
  land.appendChild(road);

  // 車（右→左）
  const carCount = Math.max(0, Math.round( (0.3 + 0.7*health + 0.6*recoveryBoost) * 3 ));
  for(let i=0;i<carCount;i++){
    addLandObj(['🚗','🚙','🚕','🛻','🚌'][Math.floor(rnd()*5)], 'obj car '+(rnd()<0.3?'fast':(rnd()<0.5?'slow':'')),
      land, {bottom:'22%', left:(120 + rnd()*50)+'%'});
  }

  // 前景/背景のボトム範囲（道路は18%）
  const ROAD_PCT = 18;
  const FG_MIN = 2, FG_MAX = ROAD_PCT-4;   // 前
  const BG_MIN = ROAD_PCT+10, BG_MAX = 48; // 奥

  // 安定配置用 RNG
  const rngTrees  = (i)=> seededRandN(city.seed, 'trees', i);
  const rngPeople = (i)=> seededRandN(city.seed, 'people', i);
  const rngAnimal = (i)=> seededRandN(city.seed, 'animals', i);
  const rngBuild  = (i)=> seededRandN(city.seed, 'buildings', i);
  const rngRuin   = (i)=> seededRandN(city.seed, 'ruins', i);
  const rngLmk    = (i)=> seededRandN(city.seed, 'landmarks', i);

  // Trees
  for(let i=0;i<city.counts.trees;i++){
    const r = rngTrees(i);
    const useForeground = r() < 0.35;
    const bottomPct = useForeground ? (FG_MIN + r()*(FG_MAX-FG_MIN)) : (BG_MIN + r()*(BG_MAX-BG_MIN));
    const leftPct = (2 + r()*96);
    const plant = (health<0.5 && r()<0.15 && recoveryBoost<0.08) ? '🥀' : (r()<0.7?'🌳':'🌲');
    addLandObj(plant,'obj',land,{left:leftPct+'%', bottom:bottomPct+'%'});
  }

  // People
  for(let i=0;i<city.counts.people;i++){
    const r = rngPeople(i);
    const bottomPct = (FG_MIN + r()*(FG_MAX-FG_MIN));
    const leftPct   = (2 + r()*96);
    const person = ['🧍','🧍‍♂️','🧍‍♀️','🚶','🕺','💃'][Math.floor(r()*6)];
    addLandObj(person,'obj',land,{left:leftPct+'%', bottom:bottomPct+'%'});
  }

  // Animals
  for(let i=0;i<city.counts.animals;i++){
    const r = rngAnimal(i);
    const bottomPct = (FG_MIN + r()*(FG_MAX-FG_MIN));
    const leftPct   = (2 + r()*96);
    const animal = r()<0.5 ? '🐕' : '🐈';
    addLandObj(animal,'obj',land,{left:leftPct+'%', bottom:bottomPct+'%'});
  }

  // Buildings
  const tier = cityTier(rate);
  const palette = buildingsForTier(tier, Math.min(1, health + recoveryBoost));
  for(let i=0;i<city.counts.buildings;i++){
    const r = rngBuild(i);
    const useForeground = r() < 0.35;
    const bottomPct = useForeground ? (FG_MIN + r()*(FG_MAX-FG_MIN)) : (BG_MIN + r()*(BG_MAX-BG_MIN));
    const leftPct   = (2 + r()*92);
    const b = palette[i % palette.length];
    addLandObj(b, 'obj', land, {
      left: leftPct+'%',
      bottom: bottomPct+'%',
      fontSize: buildingFontSizePx(b, tier, useForeground),
      lineHeight: '1'
    });
  }

  // Ruins
  for(let i=0;i<city.counts.ruins;i++){
    const r = rngRuin(i);
    const bottomPct = (FG_MIN + r()*(FG_MAX-FG_MIN));
    const leftPct   = (2 + r()*92);
    addLandObj('🏚️', 'obj', land, {left:leftPct+'%', bottom:bottomPct+'%'});
  }

  // Landmarks（通常）
  for(let i=0;i<city.counts.landmarks;i++){
    const r = rngLmk(i);
    const bottomPct = (BG_MIN + r()*(BG_MAX-BG_MIN));
    const leftPct   = (5 + r()*90);
    const lm = ['🎡','⛲','🗼','🏟️'][Math.floor(r()*4)];
    addLandObj(lm, 'obj', land, {
      left:leftPct+'%',
      bottom:bottomPct+'%',
      fontSize: buildingFontSizePx(lm, Math.max(tier, 4), false),
      lineHeight: '1'
    });
  }

  // ★ レア建造物（解放済み）表示（最大3）
  const rare = (loadCity()||defaultCityState()).rareUnlocked || [];
  const showNum = Math.min(3, rare.length);
  for(let i=0;i<showNum;i++){
    const id = rare[i];
    const r = rngLmk(1000+i);
    const bottomPct = (BG_MIN + r()*(BG_MAX-BG_MIN));
    const leftPct   = (8 + r()*84);
    const em = emojiOfRare(id);
    addLandObj(em, 'obj', land, {
      left:leftPct+'%',
      bottom:bottomPct+'%',
      fontSize: buildingFontSizePx(em, Math.max(tier,5), false),
      lineHeight:'1'
    });
  }

  // ニワトリ物語（光る）
  renderChicken(city, land, Math.max(tier, 3));

  // 賑わい小物
  if(rnd() < 0.12*(health + 0.8*recoveryBoost)) addLandObj('🎈','obj', land, {left:(2 + rnd()*92)+'%', bottom:(30 + rnd()*14)+'%'});
  if(rnd() < 0.10*(health + 0.8*recoveryBoost)) addLandObj('🛝','obj', land, {left:(5 + rnd()*20)+'%', bottom:(BG_MIN + 6)+'%'});
}

/* ========= ここまで 2/3 ブロック目 ========= */
<!-- ========= ここから 3/3 ブロック目 ========= -->

/* ========= Tabs ========= */
$$('.tab button').forEach(btn=>btn.addEventListener('click', ()=>{
  $$('.tab button').forEach(b=>b.classList.remove('active')); btn.classList.add('active');
  const t = btn.dataset.tab; $$('.view').forEach(v=>v.style.display='none'); $('#'+t).style.display='block';
  if(t==='home') renderCity();
}));

/* ========= Settings ========= */
function loadSettingsUI(){
  const s=load(LS_SETTINGS,{});
  $('#startDate').value = s.startDate || todayStr();
  $('#endDate').value = s.endDate || todayStr(new Date(Date.now()+86400000*27));
  $('#freqM').checked = !!s.freq?.m; $('#freqN').checked=!!s.freq?.n; $('#freqE').checked=!!s.freq?.e;
}
$('#saveSettings').addEventListener('click', ()=>{
  const s={ startDate: $('#startDate').value, endDate: $('#endDate').value, freq:{ m:$('#freqM').checked, n:$('#freqN').checked, e:$('#freqE').checked } };
  save(LS_SETTINGS, s); $('#saveMsg').textContent='保存しました'; setTimeout(()=>$('#saveMsg').textContent='',1500);
  recomputeStreak(); renderAll();
});

// リセット（設定と記録を初期化：起点=今日、終点=1週間後、freqクリア＋街も初期化）
$('#resetAll').addEventListener('click', ()=>{
  if(!confirm('設定と記録を初期化し、起点を今日・終点を1週間後に仮設定します。よろしいですか？')) return;
  const newSettings = {
    startDate: todayStr(),
    endDate: todayStr(new Date(Date.now()+86400000*7)),
    freq: {m:false,n:false,e:false}
  };
  save(LS_SETTINGS, newSettings);
  save(LS_LOG, {});
  save(LS_META, {streak:0,bestStreak:0,seed:Math.floor(Math.random()*1e9)});
  saveCity(defaultCityState());

  // 設定タブへ
  $$('.tab button').forEach(b=>b.classList.remove('active'));
  const btnSettings = [...$$('.tab button')].find(b=>b.dataset.tab==='settings');
  if(btnSettings){ btnSettings.classList.add('active'); }
  $$('.view').forEach(v=>v.style.display='none'); $('#settings').style.display='block';
  loadSettingsUI(); recomputeStreak(); renderAll();
  $('#saveMsg').textContent='初期化しました。頻度を選んで再スタート！';
  setTimeout(()=>$('#saveMsg').textContent='', 3000);
});

/* ========= Button interactions ========= */
['#btnM','#btnN','#btnE'].forEach(sel=>{
  const el=$(sel); const slot=el.dataset.slot;
  el.addEventListener('click', ()=>{ const s=load(LS_SETTINGS,{}); if(!s.freq[slot]) return; toggleDone(slot); });
  let t=null; el.addEventListener('touchstart',()=>{t=setTimeout(()=>toggleDone(slot),600)});
  el.addEventListener('touchend',()=>{ if(t){clearTimeout(t); t=null;} });
});

/* ========= Log ops ========= */
function toggleDone(slot){
  const s = load(LS_SETTINGS,{}); if(!s?.startDate) return;
  const log = load(LS_LOG,{}); const d = todayStr();
  if(!log[d]) log[d] = {m:false,n:false,e:false,ts:{}};

  const before = !!log[d][slot];
  log[d][slot] = !before;
  log[d].ts[slot] = log[d][slot] ? Date.now() : null;
  save(LS_LOG, log);

  if(!before && log[d][slot]){
    // 服薬成功時の演出
    const meta = load(LS_META,{seed:1,streak:0,bestStreak:0});
    meta.seed = (meta.seed||1) + 3;
    save(LS_META, meta);

    miniCelebrate(12);

    // 保存型の街をターゲットへ少し寄せる
    const city = loadCity() || defaultCityState();
    syncCityToProgress(city);

    // ミニイベントは renderAll() の後フレームで発火（消されない）
    const fire = window.__microEventForce || (Math.random() < 1/3);
    if (fire) requestAnimationFrame(()=> triggerMicroEvent());

    // レア建造物の解放抽選（25%）
    if (Math.random() < 0.25) tryUnlockRareLandmark('complete');

    // 🐔 ニワトリ物語：完了時にランダム進行
    checkChickenStoryEvent('complete');
  }

  recomputeStreak();
  renderAll();
  maybeNightCombo();
  checkFinishCelebration();
}

function recomputeStreak(){
  const s = load(LS_SETTINGS,{}); if(!s?.startDate) return;
  const enabled = ['m','n','e'].filter(k=>s.freq[k]);
  const log = load(LS_LOG,{});
  let streak=0; const now = new Date();
  for(let i=0;i<3650;i++){
    const d = new Date(now.getFullYear(),now.getMonth(),now.getDate()-i);
    const key = todayStr(d);
    const rec = log[key];
    const ok = rec && enabled.every(k=>rec[k]);
    if(ok) streak++; else break;
  }
  const meta = load(LS_META,{streak:0,bestStreak:0});
  meta.streak = streak; meta.bestStreak = Math.max(meta.bestStreak||0, streak);
  save(LS_META, meta);
}

function maybeNightCombo(){
  const s = load(LS_SETTINGS,{}); const log=load(LS_LOG,{}); const t=todayStr();
  const enabled = ['m','n','e'].filter(k=>s.freq[k]);
  const rec = log[t];
  if(rec && enabled.length>0 && enabled.every(k=>rec[k])){
    const meta = load(LS_META,{}); meta.seed = (meta.seed||1) + 7; save(LS_META, meta);
  }
}

/* ========= Init ========= */
ensureDefaults();
loadSettingsUI();
recomputeStreak();
renderAll();
checkFinishCelebration();

// 20秒ごとに軽く更新（ホーム表示時）
setInterval(()=>{
  const homeShown = $('#home') && $('#home').style.display !== 'none';
  if(homeShown) renderCity();
}, 20*1000);

/* ===== 2:00 ロールオーバー検知 ===== */
function getDayKey(){ return todayStr(); }
function refreshIfDayChanged(){
  const nowKey = getDayKey();
  if (window.__currentDayKey !== nowKey){
    window.__currentDayKey = nowKey;
    ensureCityRolledToToday(); // ★ 日付が変わったら街も進める
    recomputeStreak();
    renderAll();
  }
}
function scheduleNextRolloverTick(hour=2){
  const now = new Date();
  const target = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, 0, 1, 0); // +1秒
  if (now >= target) target.setDate(target.getDate()+1);
  const ms = target - now;
  clearTimeout(window.__rolloverTimer);
  window.__rolloverTimer = setTimeout(()=>{
    refreshIfDayChanged();
    scheduleNextRolloverTick(hour);
  }, ms);
}
window.__currentDayKey = getDayKey();
document.addEventListener('visibilitychange', ()=> { if (document.visibilityState === 'visible'){ refreshIfDayChanged(); }});
window.addEventListener('focus', refreshIfDayChanged);
window.addEventListener('pageshow', refreshIfDayChanged);
window.addEventListener('orientationchange', refreshIfDayChanged);
scheduleNextRolloverTick(2);

// iOSスタンドアロン時は1分ハートビート
const isIOSStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
if (isIOSStandalone){
  setInterval(()=> { if (document.visibilityState==='visible') refreshIfDayChanged(); }, 60*1000);
}

</script>
</body>
</html>
<!-- ========= ここまで 3/3 ブロック目 ========= -->
