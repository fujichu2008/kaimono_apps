<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Neon Air Hockey</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg-top:#06080f; --bg-bot:#0b1222; --grid:#10233f; --line:#13d2ff;
    --you:#00d1ff; --ai:#7a5cff; --puck:#24e4ff; --warn:#ff3b5c; --ok:#00ffbf;
    --glass: rgba(255,255,255,0.06); --glass-2: rgba(19,210,255,0.08);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
  html,body{height:100%; margin:0}
  body{background:linear-gradient(180deg,var(--bg-top),var(--bg-bot)); color:#eaf6ff; font-family: system-ui, -apple-system, 'Hiragino Sans', 'Noto Sans JP', sans-serif;}
  .wrap{max-width:980px; margin:0 auto; height:100%; display:flex; flex-direction:column;}
  header{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:10px 12px;}
  .brand{display:flex; align-items:center; gap:10px; font-family:'Orbitron',sans-serif; letter-spacing:1px}
  .brand .logo{width:26px; height:26px; border-radius:50%; background:conic-gradient(from 0deg at 50% 50%, #07f 0 25%, #0ff 25% 50%, #70f 50% 75%, #0fb 75% 100%); box-shadow:0 0 18px #0ff8}
  .brand span{opacity:.9}

  .hud{display:flex; gap:12px; align-items:center; font-family:'Orbitron',sans-serif;}
  .pill{padding:6px 10px; border-radius:999px; background:var(--glass); border:1px solid #ffffff18; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);}
  .score{font-size:20px; letter-spacing:1px}
  .score .you{color:var(--you)}
  .score .ai{color:var(--ai)}
  .timer{font-weight:700}

  main{flex:1; display:flex; align-items:center; justify-content:center; padding:10px;}
  .arena-wrap{position:relative; width:100%; aspect-ratio: 3/4; max-height: calc(100svh - 120px);}/* 3:4 for iPad portrait */
  canvas{width:100%; height:100%; display:block; border-radius:20px; background:
    radial-gradient(120% 100% at 50% 0%, #0c1631 0%, #0b1222 55%, #06080f 100%),
    repeating-linear-gradient(180deg, transparent 0 24px, var(--glass-2) 24px 25px);
    box-shadow: 0 10px 40px #0008, inset 0 0 0 1px #ffffff10, inset 0 0 80px #0ff08;
  }

  /* overlay menus */
  .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center;}
  .panel{width:min(560px,92%); padding:18px; border-radius:16px; background:linear-gradient(180deg,#0b1326,#081020); border:1px solid #ffffff22; box-shadow:0 12px 36px #000a;}
  .panel h1,.panel h2{margin:0 0 12px; font-family:'Orbitron',sans-serif;}
  .selects{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin:10px 0 14px}
  .btn{cursor:pointer; user-select:none; text-align:center; padding:12px 14px; border-radius:12px; border:1px solid #ffffff20; background:linear-gradient(180deg,#0e213f,#0a1a31); color:#dff7ff; box-shadow: inset 0 0 0 1px #13d2ff20, 0 0 24px #13d2ff22; transition: transform .05s ease}
  .btn:active{transform: translateY(1px)}
  .btn.primary{background:linear-gradient(180deg,#0af,#09f); border-color:#13d2ff88; box-shadow: 0 0 40px #13d2ff55, inset 0 0 0 1px #fff5}
  .seg{display:flex; gap:8px;}
  .seg .btn{flex:1}
  .row{display:flex; gap:10px; align-items:center; justify-content:space-between}
  .ghost{opacity:.7}

  .toast{position:absolute; left:50%; transform:translateX(-50%); bottom:14px; padding:8px 12px; border-radius:999px; background:var(--glass); border:1px solid #ffffff18; font-family:'Orbitron',sans-serif; opacity:0; transition: opacity .3s ease}
  .toast.show{opacity:1}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand"><div class="logo"></div><span>NEON AIR HOCKEY</span></div>
    <div class="hud">
      <div class="pill score" id="score"><span class="you">YOU 0</span> ‚Äî <span class="ai"><span id="aiLabel">ü§ñ AI</span> 0</span></div>
      <div class="pill timer" id="timer">01:00</div>
    </div>
  </header>
  <main>
    <div class="arena-wrap">
      <canvas id="arena" aria-label="air-hockey arena" role="img"></canvas>

      <!-- Start Overlay -->
      <div class="overlay" id="startOverlay">
        <div class="panel">
          <h1>NEON AIR HOCKEY</h1>
          <div class="selects">
            <div class="btn" data-mode="1P">1 PLAYER<br><span class="ghost">vs ü§ñ</span></div>
            <div class="btn" data-mode="2P">2 PLAYERS<br><span class="ghost">ÂØæÈù¢</span></div>
          </div>
          <div class="row">
            <h2 style="margin:0">AIÈõ£ÊòìÂ∫¶</h2>
            <div class="seg" id="diffSeg">
              <div class="btn" data-diff="0">EASY</div>
              <div class="btn" data-diff="1">NORMAL</div>
              <div class="btn" data-diff="2">HARD</div>
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <div class="btn primary" id="btnStart">START</div>
          </div>
        </div>
      </div>

      <!-- Result Overlay -->
      <div class="overlay" id="resultOverlay" style="display:none">
        <div class="panel" id="resultPanel">
          <h1>RESULT</h1>
          <p id="resultText" style="margin:6px 0 14px; font-family:'Orbitron',sans-serif"></p>
          <div class="seg">
            <div class="btn" id="btnRetry">RETRY</div>
            <div class="btn" id="btnMenu">MENU</div>
          </div>
        </div>
      </div>

      <div class="toast" id="toast">TOAST</div>
    </div>
  </main>
</div>

<script>
// --------------------------------------------------------
// HiDPI Canvas setup
// --------------------------------------------------------
const canvas = document.getElementById('arena');
const ctx = canvas.getContext('2d');
const DPR = Math.max(1, window.devicePixelRatio || 1);
let W=0,H=0,MID=0;

// --- Initialize AI brain early ---
const aiBrain = { tx: 0, ty: 0, react: 0, homeX: 0, homeY: 0 };

function resize(){
  const rect = canvas.getBoundingClientRect();
  W = Math.floor(rect.width * DPR);
  H = Math.floor(rect.height * DPR);
  canvas.width = W; canvas.height = H;
  MID = H/2;
}
addEventListener('resize', resize, {passive:true});
resize();

// --------------------------------------------------------
// Game State
// --------------------------------------------------------
const state = {
  running:false,
  mode:'1P',     // '1P' or '2P'
  diff:1,        // 0 easy,1 normal,2 hard
  time:60,       // seconds
  you:0,
  ai:0,
  lastTs:0,
  penaltyCooldown:0,
  flash:0,
};

// --------------------------------------------------------
// Entities
// --------------------------------------------------------
class Paddle{ 
  constructor(x,y,color,side){ 
    this.x=x; this.y=y; this.vx=0; this.vy=0; this.color=color; this.side=side; this.active=false; this.touchId=null; 
    // bar (capsule) paddle parameters
    this.shape='bar';
    this.barHalf = 56*DPR;   // half length of the bar
    this.barRad  = 22*DPR;   // round cap radius / thickness
    this.r = 38*DPR;         // legacy radius used for clamping & tests (keep similar size)
  }
  clampToSide(){ 
    if(this.side==='you') this.y=Math.max(MID+this.r, Math.min(H-this.r, this.y)); 
    else this.y=Math.min(MID-this.r, Math.max(this.r, this.y));
    this.x=Math.max(this.r, Math.min(W-this.r, this.x)); 
  }
}
class Puck{ constructor(){ this.reset(); }
  reset(){ this.x=W/2; this.y=H/2; const ang=(Math.random()*Math.PI*2); const sp= (DPR* (9 + Math.random()*3)); this.vx=Math.cos(ang)*sp; this.vy=Math.sin(ang)*sp; this.r=20*DPR; }
}

const you = new Paddle(W/2, H*0.82, '#00d1ff','you');
const ai  = new Paddle(W/2, H*0.18, '#7a5cff','ai');
const puck = new Puck();

// compute homeY after entities exist
function computeHomeY(){ aiBrain.homeY = Math.max(ai.r, (20*DPR) + puck.r); }
computeHomeY();
addEventListener('resize', computeHomeY, {passive:true});

function startServe(side){
  // side: 'AI' or 'YOU'
  puck.x = W/2; puck.y = H/2; puck.vx = (Math.random()*160-80)*DPR; const sp = 260*DPR; puck.vy = (side==='AI' ? -sp : sp);
  // boost AI first touch based on difficulty when serving to AI
  aiServeBoost = (side==='AI') ? [1.18,1.28,1.38][state.diff] : 0;
}

// --- Physics tuning & AI vars ---
const PHYS = { air: 0.9985, wallRest: 0.92, wallFric: 0.985, minSp: 400*DPR, maxSp: 2200*DPR };
let aiServeBoost = 0, aiCounterBias = 0, aiCounterSide = 0;

// --------------------------------------------------------
// Audio (WebAudio simple synth)
// --------------------------------------------------------
let actx, master;
function initAudio(){
  if(actx) return; try{ actx = new (window.AudioContext||window.webkitAudioContext)(); master=actx.createGain(); master.gain.value=0.25; master.connect(actx.destination);}catch(e){}
}
function beep(freq=440, dur=0.07, type='sine', gain=0.2){ if(!actx) return; const o=actx.createOscillator(); const g=actx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(master); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime+dur); o.stop(actx.currentTime+dur); }
function noise(dur=0.06, gain=0.2){ if(!actx) return; const buf=actx.createBuffer(1, actx.sampleRate*dur, actx.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<data.length;i++) data[i]= (Math.random()*2-1)*0.7; const src=actx.createBufferSource(); const g=actx.createGain(); g.gain.value=gain; src.buffer=buf; src.connect(g); g.connect(master); src.start(); g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime+dur); }
// lightweight BGM loop
let bgmInt=null; function startBGM(){ if(!actx) return; stopBGM(); const tempo= (state.mode==='1P'? 108:112); const beat=60/tempo; let step=0; bgmInt=setInterval(()=>{ // kick + hat + arp
  if(step%4===0){ noise(0.045,0.22);} // kick-ish
  if(step%2===0){ beep(880,0.03,'square',0.08);} // hat-ish
  // arpeggio bright
  const seq=[659,740,880,740,659,587,523,587];
  const f=seq[step%seq.length]; beep(f,0.08,'triangle',0.08);
  step++; }, beat*1000);
}
function stopBGM(){ if(bgmInt){ clearInterval(bgmInt); bgmInt=null; } }

function s_hit(){ beep(1200,0.06,'square',0.25); }
function s_goal(){ for(let i=0;i<5;i++) setTimeout(()=>beep(500+ i*200,0.08,'sawtooth',0.22), i*40); noise(0.12,0.25); }
function s_pen(){ beep(220,0.1,'sawtooth',0.3); }

// --------------------------------------------------------
// Input (Multi-touch paddles + Finger Flick)
// --------------------------------------------------------
let flickCooldown = 0; // seconds cooldown between flicks
const flick = { prox: ()=>70*DPR, minDist: ()=>12*DPR, maxDur: 0.22, minSpeed: ()=>480*DPR, gain: 0.65 };
const touches = new Map(); // id -> {sx,sy,st,lx,ly,lt,near}

function isYouSide(py){ return py >= MID; }
function nearPuck(x,y){ const dx=x-puck.x, dy=y-puck.y; return Math.hypot(dx,dy) <= flick.prox(); }
// moving fast handle: expand proximity based on paddle speed and time step to prevent tunneling
function movingNearPuck(p, dt){
  const base = flick.prox();
  const padSpeed = Math.hypot(p.vx, p.vy);
  const extra = Math.min(140*DPR, padSpeed * dt * 0.9);
  const dx = p.x - puck.x, dy = p.y - puck.y;
  return Math.hypot(dx,dy) <= base + extra;
}

function tryFlick(sx,sy,ex,ey,dt){
  // Generic flick for either half; puck must be mostly on the same half as the finger start
  if(flickCooldown>0) return false;
  const onYouSide = isYouSide(sy);
  if(onYouSide){
    if(puck.y < MID + puck.r*0.2) return false;
  } else {
    if(puck.y > MID - puck.r*0.2) return false;
  }
  const dx = ex-sx, dy = ey-sy; const dist = Math.hypot(dx,dy); if(dist < flick.minDist()) return false;
  if(dt<=0 || dt>flick.maxDur) return false; const speed = dist/dt; if(speed < flick.minSpeed()) return false;
  // direction & impulse
  const nx = dx/dist, ny = dy/dist; const imp = Math.min(1800*DPR, speed * flick.gain);
  puck.vx += nx * imp; puck.vy += ny * imp; clampPuckSpeed(); s_hit(); state.flash = 0.18; flickCooldown = 0.12; return true;
}

function onTouchStart(ev){ initAudio(); if(actx?.state==='suspended') actx.resume();
  for(const t of ev.changedTouches){ const rect=canvas.getBoundingClientRect(); const x=(t.clientX-rect.left)*DPR; const y=(t.clientY-rect.top)*DPR; const st=performance.now()/1000;
    touches.set(t.identifier,{sx:x,sy:y,st,lx:x,ly:y,lt:st,near:nearPuck(x,y)});
    if(state.mode==='1P'){
      if(isYouSide(y)){ you.active=true; you.touchId=t.identifier; you.x=x; you.y=y; }
    } else { // 2P
      if(isYouSide(y)){ you.active=true; you.touchId=t.identifier; you.x=x; you.y=y; }
      else{ ai.active=true; ai.touchId=t.identifier; ai.x=x; ai.y=y; }
    }
  }
  ev.preventDefault(); }

function onTouchMove(ev){ for(const t of ev.changedTouches){ const rect=canvas.getBoundingClientRect(); const x=(t.clientX-rect.left)*DPR; const y=(t.clientY-rect.top)*DPR; const lt=performance.now()/1000; const tr=touches.get(t.identifier); if(tr){ tr.lx=x; tr.ly=y; tr.lt=lt; }
   if(t.identifier===you.touchId){ you.vx = x-you.x; you.vy = y-you.y; you.x=x; you.y=y; you.clampToSide(); }
   if(state.mode==='2P' && t.identifier===ai.touchId){ ai.vx = x-ai.x; ai.vy = y-ai.y; ai.x=x; ai.y=y; ai.clampToSide(); }
 }
 ev.preventDefault(); }

function onTouchEnd(ev){ for(const t of ev.changedTouches){ const tr=touches.get(t.identifier); if(tr){ const dt=Math.max(0.0001, (tr.lt - tr.st)); if(tr.near){ tryFlick(tr.sx,tr.sy,tr.lx,tr.ly,dt); } touches.delete(t.identifier); }
   if(t.identifier===you.touchId){ you.active=false; you.touchId=null; }
   if(t.identifier===ai.touchId){ ai.active=false; ai.touchId=null; }
 }
 ev.preventDefault(); }

canvas.addEventListener('touchstart', onTouchStart, {passive:false});
canvas.addEventListener('touchmove', onTouchMove, {passive:false});
canvas.addEventListener('touchend', onTouchEnd, {passive:false});
canvas.addEventListener('touchcancel', onTouchEnd, {passive:false});

// --------------------------------------------------------
// Human-like AI (front-intercept + goal-line defense)
// --------------------------------------------------------
function aiUpdate(dt){
  if(state.mode!=='1P') return;
  // Anticipatory AI with wide-arc intercept and difficulty-scaled precision
  const ACCEL   = [1800,2600,3600].map(v=>v*DPR);
  const MAXSP   = [1300,1900,2600].map(v=>v*DPR);
  const REACT   = [0.080,0.045,0.020];
  const ERR     = [28,14,6].map(v=>v*DPR);
  const PREDICT = [0.85,1.00,1.20];
  const MISS    = [0.18,0.08,0.02];
  const FRONT   = [30,44,62].map(v=>v*DPR);
  const LATERAL = [32,44,64].map(v=>v*DPR); // slightly larger for wider arc
  const DASHB   = [1.20,1.40,1.70];
  const COUNTER = [260,340,440].map(v=>v*DPR);
  const SIDEK   = [110,150,210].map(v=>v*DPR);

  let accel = ACCEL[state.diff];
  let maxSpeed = MAXSP[state.diff];
  const reactBase = REACT[state.diff];
  const err = ERR[state.diff];

  const incoming   = puck.vy < 0;
  const veryFast   = puck.vy < -560*DPR;
  const nearGoal   = puck.y < (puck.r + 90*DPR); // enlarge goal danger zone
  const onAiHalf   = puck.y < MID*0.98;
  const distToPuck = Math.hypot(puck.x-ai.x, puck.y-ai.y);

  let targetX = ai.x, targetY = ai.y;
  aiCounterBias = 0; aiCounterSide = 0;

  // Helper: force a side-approach offset away from goal mouth
  function sideApproach(px,py,pv,vfx,vfy){
    const ux=-vfy, uy=vfx;
    const sideSign = (px < W/2 ? -1 : 1);
    const frontMag = FRONT[state.diff] + Math.min(90*DPR, pv*0.05);
    let latMag   = LATERAL[state.diff] + Math.min(110*DPR, pv*0.05);
    // widen even more when close to goal line to avoid own-goals
    const goalTight = Math.max(0, (puck.r + 120*DPR) - py) / (120*DPR);
    latMag *= (1.0 + goalTight*1.2);
    let tx = px - vfx*frontMag + ux*latMag*sideSign;
    let ty = py - vfy*frontMag + uy*latMag*sideSign;
    // keep away from goal line by safety margin
    const safeY = Math.max(ai.r + 18*DPR, puck.r + ai.r + 28*DPR);
    ty = Math.max(safeY, ty);
    tx = Math.max(ai.r, Math.min(W-ai.r, tx));
    ty = Math.max(ai.r, Math.min(MID - ai.r*1.02, ty));
    return [tx,ty];
  }

  if(nearGoal && (incoming || onAiHalf)){
    // Goal-line: do not sit on the line; approach from the side and slightly forward
    const pv = Math.hypot(puck.vx, puck.vy) || 1;
    const vfx = puck.vx/pv, vfy = puck.vy/pv;
    const dash = (veryFast || distToPuck>220*DPR) ? DASHB[state.diff] : 1.0;
    maxSpeed *= dash; accel *= dash;
    const px=puck.x, py=Math.max(puck.y, puck.r + ai.r + 36*DPR);
    [targetX,targetY] = sideApproach(px,py,pv,vfx,vfy);
    aiCounterBias = COUNTER[state.diff];
    aiCounterSide = SIDEK[state.diff] * (px < W/2 ? -1 : 1);
  } else if(incoming || onAiHalf){
    // Predict and meet on a wide arc
    const pv = Math.hypot(puck.vx, puck.vy) || 1;
    const vfx = puck.vx/pv, vfy = puck.vy/pv;
    const dash = (veryFast || distToPuck>280*DPR) ? DASHB[state.diff] : 1.0;
    maxSpeed *= dash; accel *= dash;
    const relSp = Math.max(1, pv + maxSpeed*0.65);
    const tBase = distToPuck / relSp;
    const t = Math.max(0.06, Math.min(0.9, tBase * PREDICT[state.diff]));
    const px = puck.x + puck.vx*t;
    const py = puck.y + puck.vy*t;
    [targetX,targetY] = sideApproach(px,py,pv,vfx,vfy);
  } else {
    // Idle patrol
    const goalY = Math.max(ai.r + 20*DPR, aiBrain.homeY || (puck.r + 80*DPR));
    targetX = Math.max(ai.r, Math.min(W-ai.r, (W/2) + Math.sin(performance.now()/520)*60*DPR));
    targetY = Math.max(ai.r, Math.min(MID - ai.r*1.25, goalY + Math.cos(performance.now()/740)*24*DPR));
  }

  // Reaction & precision
  if(aiBrain.react>0){ aiBrain.react -= dt; }
  else {
    let jx = (Math.random()-0.5)*err;
    let jy = (Math.random()-0.5)*err;
    if(Math.random() < MISS[state.diff]){ jx *= 1.4; jy *= 1.4; }
    aiBrain.tx = targetX + jx; aiBrain.ty = targetY + jy;
    aiBrain.react = reactBase + Math.random()*reactBase*0.35;
  }

  const tx = Math.max(ai.r, Math.min(W-ai.r, aiBrain.tx));
  const ty = Math.max(ai.r, Math.min(MID - ai.r*1.02, aiBrain.ty));

  const ddx = tx - ai.x, ddy = ty - ai.y; const d = Math.hypot(ddx,ddy);
  if(d>1){
    const desiredVx = ddx/d * maxSpeed;
    const desiredVy = ddy/d * maxSpeed;
    ai.vx += Math.max(-accel*dt, Math.min(accel*dt, desiredVx - ai.vx));
    ai.vy += Math.max(-accel*dt, Math.min(accel*dt, desiredVy - ai.vy));
    ai.x += ai.vx*dt; ai.y += ai.vy*dt; ai.vx *= 0.90; ai.vy *= 0.90; ai.clampToSide();
  }
}

// --------------------------------------------------------
// Physics
// --------------------------------------------------------
function collidePaddle(p){
  // helper: apply collision response with current normal nx,ny
  function resolveWithNormal(nx, ny, p){
    // relative velocity
    let rvx = puck.vx - p.vx; let rvy = puck.vy - p.vy;
    const vn = rvx*nx + rvy*ny;
    const tx = -ny, ty = nx; let vt = rvx*tx + rvy*ty;
    let e = 1.05; if(p===ai && aiServeBoost>0){ e *= aiServeBoost; aiServeBoost = 0; }
    if(p===ai && aiCounterBias>0){ puck.vy += aiCounterBias; puck.vx += aiCounterSide; aiCounterBias = 0; aiCounterSide = 0; }
    const mu = 0.90; const spin = (p.vx*tx + p.vy*ty)*0.35;
    const vn2 = -vn * e; const vt2 = vt * mu + spin;
    rvx = vn2*nx + vt2*tx; rvy = vn2*ny + vt2*ty;
    puck.vx = rvx + p.vx; puck.vy = rvy + p.vy;
    // Difficulty-scaled return speed (softer on Easy/Normal)
    const sp = Math.hypot(puck.vx, puck.vy) || 1;
    const scale = [0.72,0.88,1.0][state.diff];
    const target = Math.max(PHYS.minSp*0.9, Math.min(PHYS.maxSp, sp*scale));
    puck.vx = puck.vx / sp * target; puck.vy = puck.vy / sp * target;
    clampPuckSpeed(); s_hit(); state.flash = 0.18;
  }

  if(p.shape==='bar'){
    // Capsule (horizontal) vs circle collision
    const hw=p.barHalf, rr=p.barRad;
    // Closest point on segment to puck center
    let ax=p.x-hw, ay=p.y, bx=p.x+hw, by=p.y;
    const abx=bx-ax, aby=by-ay; // (length 2*hw, horizontal)
    let t = ((puck.x-ax)*abx + (puck.y-ay)*aby) / (abx*abx + aby*aby);
    t = Math.max(0, Math.min(1, t));
    const cx = ax + abx*t, cy = ay + aby*t; // closest point on segment center-line
    let nx = puck.x - cx, ny = puck.y - cy; // vector to closest point
    let dist = Math.hypot(nx,ny);
    const minDist = puck.r + rr;

    // --- goal-line "grazing" assist: treat near-miss as save ---
    const nearMiss = (p===ai && aiCounterBias>0 && puck.vy<0 && dist < minDist + 10*DPR);
    if(nearMiss){
      // compute and normalize normal; push puck onto contact shell
      nx = (nx||(1)) / (dist||1); ny = (ny||(0)) / (dist||1);
      const overlap = Math.max(0.6, (minDist - dist) + 0.6);
      puck.x += nx*overlap; puck.y += ny*overlap;
      resolveWithNormal(nx, ny, p);
      return;
    }

    if(dist < minDist){
      nx = (nx||(1)) / (dist||1); ny = (ny||(0)) / (dist||1);
      const overlap = (minDist - dist) + 0.6;
      puck.x += nx*overlap; puck.y += ny*overlap;
      resolveWithNormal(nx, ny, p);
    }
    return;
  }

  // circle fallback (not used now)
  const dx = puck.x - p.x; const dy = puck.y - p.y;
  let dist = Math.hypot(dx,dy); const minDist = puck.r + p.r;
  let nx = (dx||1)/(dist||1), ny = (dy||0)/(dist||1);

  // goal-line "grazing" assist for circle, too
  const nearMiss = (p===ai && aiCounterBias>0 && puck.vy<0 && dist < minDist + 10*DPR);
  if(nearMiss){
    const overlap = Math.max(0.6, (minDist - dist) + 0.6);
    puck.x += nx*overlap; puck.y += ny*overlap;
    resolveWithNormal(nx, ny, p);
    return;
  }

  if(dist < minDist){
    const overlap = (minDist - dist) + 0.6;
    puck.x += nx*overlap; puck.y += ny*overlap;
    resolveWithNormal(nx, ny, p);
  }
}

function clampPuckSpeed(){
  const sp = Math.hypot(puck.vx, puck.vy) || 1;
  const ns = Math.max(PHYS.minSp, Math.min(PHYS.maxSp, sp));
  puck.vx = puck.vx/sp*ns; puck.vy = puck.vy/sp*ns;
}

function physics(dt){
  // Sub-step integration to prevent tunneling when paddles move fast
  const maxMove = puck.r*0.75; // max puck travel per substep
  const move = Math.max(Math.abs(puck.vx), Math.abs(puck.vy)) * dt;
  let steps = Math.ceil(move / maxMove);
  steps = Math.max(1, Math.min(steps, 6));
  const sdt = dt / steps;
  for(let s=0; s<steps; s++){
    // integrate
    puck.x += puck.vx*sdt; puck.y += puck.vy*sdt;
    // air drag
    puck.vx *= Math.pow(PHYS.air, sdt/ (1/60)); // scale drag to substep
    puck.vy *= Math.pow(PHYS.air, sdt/ (1/60));

    // walls (left/right)
    if(puck.x < puck.r){ puck.x=puck.r; puck.vx = -puck.vx*PHYS.wallRest; puck.vy *= PHYS.wallFric; s_hit(); }
    if(puck.x > W-puck.r){ puck.x=W-puck.r; puck.vx = -puck.vx*PHYS.wallRest; puck.vy *= PHYS.wallFric; s_hit(); }

    // goals (top/bottom)
    if(puck.y < puck.r){ state.you++; goal('YOU'); break; }
    if(puck.y > H-puck.r){ state.ai++; goal('AI'); break; }

    // AI update once per frame on first substep; light adjust on later
    if(s===0){ if(state.mode==='1P'){ aiUpdate(sdt); } }

    // paddle collisions (use movingNearPuck to avoid passthrough on fast handle)
    if(you.active && movingNearPuck(you, sdt)) collidePaddle(you);
    if(state.mode==='2P'){
      if(ai.active && movingNearPuck(ai, sdt)) collidePaddle(ai);
    } else {
      collidePaddle(ai);
    }
  }

  // warnings & flashes decay
  if(state.flash>0) state.flash -= dt; if(warnFlash>0) warnFlash -= dt*2.5;

  // timer
  timeAcc += dt; if(timeAcc>=1){ timeAcc-=1; state.time--; updateHUD(); if(state.time<=0) finish(); }
}

function goal(who){ s_goal(); puck.reset(); state.flash=0.4; showToast(`${who} GOAL!`); updateHUD(); }
function penalize(who){ s_pen(); state.penaltyCooldown = 1.2; if(who==='YOU' && state.you>0) state.you--; if(who==='AI' && state.ai>0) state.ai--; flashWarn(); showToast(`${who} PENALTY!`); updateHUD(); if(who==='YOU'){ // push back paddle
  you.y = Math.max(you.y, MID + you.r*1.1);
 } else { ai.y = Math.min(ai.y, MID - ai.r*1.1); }
}

// --------------------------------------------------------
// Render (neon styles)
function glowCircle(x,y,r, color, innerColor){ ctx.save(); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); const g=ctx.createRadialGradient(x,y,r*0.3,x,y,r); g.addColorStop(0, innerColor || '#ffffff'); g.addColorStop(1, color); ctx.fillStyle=g; ctx.fill(); ctx.shadowColor=color; ctx.shadowBlur=r*0.8; ctx.strokeStyle=color; ctx.lineWidth = Math.max(2*DPR, r*0.08); ctx.stroke(); ctx.restore(); }

function drawPaddle(p){
  if(p.shape==='bar'){
    const hw=p.barHalf, rr=p.barRad; 
    ctx.save();
    // neon glow
    ctx.shadowColor = p===ai ? 'rgba(122,92,255,.8)' : 'rgba(0,209,255,.8)';
    ctx.shadowBlur = rr*1.1;
    ctx.fillStyle = p===ai ? 'rgba(200,180,255,.85)' : 'rgba(200,255,255,.9)';
    ctx.strokeStyle = p===ai ? 'rgba(122,92,255,.6)' : 'rgba(0,209,255,.6)';
    ctx.lineWidth = 3*DPR;
    // rounded capsule path (horizontal bar)
    ctx.beginPath();
    ctx.moveTo(p.x-hw, p.y-rr);
    ctx.lineTo(p.x+hw, p.y-rr);
    ctx.arc(p.x+hw, p.y, rr, -Math.PI/2, Math.PI/2, false);
    ctx.lineTo(p.x-hw, p.y+rr);
    ctx.arc(p.x-hw, p.y, rr, Math.PI/2, -Math.PI/2, false);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.restore();
  } else {
    glowCircle(p.x, p.y, p.r, p===ai ? 'rgba(122,92,255,.45)':'rgba(0,209,255,.5)','rgba(255,255,255,.9)');
  }
}

function draw(){ ctx.clearRect(0,0,W,H);
  // center neon line
  ctx.save(); ctx.strokeStyle='rgba(19,210,255,0.55)'; ctx.lineWidth=4*DPR; ctx.setLineDash([18*DPR, 12*DPR]); ctx.beginPath(); ctx.moveTo(0,MID); ctx.lineTo(W,MID); ctx.stroke(); ctx.restore();

  // goals highlights
  ctx.save();
  const topG=ctx.createLinearGradient(0,0,0,40*DPR); topG.addColorStop(0,'rgba(19,210,255,.6)'); topG.addColorStop(1,'rgba(19,210,255,0)');
  ctx.fillStyle=topG; ctx.fillRect(0,0,W,40*DPR);
  const botG=ctx.createLinearGradient(0,H,0,H-40*DPR); botG.addColorStop(0,'rgba(19,210,255,.6)'); botG.addColorStop(1,'rgba(19,210,255,0)');
  ctx.fillStyle=botG; ctx.fillRect(0,H-40*DPR,W,40*DPR);
  ctx.restore();

  // tail flash when hit
  if(state.flash>0){ ctx.save(); ctx.globalAlpha = Math.min(0.7, state.flash*2); const rr=puck.r*2.4; glowCircle(puck.x,puck.y, rr, 'rgba(36,228,255,.35)','rgba(255,255,255,.8)'); ctx.restore(); }

  // paddles
  if(state.mode==='2P' ? ai.active : true){ drawPaddle(ai); }
  if(you.active) drawPaddle(you);

  // puck
  glowCircle(puck.x, puck.y, puck.r, 'rgba(36,228,255,.55)','rgba(255,255,255,.95)');

  // warning flash
  if(warnFlash>0){ ctx.save(); ctx.globalAlpha = warnFlash; ctx.fillStyle='rgba(255,59,92,.18)'; ctx.fillRect(0,0,W,H); ctx.restore(); }
}

let warnFlash=0; function flashWarn(){ warnFlash=0.55; }

// --------------------------------------------------------
// Loop & HUD
// --------------------------------------------------------
function loop(ts){ if(!state.running){ state.lastTs = ts; return requestAnimationFrame(loop);} const dt = Math.min(0.033, (ts - state.lastTs)/1000); state.lastTs = ts;
  if(flickCooldown>0) flickCooldown -= dt;
  physics(dt); draw();
  if(state.flash>0) state.flash -= dt; if(warnFlash>0) warnFlash -= dt*2.5;
  // timer
  timeAcc += dt; if(timeAcc>=1){ timeAcc-=1; state.time--; updateHUD(); if(state.time<=0) finish(); }
  requestAnimationFrame(loop);
}

const timerEl = document.getElementById('timer');
const scoreEl = document.getElementById('score');
const aiLabelEl = document.getElementById('aiLabel');
function updateHUD(){ const mm = String(Math.max(0, Math.floor(state.time/60))).padStart(2,'0'); const ss = String(Math.max(0, state.time%60)).padStart(2,'0'); timerEl.textContent=`${mm}:${ss}`; scoreEl.innerHTML = `<span class="you">YOU ${state.you}</span> ‚Äî <span class="ai"><span id="aiLabel">${state.mode==='1P'?'ü§ñ AI':'P2'}</span> ${state.ai}</span>`; }

let timeAcc=0;
function startGame(){
  state.you=0; state.ai=0; state.time=60; state.running=true; updateHUD();
  you.x=W/2; you.y=H*0.82; ai.x=W/2; ai.y=H*0.18; you.active=false; ai.active=(state.mode==='2P'? false:true);
  computeHomeY(); // ensure homeY reflects current DPR and radii
  // Serve: start towards random side with slow speed
  const side = Math.random()<0.5 ? 'AI' : 'YOU'; startServe(side);
  hide(document.getElementById('startOverlay')); hide(document.getElementById('resultOverlay'));
  state.lastTs = performance.now(); requestAnimationFrame(loop);
  initAudio(); if(actx?.state==='suspended') actx.resume(); startBGM(); showToast(`SERVE ‚Üí ${side}`);
}
function finish(){ state.running=false; stopBGM(); const res = state.you===state.ai? 'DRAW' : (state.you>state.ai? 'YOU WIN!' : 'YOU LOSE'); document.getElementById('resultText').textContent = `${res}  ‚Äî  ${state.you} : ${state.ai}`; show(document.getElementById('resultOverlay')); }

// --------------------------------------------------------
// UI / overlays
// --------------------------------------------------------
const startOv = document.getElementById('startOverlay');
const btnStart = document.getElementById('btnStart');
const diffSeg = document.getElementById('diffSeg');

startOv.addEventListener('click',(e)=>{ const t=e.target.closest('.btn'); if(!t) return; if(t.dataset.mode){ state.mode=t.dataset.mode; toggleDiffVisible(); highlightSelect(); updateHUD(); }
  if(t.dataset.diff){ state.diff = +t.dataset.diff; highlightSelect(); }
});
btnStart.addEventListener('click', ()=>{ startGame(); });

document.getElementById('btnRetry').addEventListener('click', ()=>{ startGame(); });
document.getElementById('btnMenu').addEventListener('click', ()=>{ show(startOv); hide(document.getElementById('resultOverlay')); stopBGM(); });

function toggleDiffVisible(){ diffSeg.parentElement.style.opacity = (state.mode==='1P'? 1:0.35); diffSeg.parentElement.style.pointerEvents = (state.mode==='1P'? 'auto':'none'); aiLabelEl.textContent = (state.mode==='1P'? 'ü§ñ AI':'P2'); }
function highlightSelect(){ for(const b of startOv.querySelectorAll('[data-mode]')) b.classList.toggle('primary', b.dataset.mode===state.mode); for(const b of diffSeg.querySelectorAll('[data-diff]')) b.classList.toggle('primary', +b.dataset.diff===state.diff); }
function show(el){ el.style.display='flex'; }
function hide(el){ el.style.display='none'; }

// toast
const toastEl = document.getElementById('toast');
let toastTimer=null; function showToast(msg){ toastEl.textContent=msg; toastEl.classList.add('show'); clearTimeout(toastTimer); toastTimer=setTimeout(()=>toastEl.classList.remove('show'), 1100); }

// initial highlight
highlightSelect(); toggleDiffVisible();

// --------------------------------------------------------
// Accessibility: keyboard (for desktop testing)
// --------------------------------------------------------
let k= {l:false,r:false,u:false,d:false};
document.addEventListener('keydown',(e)=>{ 
  if(e.key==='Enter' && startOv.style.display!=='none'){ startGame(); }
  if(e.key==='1') { state.mode='1P'; highlightSelect(); toggleDiffVisible(); }
  if(e.key==='2') { state.mode='2P'; highlightSelect(); toggleDiffVisible(); }
  if(e.key==='ArrowLeft') k.l=true; 
  if(e.key==='ArrowRight') k.r=true; 
  if(e.key==='ArrowUp') k.u=true; 
  if(e.key==='ArrowDown') k.d=true; 
});
document.addEventListener('keyup',(e)=>{ if(e.key==='ArrowLeft') k.l=false; if(e.key==='ArrowRight') k.r=false; if(e.key==='ArrowUp') k.u=false; if(e.key==='ArrowDown') k.d=false; });
function desktopYou(dt){ const speed=900*DPR; let vx=0,vy=0; if(k.l) vx-=speed; if(k.r) vx+=speed; if(k.u) vy-=speed; if(k.d) vy+=speed; if(vx||vy){ you.active=true; you.x += vx*dt; you.y += vy*dt; you.clampToSide(); }
}
// hook into loop by monkey-patching aiUpdate call when not touching on desktop
const _aiUpdate = aiUpdate; aiUpdate = function(dt){ _aiUpdate(dt); if(!('ontouchstart' in window)){ desktopYou(dt); } }

// --------------------------------------------------------
// Prevent scrolling on touch move outside canvas on iOS
// --------------------------------------------------------
document.body.addEventListener('touchmove', (e)=>{ if(e.target!==canvas) e.preventDefault(); }, {passive:false});

// --------------------------------------------------------
// Self-tests (basic runtime checks)
// --------------------------------------------------------
function runSelfTests(){
  const results=[]; const ok=(name,cond)=>{ results.push({name,pass:!!cond}); if(!cond) console.error('[TEST FAIL]',name); else console.log('[TEST PASS]',name); };
  // 1) clamp test: you cannot cross to AI half
  const y0 = you.y; you.y = MID-10; you.clampToSide(); ok('Paddle clamp stays in own half', you.y>=MID+you.r); you.y = y0;
  // 2) speed clamp
  const vx0=puck.vx, vy0=puck.vy; puck.vx=99999; puck.vy=99999; clampPuckSpeed(); ok('Puck speed clamped', Math.hypot(puck.vx,puck.vy) <= PHYS.maxSp+1);
  // 3) AI never crosses center (1P)
  const wasMode = state.mode; state.mode='1P'; ai.y = H*0.18; ai.x=W/2; for(let i=0;i<30;i++){ aiUpdate(0.016); if(ai.y > MID - ai.r*0.1){ ok('AI stayed on own half', false); break; } if(i===29) ok('AI stayed on own half', true); }
  // 4) serve direction toward AI is upward (vy<0)
  startServe('AI'); ok('Serve to AI has upward vy', puck.vy < 0 && Math.abs(puck.vy) < 500*DPR && Math.abs(puck.vy) > 150*DPR);
  startServe('YOU'); ok('Serve to YOU has downward vy', puck.vy > 0 && Math.abs(puck.vy) < 500*DPR && Math.abs(puck.vy) > 150*DPR);
  // 5) aiBrain.homeY initialized (>0 assumed after entities)
  ok('aiBrain.homeY initialized', typeof aiBrain.homeY==='number' && aiBrain.homeY >= ai.r);
  // 6) When puck is on player half, AI tends to stay near goal (not near center)
  puck.x=W*0.7; puck.y=H*0.85; for(let i=0;i<25;i++){ aiUpdate(0.016);} ok('AI idles near goal when puck far', ai.y < MID*0.85);
  // 7) computeHomeY keeps value >= ai.r after call
  const prevHomeY = aiBrain.homeY; computeHomeY(); ok('computeHomeY keeps >= ai.r', aiBrain.homeY >= ai.r && aiBrain.homeY >= 20*DPR);
  // 8) Bar collision returns puck opposite vertically when hitting near center of bar
  const saveState = {px:puck.x, py:puck.y, vx:puck.vx, vy:puck.vy, ax:ai.x, ay:ai.y};
  puck.x = ai.x; puck.y = ai.y + ai.barRad + puck.r - 2*DPR; puck.vx = 0; puck.vy = -600*DPR; ai.vx=0; ai.vy=0; ai.active=true; state.mode='1P';
  collidePaddle(ai);
  ok('Bar hit flips vertical direction', puck.vy > 0);
  // restore
  puck.x=saveState.px; puck.y=saveState.py; puck.vx=saveState.vx; puck.vy=saveState.vy; ai.x=saveState.ax; ai.y=saveState.ay; state.mode=wasMode;

  const passed = results.every(r=>r.pass);
  if(passed) showToast('Self-tests passed');
}
// Extra test: goal-line save applies downward bias
function testGoalLineSave(){
  const was = {x:puck.x,y:puck.y,vx:puck.vx,vy:puck.vy, ax:ai.x, ay:ai.y};
  // Place puck near AI goal line, moving upward (toward goal)
  puck.x = W*0.5; puck.y = puck.r + 60*DPR; puck.vx = 0; puck.vy = -500*DPR;
  ai.x = puck.x; ai.y = puck.y + ai.r + 16*DPR;
  ai.active = true; state.mode='1P';
  aiUpdate(0.016);
  // Force a collision check
  collidePaddle(ai);
  const passed = (puck.vy > 0); // should now go downward
  console[passed?'log':'error']('[TEST '+(passed?'PASS':'FAIL')+'] Goal-line counter downward', {vy:puck.vy});
  // restore
  puck.x=was.x; puck.y=was.y; puck.vx=was.vx; puck.vy=was.vy; ai.x=was.ax; ai.y=was.ay;
}
// Additional grazing-save test: within tolerance still pushes downward
function testGrazingSave(){
  const was = {x:puck.x,y:puck.y,vx:puck.vx,vy:puck.vy, ax:ai.x, ay:ai.y};
  puck.x = W*0.5; puck.y = puck.r + 70*DPR; puck.vx = 30*DPR; puck.vy = -420*DPR;
  ai.x = puck.x; ai.y = puck.y + ai.r + 20*DPR; // slightly further -> near-miss region
  ai.active=true; state.mode='1P'; aiUpdate(0.016); collidePaddle(ai);
  const passed = (puck.vy > 0);
  console[passed?'log':'error']('[TEST '+(passed?'PASS':'FAIL')+'] Grazing goal-line save downward', {vy:puck.vy});
  // restore
  puck.x=was.x; puck.y=was.y; puck.vx=was.vx; puck.vy=was.vy; ai.x=was.ax; ai.y=was.ay;
}
// Flick test to ensure finger swipe imparts velocity
function testFlick(){
  const was = {px:puck.x,py:puck.y,vx:puck.vx,vy:puck.vy};
  // place puck on player's half
  puck.x=W*0.6; puck.y=MID+80*DPR; puck.vx=0; puck.vy=0;
  const sx=puck.x-30*DPR, sy=puck.y+30*DPR, ex=sx, ey=sy-120*DPR; // quick upward flick
  const vyBefore = puck.vy;
  const ok1 = tryFlick(sx,sy,ex,ey,0.12);
  const passed = ok1 && (puck.vx!==0 || puck.vy!==0);
  console[passed?'log':'error']('[TEST '+(passed?'PASS':'FAIL')+'] Finger flick adds velocity', {vx:puck.vx, vy:puck.vy, ok1});
  // restore
  puck.x=was.px; puck.y=was.py; puck.vx=was.vx; puck.vy=was.vy;
}
// New tests: (9) Prevent tunneling on fast handle, (10) AI wide-arc avoids own-goal
function testNoTunnel(){
  const was={x:puck.x,y:puck.y,vx:puck.vx,vy:puck.vy};
  // put puck just in front, move handle quickly across it
  puck.x=W*0.5; puck.y=MID+120*DPR; puck.vx=0; puck.vy=600*DPR; // moving down -> should score AI if no hit
  you.x=puck.x-200*DPR; you.y=MID+130*DPR; you.vx=1800*DPR; you.vy=0; you.active=true;
  const yBefore=puck.y;
  physics(1/60);
  const hitHappened = Math.abs(puck.y - yBefore) < 1e-3 ? false : (puck.vy < 0); // reversed means hit
  console[hitHappened?'log':'error']('[TEST '+(hitHappened?'PASS':'FAIL')+'] No tunneling on fast handle', {vy:puck.vy});
  // restore
  puck.x=was.x; puck.y=was.y; puck.vx=was.vx; puck.vy=was.vy; you.active=false;
}
function testAIWideArc(){
  const was={ax:ai.x,ay:ai.y, px:puck.x,py:puck.y,vx:puck.vx,vy:puck.vy};
  state.mode='1P';
  puck.x=W*0.52; puck.y=puck.r+70*DPR; puck.vx=0; puck.vy=-520*DPR; // toward AI goal
  ai.x=W*0.6; ai.y=MID*0.2; ai.vx=0; ai.vy=0; ai.active=true;
  for(let i=0;i<10;i++){ aiUpdate(1/120); }
  const avoidedGoalMouth = ai.y > (puck.r + ai.r + 20*DPR);
  console[avoidedGoalMouth?'log':'error']('[TEST '+(avoidedGoalMouth?'PASS':'FAIL')+'] AI uses wide arc near goal', {aiY:ai.y});
  // restore
  ai.x=was.ax; ai.y=was.ay; puck.x=was.px; puck.y=was.py; puck.vx=was.vx; puck.vy=was.vy;
}
setTimeout(()=>{ runSelfTests(); testGoalLineSave(); testGrazingSave(); testFlick(); testNoTunnel(); testAIWideArc(); }, 0);

</script>
</body>
</html>