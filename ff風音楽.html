<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Procedural Epic Music Engine</title>
<style>
    :root {
        --primary: #ff2a6d; /* 激しい赤 */
        --secondary: #05d9e8; /* サイバーシアン */
        --bg: #01012b;
    }
    body {
        margin: 0;
        height: 100vh;
        background: radial-gradient(circle at center, #1a1a40 0%, #000000 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        font-family: 'Segoe UI', sans-serif;
        overflow: hidden;
    }

    /* ビジュアライザー用キャンバス */
    #visualizer {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        z-index: 1;
        opacity: 0.6;
        pointer-events: none;
    }

    /* UIコンテナ */
    .container {
        z-index: 10;
        text-align: center;
        position: relative;
    }

    h1 {
        font-weight: 100;
        letter-spacing: 5px;
        font-size: 14px;
        color: rgba(255,255,255,0.5);
        margin-bottom: 20px;
        text-transform: uppercase;
    }

    /* メインボタン */
    #play-btn {
        width: 140px;
        height: 140px;
        border-radius: 50%;
        background: rgba(0,0,0,0.3);
        border: 2px solid var(--secondary);
        box-shadow: 0 0 30px var(--secondary), inset 0 0 20px rgba(5, 217, 232, 0.3);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        backdrop-filter: blur(5px);
    }

    #play-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 0 60px var(--secondary), inset 0 0 30px var(--secondary);
    }

    #play-btn.active {
        border-color: var(--primary);
        box-shadow: 0 0 80px var(--primary), inset 0 0 40px var(--primary);
        animation: pulse 2s infinite;
    }

    #icon {
        font-size: 50px;
        color: #fff;
        text-shadow: 0 0 10px rgba(255,255,255,0.8);
    }

    /* 進行状況表示 */
    #status {
        margin-top: 20px;
        font-size: 12px;
        letter-spacing: 2px;
        color: var(--secondary);
        height: 20px;
    }

    @keyframes pulse {
        0% { transform: scale(1); box-shadow: 0 0 30px var(--primary); }
        50% { transform: scale(1.05); box-shadow: 0 0 60px var(--primary); }
        100% { transform: scale(1); box-shadow: 0 0 30px var(--primary); }
    }
</style>
</head>
<body>

<canvas id="visualizer"></canvas>

<div class="container">
    <h1>Neural Symphony Engine</h1>
    <div id="play-btn">
        <div id="icon">▶</div>
    </div>
    <div id="status">READY TO INITIALIZE</div>
</div>

<script>
/**
 * EIKON SOUND ENGINE
 * 現代的なFFバトル曲のような「静寂と爆発」をプログラムで生成するエンジン
 */

const CTX = window.AudioContext || window.webkitAudioContext;
let ctx = null;
let masterGain = null;
let compressor = null;
let analyser = null;
let isPlaying = false;
let nextNoteTime = 0;
let current16th = 0;
let measureCount = 0;
let section = 'INTRO'; // INTRO, BUILD, CLIMAX, BREAK
let tempo = 145; // BPM

// 音楽理論データ (D Minor Scale / Harmonic Minor)
const SCALE = {
    base: [146.83, 164.81, 174.61, 196.00, 220.00, 233.08, 277.18], // D, E, F, G, A, Bb, C#
    bass: [36.71, 43.65, 48.99, 55.00], // D1, F1, G1, A1
    high: [587.33, 659.25, 698.46, 783.99, 880.00, 932.33, 1108.73]
};

// === 音源生成関数 (Synthesizers) ===

// 1. Cinematic Drums (重厚なタムとキック)
function playDrum(time, type) {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    if (type === 'KICK') {
        // 胴鳴り (Sine sweep)
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(30, time + 0.3);
        gain.gain.setValueAtTime(1.0, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
        
        // アタック感 (Click)
        const noise = ctx.createBufferSource();
        noise.buffer = createNoiseBuffer();
        const nFilter = ctx.createBiquadFilter();
        nFilter.type = 'lowpass';
        nFilter.frequency.value = 3000;
        const nGain = ctx.createGain();
        nGain.gain.setValueAtTime(0.4, time);
        nGain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
        noise.connect(nFilter).connect(nGain).connect(compressor);
        noise.start(time);

    } else if (type === 'SNARE') {
        // ノイズ主体
        const noise = ctx.createBufferSource();
        noise.buffer = createNoiseBuffer();
        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 200;
        
        gain.gain.setValueAtTime(0.8, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
        
        noise.connect(filter).connect(gain);
        osc.frequency.setValueAtTime(200, time); // ボディ
        osc.frequency.exponentialRampToValueAtTime(100, time + 0.1);
        
        noise.start(time);
    } else if (type === 'TOM') {
        // タムタム (深く響く)
        osc.frequency.setValueAtTime(100, time);
        osc.frequency.exponentialRampToValueAtTime(40, time + 0.4);
        gain.gain.setValueAtTime(0.7, time);
        gain.gain.linearRampToValueAtTime(0, time + 0.5);
    }

    osc.connect(gain).connect(compressor); // ドラムはコンプに通して迫力を出す
    osc.start(time);
    osc.stop(time + 0.5);
}

// 2. Strings Section (デチューンされたノコギリ波)
function playStrings(time, freq, duration, type = 'LEGATO') {
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    
    filter.type = 'lowpass';
    filter.Q.value = 1;

    // 3つのオシレーターで厚みを出す (Unison)
    [-10, 0, 10].forEach(cents => {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.detune.value = cents;
        osc.frequency.value = freq;
        osc.connect(filter);
        osc.start(time);
        osc.stop(time + duration + 0.5);
    });

    if (type === 'STACCATO') {
        // 短く鋭く
        filter.frequency.setValueAtTime(2000, time);
        filter.frequency.exponentialRampToValueAtTime(500, time + 0.2);
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.4, time + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
    } else {
        // ゆったりと
        filter.frequency.setValueAtTime(500, time);
        filter.frequency.linearRampToValueAtTime(1500, time + duration * 0.5);
        filter.frequency.linearRampToValueAtTime(500, time + duration);
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.3, time + 0.5);
        gain.gain.setValueAtTime(0.3, time + duration - 0.2);
        gain.gain.linearRampToValueAtTime(0, time + duration + 0.5);
    }

    filter.connect(gain).connect(masterGain);
}

// 3. Bass (唸るような低音)
function playBass(time, freq, duration) {
    const osc = ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(100, time);
    filter.frequency.linearRampToValueAtTime(400, time + duration * 0.8); // 徐々に開く
    
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.5, time);
    gain.gain.linearRampToValueAtTime(0, time + duration);

    osc.connect(filter).connect(gain).connect(masterGain);
    osc.start(time);
    osc.stop(time + duration);
}

// 4. Arpeggio / Piano (金属的な響き)
function playArp(time, freq) {
    const osc = ctx.createOscillator();
    osc.type = 'sine'; // 純粋なトーン
    osc.frequency.value = freq;
    
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.2, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
    
    osc.connect(gain).connect(masterGain);
    osc.start(time);
    osc.stop(time + 0.5);
}


// === ユーティリティ ===
function createNoiseBuffer() {
    const bufferSize = ctx.sampleRate * 1; 
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }
    return buffer;
}

// === 自動作曲エンジン (Sequencer) ===

function scheduler() {
    // 先読み時間 (0.1秒)
    while (nextNoteTime < ctx.currentTime + 0.1) {
        scheduleMeasure(current16th, nextNoteTime);
        
        nextNoteTime += (60 / tempo) / 4; // 16分音符進める
        current16th++;
        if (current16th === 16) {
            current16th = 0;
            measureCount++;
            updateSection(); // 小節ごとに展開をチェック
        }
    }
    if (isPlaying) {
        requestAnimationFrame(scheduler);
        drawVisualizer();
    }
}

// 展開管理
function updateSection() {
    const bar = measureCount;
    let text = "";
    
    if (bar < 4) { section = 'INTRO'; text = "PHASE 1: AWAKENING"; }
    else if (bar < 12) { section = 'BUILD'; text = "PHASE 2: RISING TENSION"; }
    else if (bar < 28) { section = 'CLIMAX'; text = "PHASE 3: BATTLE ENGAGED"; }
    else if (bar < 32) { section = 'BREAK'; text = "PHASE 4: SILENCE"; }
    else { 
        measureCount = 4; // Loop back to Build
        section = 'BUILD';
        text = "PHASE 2: RE-ENGAGE";
    }
    
    document.getElementById('status').innerText = text + " (BAR: " + bar + ")";
    document.getElementById('status').style.color = (section === 'CLIMAX') ? '#ff2a6d' : '#05d9e8';
    
    if(section === 'CLIMAX') document.getElementById('play-btn').classList.add('active');
    else document.getElementById('play-btn').classList.remove('active');
}

// 実際の音符配置ロジック
function scheduleMeasure(beat, time) {
    const isDownBeat = (beat % 4 === 0);
    const isOffBeat = (beat % 4 === 2);
    const isEighth = (beat % 2 === 0);

    // Bass Root Note (小節ごとに変化)
    let rootIndex = (Math.floor(measureCount / 2) % 4); 
    // 進行: D -> Bb -> G -> A
    const roots = [SCALE.bass[0], SCALE.bass[3]*0.5, SCALE.bass[2], SCALE.bass[3]]; 
    const currentRoot = roots[rootIndex % roots.length];

    // --- DRUMS ---
    if (section !== 'INTRO' && section !== 'BREAK') {
        // Kick Pattern (Complex)
        if (beat === 0 || beat === 10 || (section === 'CLIMAX' && beat === 3)) {
            playDrum(time, 'KICK');
        }
        
        // Snare / Tom (Epic percussion)
        if (beat === 4 || beat === 12) {
             // クライマックスではスネア、ビルドではタム
             playDrum(time, (section === 'CLIMAX') ? 'SNARE' : 'TOM');
        }
        
        // フィルイン (小節の最後)
        if (beat > 12 && Math.random() > 0.5 && section === 'CLIMAX') {
             playDrum(time, 'TOM');
        }

        // Hi-hats (16th drive)
        if (section === 'CLIMAX' || (section === 'BUILD' && isEighth)) {
            // ハイハットはノイズで簡易的に表現可能だが、ここではあえて音数を減らして負荷軽減
        }
    }

    // --- BASS ---
    if (section !== 'INTRO' && beat === 0) {
        playBass(time, currentRoot, 2); // 2拍分の長さ
    }
    if (section === 'CLIMAX' && beat === 8) {
        playBass(time, currentRoot, 1.5); // 裏にも入れる
    }

    // --- STRINGS / PADS ---
    if (beat === 0) {
        // コード感 (ルート + 5度)
        const fifth = currentRoot * 1.5;
        if (section === 'INTRO' || section === 'BREAK') {
            playStrings(time, currentRoot * 2, 4, 'LEGATO');
        } else {
            playStrings(time, currentRoot * 2, 2, 'STACCATO'); // リズムを刻む
            playStrings(time, fifth * 2, 2, 'STACCATO');
        }
    }

    // --- ARPEGGIO / MELODY ---
    if (section === 'CLIMAX' || section === 'BUILD') {
        // ランダムだがスケールに沿ったメロディ
        if (isEighth) {
            const noteIdx = Math.floor(Math.random() * SCALE.high.length);
            // ビルドアップ中は音数を減らす
            if (section === 'CLIMAX' || Math.random() > 0.5) {
                playArp(time, SCALE.high[noteIdx]);
            }
        }
    }
    
    // INTROの不穏なピアノ
    if (section === 'INTRO' && beat % 8 === 0 && Math.random() > 0.5) {
         const noteIdx = Math.floor(Math.random() * 4);
         playArp(time, SCALE.high[noteIdx] * 0.5);
    }
}


// === 初期化 & コントロール ===

function initAudio() {
    ctx = new CTX();
    
    // マスターエフェクトチェーン
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -24;
    compressor.knee.value = 30;
    compressor.ratio.value = 12;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.25;

    masterGain = ctx.createGain();
    masterGain.gain.value = 0.7;
    
    // アナライザー (ビジュアル用)
    analyser = ctx.createAnalyser();
    analyser.fftSize = 256;

    // リバーブ (簡易的なDelay Networkで代用)
    const delay = ctx.createDelay();
    delay.delayTime.value = 0.35; // 350ms
    const feedback = ctx.createGain();
    feedback.gain.value = 0.4;
    const reverbFilter = ctx.createBiquadFilter();
    reverbFilter.type = 'lowpass';
    reverbFilter.frequency.value = 2000; // 高域を削って暗くする

    // 接続
    compressor.connect(masterGain);
    masterGain.connect(analyser);
    analyser.connect(ctx.destination);
    
    // リバーブ接続 (Send/Return)
    compressor.connect(delay);
    delay.connect(reverbFilter);
    reverbFilter.connect(feedback);
    feedback.connect(delay);
    reverbFilter.connect(masterGain); // Mix
}

// ビジュアライザー描画
const canvas = document.getElementById('visualizer');
const canvasCtx = canvas.getContext('2d');

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function drawVisualizer() {
    if(!isPlaying) return;
    
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    analyser.getByteFrequencyData(dataArray);

    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const radius = 100;
    
    // 円形スペクトラム
    canvasCtx.beginPath();
    for (let i = 0; i < bufferLength; i++) {
        const barHeight = dataArray[i] * 1.5;
        const angle = (i / bufferLength) * Math.PI * 2;
        const x = cx + Math.cos(angle) * (radius + barHeight * 0.5);
        const y = cy + Math.sin(angle) * (radius + barHeight * 0.5);
        
        const hue = i * 2 + (measureCount * 10);
        canvasCtx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
        canvasCtx.lineWidth = 2;
        
        if (i === 0) canvasCtx.moveTo(x, y);
        else canvasCtx.lineTo(x, y);
    }
    canvasCtx.closePath();
    canvasCtx.stroke();
    
    // 低音に合わせて画面を揺らす
    if (dataArray[1] > 200) {
        canvas.style.transform = `scale(${1 + (dataArray[1]/2000)})`;
    } else {
        canvas.style.transform = `scale(1)`;
    }
}


// ボタン操作
const btn = document.getElementById('play-btn');
const icon = document.getElementById('icon');

btn.addEventListener('click', () => {
    if (!ctx) initAudio();
    
    if (isPlaying) {
        isPlaying = false;
        btn.classList.remove('active');
        icon.innerHTML = "▶";
        if(ctx) ctx.suspend();
        document.getElementById('status').innerText = "SYSTEM PAUSED";
    } else {
        isPlaying = true;
        btn.classList.add('active');
        icon.innerHTML = "■";
        if(ctx.state === 'suspended') ctx.resume();
        else {
            nextNoteTime = ctx.currentTime + 0.1;
            scheduler();
        }
    }
});

</script>
</body>
</html>