<!DOCTYPE html>
<html lang="ja" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AppStudio</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            forge: { 800: '#1e1e2e', 900: '#181825', 700: '#313244', accent: '#89b4fa', surface: '#45475a' }
          }
        }
      }
    }
  </script>

  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">

  <style>
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #181825; }
    ::-webkit-scrollbar-thumb { background: #45475a; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #585b70; }
    .glass-panel { background: rgba(30, 30, 46, 0.98); border-bottom: 1px solid rgba(255,255,255,0.08); }
    .sidebar-panel { background: #1e1e2e; border-right: 1px solid #313244; transition: width 0.3s ease; }
    .gutter { background-color: #313244; cursor: col-resize; width: 6px; transition: background 0.2s; }
    .gutter:hover { background-color: #89b4fa; }
    .fade-enter-active, .fade-leave-active { transition: opacity 0.2s; }
    .fade-enter-from, .fade-leave-to { opacity: 0; }

    .pill-btn { border: 1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); }
    .pill-btn:hover { background: rgba(255,255,255,.10); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New"; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New"; }

    /* Toast */
    .toast-enter-active, .toast-leave-active { transition: all .18s ease; }
    .toast-enter-from { opacity:0; transform: translateY(8px); }
    .toast-leave-to { opacity:0; transform: translateY(8px); }

    /* Draggable cursor */
    .drag-handle { cursor: move; user-select: none; }

    /* line-clamp fallback */
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
  </style>
</head>

<body class="bg-forge-900 text-gray-200 overflow-hidden font-sans">
<div id="app" class="h-screen flex flex-col">

  <div class="fixed bottom-4 left-1/2 -translate-x-1/2 z-[999] w-[92%] max-w-[760px] space-y-2 pointer-events-none">
    <transition-group name="toast" tag="div">
      <div v-for="t in toasts" :key="t.id"
           class="pointer-events-none bg-gray-900/95 border border-gray-700 rounded-xl shadow-2xl backdrop-blur px-4 py-3 flex items-start gap-3">
        <div class="mt-0.5">
          <i class="fas" :class="t.iconClass"></i>
        </div>
        <div class="min-w-0">
          <div class="text-xs font-bold text-gray-100">{{ t.title }}</div>
          <div class="text-[11px] text-gray-400 mt-0.5 whitespace-pre-wrap break-words">{{ t.message }}</div>
        </div>
      </div>
    </transition-group>
  </div>

    <div class="fixed bottom-2 right-3 z-[50] text-xs text-white font-mono font-bold pointer-events-none opacity-80 select-none drop-shadow-md">
    (c)2026 Hisashi Fujinaka All rights reserved.
  </div>

  <header class="glass-panel h-14 flex justify-between items-center px-4 z-30 shadow-lg relative">
    <div class="flex items-center gap-4">
      <div class="flex items-center gap-3">
        <div class="flex items-center gap-2 mr-1">
          <span class="text-lg font-bold tracking-wider">
                        AppStudio <span class="text-xs bg-gray-700 px-1 rounded">v5.0</span>
          </span>
        </div>

                <button v-if="appMode === 'project'" @click="toggleSidebar"
                class="group relative w-8 h-8 flex items-center justify-center rounded hover:bg-gray-700 text-gray-400 hover:text-white transition">
          <i class="fas fa-bars text-lg"></i>
          <div class="pointer-events-none absolute top-full left-1/2 -translate-x-1/2 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
            履歴サイドバー
          </div>
        </button>

        <div class="relative">
          <button @click="menus.file = !menus.file"
                  class="group flex items-center gap-2 text-xs font-bold text-gray-300 hover:text-white transition px-3 py-1.5 rounded hover:bg-white/10 border border-transparent hover:border-gray-600">
            <div class="pointer-events-none absolute top-full left-0 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
              プロジェクト切替・新規作成
            </div>
            <i class="fas fa-folder text-yellow-500"></i>
            <span>{{ projectDisplayName }}</span>
            <i class="fas fa-caret-down opacity-50"></i>
          </button>

<div v-if="menus.file"
               class="absolute top-full left-0 mt-1 w-72 bg-forge-800 border border-gray-600 rounded shadow-2xl py-1 z-50">
            <div class="px-3 py-1 text-[10px] text-gray-500 font-bold uppercase">単発アプリ</div>
            
            <a @click="createNewSingleApp" class="group relative block px-4 py-2 hover:bg-gray-700 cursor-pointer text-sm">
              <i class="fas fa-file-circle-plus w-4 text-green-400"></i> 単発htmlアプリを新規作成
              <div class="pointer-events-none absolute left-full top-0 ml-2 w-64 p-3 bg-gray-900/95 border border-gray-600 rounded-lg shadow-2xl text-xs text-gray-300 opacity-0 group-hover:opacity-100 transition-opacity duration-200 z-[60] backdrop-blur-sm">
                <strong class="text-green-400 block mb-1">単発アプリモード</strong>
                履歴管理なしで、1つのHTMLファイルをサクッと作りたい時に最適です。保存先はその都度指定します。
              </div>
            </a>

            <a @click="openSingleFile" class="group relative block px-4 py-2 hover:bg-gray-700 cursor-pointer text-sm">
              <i class="fas fa-file-code w-4"></i> HTMLファイルを開く
              <div class="pointer-events-none absolute left-full top-0 ml-2 w-64 p-3 bg-gray-900/95 border border-gray-600 rounded-lg shadow-2xl text-xs text-gray-300 opacity-0 group-hover:opacity-100 transition-opacity duration-200 z-[60] backdrop-blur-sm">
                <strong class="text-green-400 block mb-1">単発アプリモード</strong>
                既存のHTMLファイルを直接開いて編集します。履歴機能は使えませんが手軽です。
              </div>
            </a>

            <div class="border-t border-gray-700 my-1"></div>
            <div class="px-3 py-1 text-[10px] text-gray-500 font-bold uppercase">プロジェクト</div>
            
            <a @click="createNewProject" class="group relative block px-4 py-2 hover:bg-gray-700 cursor-pointer text-sm">
              <i class="fas fa-plus-circle w-4"></i> 新規プロジェクト作成
              <div class="pointer-events-none absolute left-full top-0 ml-2 w-64 p-3 bg-gray-900/95 border border-gray-600 rounded-lg shadow-2xl text-xs text-gray-300 opacity-0 group-hover:opacity-100 transition-opacity duration-200 z-[60] backdrop-blur-sm">
                <strong class="text-blue-400 block mb-1">プロジェクトモード (推奨)</strong>
                プロジェクトをフォルダ単位で管理します。保存するたびに履歴が自動記録され、いつでも過去の状態に戻せます。
              </div>
            </a>

            <a @click="openProjectFolder" class="group relative block px-4 py-2 hover:bg-gray-700 cursor-pointer text-sm">
              <i class="fas fa-folder w-4"></i> 既存プロジェクトを開く
              <div class="pointer-events-none absolute left-full top-0 ml-2 w-64 p-3 bg-gray-900/95 border border-gray-600 rounded-lg shadow-2xl text-xs text-gray-300 opacity-0 group-hover:opacity-100 transition-opacity duration-200 z-[60] backdrop-blur-sm">
                <strong class="text-blue-400 block mb-1">プロジェクトモード (推奨)</strong>
                過去に作成したプロジェクトフォルダを開いて開発を再開します。変更履歴も読み込まれます。
              </div>
            </a>

            <div class="border-t border-gray-700 my-1"></div>
            <a v-if="appMode==='project'" @click="refreshLibrary" class="block px-4 py-2 hover:bg-gray-700 cursor-pointer text-sm">
              <i class="fas fa-rotate w-4"></i> 履歴を再読込
            </a>
          </div>
        </div>
      </div>

      <div class="h-8 w-px bg-gray-700"></div>

            <div class="flex items-center p-1 gap-1 rounded border border-gray-600 bg-gray-800/50">
        <button @click="runEmulator"
                class="group relative px-4 py-1.5 bg-green-700 hover:bg-green-600 text-white text-xs rounded flex items-center gap-2 transition font-bold shadow hover:shadow-green-500/20">
          <i class="fas fa-play"></i> 実行
          <div class="pointer-events-none absolute top-full left-1/2 -translate-x-1/2 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
            コードを実行 (Ctrl+Enter)
          </div>
        </button>
        <button @click="openFullWindow"
                class="group relative px-3 py-1.5 text-gray-300 hover:bg-gray-700 hover:text-white rounded text-xs transition flex items-center gap-2">
          <i class="fas fa-external-link-alt"></i> <span class="hidden xl:inline">別ウインドウ表示</span>
          <div class="pointer-events-none absolute top-full left-1/2 -translate-x-1/2 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
            大きな画面でプレビュー
          </div>
        </button>
        <button @click="stopEmulator"
                class="group relative px-3 py-1.5 text-red-400 hover:bg-gray-700 hover:text-red-300 rounded text-xs transition">
          <i class="fas fa-stop"></i>
          <div class="pointer-events-none absolute top-full left-1/2 -translate-x-1/2 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
            実行停止・リセット
          </div>
        </button>
      </div>

      <div class="h-8 w-px bg-gray-700"></div>

            <div class="flex items-center gap-2">
        <button @click="openAiModal"
                class="group relative text-xs px-3 py-1.5 rounded bg-purple-800 hover:bg-purple-700 flex items-center gap-2 transition border border-purple-600 text-purple-100 shadow">
          <i class="fas fa-robot"></i> AI指示
          <div class="pointer-events-none absolute top-full left-1/2 -translate-x-1/2 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
            AIにコード作成・修正を依頼
          </div>
        </button>
        <button @click="openPatchModal"
                class="group relative text-xs px-3 py-1.5 rounded bg-yellow-700 hover:bg-yellow-600 flex items-center gap-2 font-bold text-white transition border border-yellow-600 shadow">
          <i class="fas fa-sync-alt"></i> コード置換
          <div class="pointer-events-none absolute top-full left-1/2 -translate-x-1/2 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
            AIが作った修正コードを適用
          </div>
        </button>
      </div>

      <div class="h-8 w-px bg-gray-700"></div>

      <div>
        <button @click="openSaveModal"
                class="group relative btn-primary text-xs px-5 py-1.5 rounded bg-blue-600 hover:bg-blue-500 flex items-center gap-2 transition shadow-lg shadow-blue-900/30 font-bold text-white">
          <i class="fas fa-save"></i> 保存
          <div class="pointer-events-none absolute top-full left-1/2 -translate-x-1/2 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
            現在の状態を保存
          </div>
        </button>
      </div>
    </div>

        <div class="flex items-center gap-2">
      <button @click="modals.settings = true"
              class="group relative w-9 h-9 flex items-center justify-center rounded hover:bg-gray-700 text-gray-400 hover:text-white transition">
        <i class="fas fa-cog"></i>
        <div class="pointer-events-none absolute top-full right-0 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
          保存先・セキュリティ設定
        </div>
      </button>
      <button @click="modals.help = true"
              class="group relative w-9 h-9 flex items-center justify-center rounded hover:bg-gray-700 text-gray-400 hover:text-white transition">
        <i class="fas fa-question-circle"></i>
        <div class="pointer-events-none absolute top-full right-0 mt-2 w-max px-2 py-1 bg-gray-900 text-[10px] text-gray-200 rounded border border-gray-700 shadow-xl opacity-0 group-hover:opacity-100 transition-opacity z-[60]">
          使い方ガイド
        </div>
      </button>
    </div>
  </header>

  <div class="flex-1 flex relative overflow-hidden">

    <transition name="fade">
      <aside v-if="appMode === 'project' && isSidebarOpen"
             class="w-80 sidebar-panel flex-shrink-0 flex flex-col z-10 shadow-xl">
        <div class="p-3 bg-forge-700 text-xs font-bold text-gray-300 flex justify-between items-center border-b border-gray-600">
          <span><i class="fas fa-history mr-1"></i> このPJの履歴</span>
          <button @click="refreshLibrary" class="hover:text-white" title="再読込">
            <i class="fas fa-sync-alt"></i>
          </button>
        </div>

        <div class="p-2 border-b border-gray-700">
          <div class="text-[11px] text-gray-400 mb-1">モード切替</div>
          <div class="flex gap-2">
            <button @click="historyMode='flat'; refreshLibrary()"
                    class="group relative flex-1 px-2 py-2 rounded text-[11px] font-bold flex flex-col items-center gap-1 leading-tight"
                    :class="historyMode==='flat' ? 'bg-blue-700 text-white shadow-lg' : 'bg-gray-800 text-gray-400 hover:bg-gray-700 border border-gray-700'">
              <i class="fas fa-clock"></i>
              このPJの履歴
              <div class="pointer-events-none absolute left-full top-0 ml-2 w-48 p-2 bg-gray-900/95 border border-gray-600 rounded shadow-xl text-[10px] text-gray-300 opacity-0 group-hover:opacity-100 transition-opacity z-50 text-left normal-case font-normal leading-relaxed backdrop-blur-sm">
                <strong class="text-blue-300 block mb-1">履歴モード (Default)</strong>
                現在のプロジェクトフォルダ内にある、全ての保存履歴（HTML）を日時順に表示します。
              </div>
            </button>
            <button @click="historyMode='group'; refreshLibrary()"
                    class="group relative flex-1 px-2 py-2 rounded text-[11px] font-bold flex flex-col items-center gap-1 leading-tight"
                    :class="historyMode==='group' ? 'bg-teal-700 text-white shadow-lg' : 'bg-gray-800 text-gray-400 hover:bg-gray-700 border border-gray-700'">
              <i class="fas fa-folder-tree"></i>
              PJ一覧 (Root)
              <div class="pointer-events-none absolute left-full top-0 ml-2 w-48 p-2 bg-gray-900/95 border border-gray-600 rounded shadow-xl text-[10px] text-gray-300 opacity-0 group-hover:opacity-100 transition-opacity z-50 text-left normal-case font-normal leading-relaxed backdrop-blur-sm">
                <strong class="text-teal-300 block mb-1">プロジェクト一覧モード</strong>
                設定された「親フォルダ(Root)」直下の各フォルダをスキャンし、それぞれの最新アプリを表示します。
              </div>
            </button>
          </div>

          <div class="mt-2 text-[10px] text-gray-500">
            読み込み: <span class="text-gray-200 font-bold">{{ libraryFiles.length }}</span>件
            <span class="ml-2" v-if="libraryScanStatus">/ {{ libraryScanStatus }}</span>
          </div>

          <div class="mt-2 flex gap-2">
            <button @click="refreshLibrary"
                    class="flex-1 px-3 py-1.5 rounded text-xs font-bold bg-gray-900/40 hover:bg-gray-800 border border-gray-700"
                    title="ファイル一覧を更新">
              <i class="fas fa-rotate mr-1"></i> 再読み込み
            </button>
            <button @click="revealCurrentFolder"
                    class="px-3 py-1.5 rounded text-xs font-bold bg-gray-900/40 hover:bg-gray-800 border border-gray-700 text-gray-400 hover:text-white"
                    title="エクスプローラで場所を確認">
              <i class="fas fa-folder-open"></i>
            </button>
          </div>
        </div>

        <div class="flex-1 overflow-y-auto p-2 space-y-2">

          <div v-if="libraryFiles.length === 0" class="text-center text-gray-500 py-10 text-xs">
            <i class="fas fa-folder-open mb-2 text-2xl opacity-30"></i><br>
            履歴なし（フォルダ配下に .html が見つからない / 読み取り不可の可能性）
          </div>

<template v-if="historyMode==='group'">
            <div v-for="grp in groupedApps" :key="grp.groupKey"
                 class="rounded border border-gray-700 bg-gray-900/40 overflow-hidden hover:border-blue-500 transition cursor-pointer"
                 @click="openProjectFromList(grp.versions[0])">
              <div class="p-3 bg-gray-900/60 flex items-start justify-between gap-3">
                <div class="min-w-0 flex-1">
                  <div class="flex items-center gap-2 mb-1">
                    <i class="fas fa-folder text-yellow-500 text-sm"></i>
                    <div class="text-xs font-bold text-blue-200 truncate">
                      {{ grp.latestTitle || grp.groupKey }}
                    </div>
                  </div>
                  <div class="text-[10px] text-gray-500 mb-1">
                    最終更新: {{ grp.versions[0]?.savedAtStr }}
                  </div>
                                    <div class="text-[10px] text-gray-400 mt-1 line-clamp-2 bg-gray-800/50 p-1.5 rounded hover:bg-gray-700/80 transition-colors"
                       v-if="grp.latestAiInstruction"
                       @mouseenter="showHistoryDetail($event, grp.latestAiInstruction)"
                       @mouseleave="hideHistoryDetail">
                    <i class="fas fa-robot mr-1 opacity-70"></i>{{ grp.latestAiInstruction }}
                  </div>
                </div>
                <button class="px-3 py-1.5 text-[10px] rounded bg-blue-600 hover:bg-blue-500 text-white font-bold shadow-lg flex-shrink-0 flex items-center gap-1">
                  <i class="fas fa-door-open"></i> 開く
                </button>
              </div>
            </div>
          </template>

                    <template v-else>
            <div v-for="(file, idx) in libraryFilesFlat" :key="file.name"
                 class="group p-2 rounded bg-gray-800 border border-gray-700 hover:border-gray-500 transition cursor-pointer flex flex-col gap-1 relative"
                 :class="{'border-forge-accent bg-gray-700': currentFileName === file.name}"
                 @click="loadFile(file.handle)">
                            <div class="flex justify-between items-start gap-2">
                <span class="text-xs font-bold text-blue-300 truncate w-52">
                  {{ file.displayTitle }}
                  <span v-if="idx === 0" class="inline-block bg-pink-600 text-white text-[9px] px-1.5 rounded-sm ml-1 font-mono shadow-sm">LATEST</span>
                </span>
                <span class="text-[10px] text-gray-400 whitespace-nowrap">{{ file.savedAtStr }}</span>
              </div>
              <div class="text-[10px] text-gray-500">
                key: <span class="mono">{{ file.groupKey.slice(0,12) }}</span>
              </div>
              <div class="text-[10px] text-gray-500 break-all">
                {{ file.name }}
              </div>
                            <div class="text-[11px] text-gray-300 mt-1 bg-gray-900 bg-opacity-50 p-1 rounded italic line-clamp-2 hover:bg-gray-700 transition-colors"
                   v-if="file.meta.aiInstruction || file.meta.comment"
                   @mouseenter="showHistoryDetail($event, file.meta.aiInstruction || file.meta.comment)"
                   @mouseleave="hideHistoryDetail">
                <i class="fas fa-comment-alt text-[9px] mr-1 opacity-50"></i>{{ file.meta.aiInstruction || file.meta.comment }}
              </div>
              <div class="mt-2 flex gap-1 opacity-60 group-hover:opacity-100 transition">
                <button @click.stop="runExternal(file)"
                        class="flex-1 py-1 bg-gray-600 hover:bg-gray-500 rounded text-[10px]">
                  <i class="fas fa-external-link-alt"></i> 別窓で実行
                </button>
              </div>
            </div>
          </template>

        </div>
            </aside>
    </transition>

    
    <div v-if="hoveredHistory"
         class="fixed z-[100] w-72 p-3 bg-gray-900/95 border border-gray-500 rounded-lg shadow-2xl text-xs text-gray-100 pointer-events-none whitespace-pre-wrap break-words backdrop-blur font-sans leading-relaxed"
         :style="{ top: hoveredHistory.top + 'px', left: hoveredHistory.left + 'px' }">
      <div class="text-[10px] text-blue-300 font-bold mb-1 border-b border-gray-700 pb-1">History Comment</div>
      {{ hoveredHistory.text }}
    </div>

    <section id="editor-pane" class="flex-1 flex flex-col min-w-[300px] relative z-0">
      <div class="bg-forge-800 h-8 flex items-center justify-between px-2 border-b border-gray-700 select-none">
        <div class="flex items-center gap-2">
          <span class="text-xs font-bold text-gray-500 px-2"><i class="fas fa-code"></i> エディタ</span>

          <button @click="openFindReplace('find')"
                  class="text-gray-400 hover:text-white px-2 py-1 hover:bg-gray-700 rounded text-xs"
                  title="検索 (Ctrl+F)">
            <i class="fas fa-search"></i>
          </button>
          <button @click="openFindReplace('replace')"
                  class="text-gray-400 hover:text-white px-2 py-1 hover:bg-gray-700 rounded text-xs"
                  title="置換 (Ctrl+H)">
            <i class="fas fa-i-cursor"></i>
          </button>

          <button @click="clearCode"
                  class="text-gray-400 hover:text-red-400 px-2 py-1 hover:bg-gray-700 rounded text-xs"
                  title="全クリア">
            <i class="fas fa-trash-alt"></i>
          </button>
        </div>

        <div class="text-[10px] text-gray-500 font-mono flex gap-3">
          <span>{{ editorStats.lines }} 行</span>
          <span>{{ editorStats.chars }} 文字</span>
        </div>
      </div>

      <div class="flex-1 relative group">
        <div id="editor-container" class="w-full h-full"></div>

        <div v-if="findUI.open"
             class="absolute z-20 w-[720px] max-w-[92%] bg-gray-900/95 border border-gray-700 rounded-lg shadow-2xl backdrop-blur p-3"
             :style="{ left: findUI.x + 'px', top: findUI.y + 'px' }">
          <div class="flex items-center justify-between mb-2 drag-handle"
               @mousedown.prevent="startDragFindUI">
            <div class="text-xs font-bold text-gray-200 flex items-center gap-2">
              <i class="fas fa-search text-blue-300"></i>
              <span>Find / Replace</span>
              <span class="text-[10px] text-gray-500">(Escで閉じる / ドラッグで移動)</span>
            </div>
            <button @click.stop="closeFindReplace"
                    class="w-7 h-7 rounded bg-gray-800 hover:bg-gray-700 border border-gray-700 text-gray-200"
                    title="閉じる">
              <i class="fas fa-times text-xs"></i>
            </button>
          </div>

          <div class="mb-2 flex items-center justify-between gap-2">
            <label class="flex items-center gap-2 text-[11px] text-gray-200 select-none cursor-pointer bg-gray-900/40 border border-gray-700 rounded px-3 py-1.5">
              <input type="checkbox" v-model="findUI.ignoreWhitespace" class="accent-blue-500">
              <span class="font-bold">改行・スペースを無視</span>
              <span class="text-gray-500">(デフォルトON)</span>
            </label>
            <div class="text-[10px] text-gray-500">※単純検索（正規表現なし）</div>
          </div>

          <div class="mb-2">
            <div class="flex items-center justify-between mb-1">
              <label class="text-[11px] font-bold text-gray-300">Find</label>
              <button type="button"
                      @click="findUI.find=''; recomputeMatchCount(); $nextTick(()=>findInputEl && findInputEl.focus())"
                      class="px-2 py-1 text-[10px] rounded bg-gray-800 hover:bg-gray-700 border border-gray-700 text-gray-200 flex items-center gap-1"
                      title="Findをクリア">
                <i class="fas fa-eraser text-[10px]"></i> クリア
              </button>
            </div>

            <textarea ref="findInputEl"
                      v-model="findUI.find"
                      class="w-full bg-gray-800 border border-gray-700 rounded px-3 py-2 text-xs text-gray-100 outline-none focus:border-blue-400 font-mono h-24 resize-y whitespace-pre"
                      placeholder="検索文字列（そのまま貼り付けOK / Ctrl+F）"
                      @input="recomputeMatchCount"
                      @keydown.enter.exact.prevent="findNext()"></textarea>
          </div>

          <div class="mb-2">
            <div class="flex items-center justify-between mb-1">
              <label class="text-[11px] font-bold text-gray-300">Replace</label>
              <button type="button"
                      @click="findUI.replace=''; $nextTick(()=>replaceInputEl && replaceInputEl.focus())"
                      class="px-2 py-1 text-[10px] rounded bg-gray-800 hover:bg-gray-700 border border-gray-700 text-gray-200 flex items-center gap-1"
                      title="Replaceをクリア">
                <i class="fas fa-eraser text-[10px]"></i> クリア
              </button>
            </div>

            <textarea ref="replaceInputEl"
                      v-model="findUI.replace"
                      class="w-full bg-gray-800 border border-gray-700 rounded px-3 py-2 text-xs text-gray-100 outline-none focus:border-yellow-400 font-mono h-24 resize-y whitespace-pre"
                      placeholder="置換文字列（そのまま貼り付けOK / Ctrl+H）"
                      @keydown.enter.exact.prevent="replaceOne()"></textarea>
          </div>

          <div class="flex items-center justify-between gap-2 mt-2">
            <div class="flex gap-2">
              <button @click="findNext"
                      class="px-3 py-2 rounded bg-blue-700 hover:bg-blue-600 text-white text-xs font-bold border border-blue-600">
                次を検索
              </button>
              <button @click="findPrev"
                      class="px-3 py-2 rounded bg-blue-900 hover:bg-blue-800 text-white text-xs font-bold border border-blue-800">
                前を検索
              </button>
            </div>

            <div class="flex gap-2">
              <button @click="replaceOne"
                      class="px-3 py-2 rounded bg-yellow-700 hover:bg-yellow-600 text-white text-xs font-bold border border-yellow-600">
                置換
              </button>
              <button @click="replaceAll"
                      class="px-3 py-2 rounded bg-yellow-900 hover:bg-yellow-800 text-white text-xs font-bold border border-yellow-800">
                全置換
              </button>
            </div>
          </div>

          <div class="mt-2 text-[10px] text-gray-500 flex justify-between items-center">
            <span v-if="findUI.find && findUI.matchCount > 0" class="text-red-400 font-bold text-[12px]">該当箇所が見つかりました：{{ findUI.matchCount }}件</span>
            <span v-else-if="findUI.find && findUI.matchCount === 0">該当箇所は見つかりませんでした</span>
            <span v-else>検索文字列を入力してください</span>
            <span class="text-gray-600">Enter=次</span>
          </div>
        </div>

        <button @click="copyFullCode"
                class="absolute top-4 right-6 bg-gray-700 bg-opacity-80 hover:bg-blue-600 text-white text-xs px-3 py-2 rounded shadow-lg backdrop-blur opacity-0 group-hover:opacity-100 transition duration-200 z-10 flex items-center gap-2 font-bold">
          <i class="fas fa-copy"></i> コードをコピー
        </button>
      </div>
    </section>

    <div class="gutter" @mousedown="startResize"></div>

    <section id="emulator-pane" class="flex-1 flex flex-col min-w-[300px] bg-white transition-all duration-200">
      <div class="bg-gray-100 h-8 flex items-center justify-between px-3 border-b border-gray-300">
        <div class="flex items-center gap-2">
          <div class="relative group z-20">
            <button class="flex items-center gap-2 text-xs font-bold text-gray-700 hover:bg-gray-200 px-2 py-1 rounded transition" title="デバイスサイズ切り替え">
              <i class="fas" :class="currentDevice.icon"></i>
              <span class="hidden sm:inline">{{ currentDevice.name }}</span>
              <i class="fas fa-caret-down text-[10px] opacity-50"></i>
            </button>
            <div class="absolute top-full left-0 mt-1 w-48 bg-white border border-gray-300 rounded shadow-xl py-1 hidden group-hover:block">
              <div v-for="d in deviceModes" :key="d.name" 
                   @click="currentDevice = d"
                   class="px-4 py-2 hover:bg-blue-50 cursor-pointer text-xs text-gray-700 flex items-center gap-2 transition"
                   :class="{'bg-blue-100 font-bold text-blue-800': currentDevice.name === d.name}">
                <i class="fas w-4 text-center" :class="d.icon"></i> {{ d.name }}
              </div>
            </div>
          </div>

          <button @click="runEmulator" class="text-gray-400 hover:text-green-600 ml-2" title="リロード">
            <i class="fas fa-redo"></i>
          </button>
        </div>

        <div class="flex items-center gap-1">
          <button @click="openDbModal"
                  class="flex items-center gap-2 text-xs font-bold text-gray-700 hover:bg-gray-200 px-3 py-1 rounded transition"
                  title="IndexedDB 簡易表示">
            <i class="fas fa-database text-blue-600"></i>
            <span>DB</span>
          </button>

          <div class="h-4 w-px bg-gray-300 mx-1"></div>

          <button @click="openFullWindow"
                  class="flex items-center gap-2 text-xs font-bold text-gray-700 hover:bg-gray-200 px-3 py-1 rounded transition"
                  title="別ウインドウ表示">
            <i class="fas fa-external-link-alt text-green-600"></i>
            <span>別ウインドウ</span>
          </button>
        </div>
      </div>

      <div class="flex-1 relative bg-gray-50 bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZTVlNzViIiBzdHJva2Utd2lkdGg9IjEiPjxwYXRoIGQ9Ik0wIDBoMjB2MjBIMHoiLz48cGF0aCBkPSJNMCAyMGgyME0yMCAwdjIwIiBvcGFjaXR5PSIuMiIvPjwvc3ZnPg==')] overflow-auto flex items-center justify-center">
        <div :style="{ width: currentDevice.width, height: currentDevice.height }" class="transition-all duration-300 relative shadow-2xl bg-white border border-gray-300 flex-shrink-0">
          <iframe id="emulator-frame" class="w-full h-full border-none bg-white"></iframe>
        </div>
      </div>

      <div class="h-24 bg-gray-900 border-t border-gray-700 flex flex-col font-mono text-[10px]">
        <div class="px-2 py-0.5 bg-gray-800 text-gray-500 flex justify-between">
          <span>コンソール</span>
          <button @click="consoleLogs=[]" class="hover:text-white">クリア</button>
        </div>
        <div class="flex-1 overflow-y-auto p-2" id="console-output">
          <div v-for="(log, i) in consoleLogs" :key="i" class="mb-0.5 border-b border-gray-800 pb-0.5"
               :class="{'text-red-400': log.type === 'error', 'text-yellow-400': log.type === 'warn', 'text-green-400': log.type === 'info'}">
            > {{ log.message }}
          </div>
        </div>
      </div>
    </section>
  </div>

  <div v-if="modals.ai" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm">
    <div class="glass-panel p-0 rounded-lg w-[780px] max-w-full shadow-2xl border border-gray-600 flex flex-col overflow-hidden">
      <div class="flex border-b border-gray-600 bg-gray-800">
        <button @click="aiTab='full'"
                class="flex-1 py-3 text-sm font-bold transition"
                :class="aiTab==='full' ? 'bg-forge-700 text-blue-400 border-b-2 border-blue-400' : 'text-gray-400 hover:text-white'">
          ① 全コード生成 (新規/リセット)
        </button>
        <button @click="aiTab='patch'"
                class="flex-1 py-3 text-sm font-bold transition"
                :class="aiTab==='patch' ? 'bg-forge-700 text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400 hover:text-white'">
          ② 部分修正 (手動)
        </button>
        <button @click="aiTab='json'"
                class="flex-1 py-3 text-sm font-bold transition"
                :class="aiTab==='json' ? 'bg-forge-700 text-pink-400 border-b-2 border-pink-400' : 'text-gray-400 hover:text-white'">
          ③ 部分修正 (JSONオート)
        </button>
      </div>

      <div class="p-6 bg-forge-900">
        <p class="text-xs text-gray-400 mb-2">
          <i class="fas fa-info-circle"></i>
          <span v-if="aiTab==='full'">あなたの指示を元に、AIにアプリ全体のコードを書かせるプロンプトを作成します。</span>
          <span v-else-if="aiTab==='patch'">変更指示を入力してください。AIに「変更前のコード」と「変更後のコード」を明確に出力させ、手動で置換しやすくします。</span>
          <span v-else>複数の変更を一括で行うためのJSONデータをAIに生成させます。生成されたJSONを「コード置換」画面に貼ると自動適用されます。</span>
        </p>

        <div class="mb-2 text-[11px] text-gray-500" v-if="appMode==='project'">
          対象アプリ: <span class="text-gray-200 font-bold">{{ currentAppTitle || '(未選択)' }}</span>
          <span class="ml-2 text-gray-600">(key: <span class="mono">{{ (currentGroupKey||'').slice(0,12) }}</span>)</span>
        </div>

        <div class="mb-4">
          <label class="block text-xs font-bold text-gray-300 mb-1">指示内容（このアプリに紐づけ）</label>
          <textarea v-model="aiPromptInput"
                    class="w-full h-32 bg-gray-800 border border-gray-600 rounded p-3 text-sm text-white focus:border-forge-accent outline-none resize-none"
                    :placeholder="aiTab==='full' ? '例: シンプルなTODOアプリを作って。色は青ベースで。' : '例: 「保存ボタン」の色を赤に変更して。アラートが出るようにして。'"></textarea>
          <div class="text-[10px] text-gray-500 mt-1">
            ※ここでの指示は一時的に蓄積され、保存時の履歴コメント（初期値）として使用されます。
          </div>
        </div>

        <div class="mb-4">
          <label class="block text-xs font-bold text-gray-300 mb-2">コード添付</label>
          <div class="flex flex-col gap-2 bg-gray-900/40 border border-gray-700 rounded p-3">
            <label class="flex items-center gap-2 text-sm text-gray-200 cursor-pointer">
              <input type="radio" class="accent-blue-500" name="ai-attach" :value="true" v-model="aiIncludeFullCode">
              <span class="font-bold text-gray-100">フルコードを添付する</span>
              <span class="text-[11px] text-gray-500">（コードを省略せず、すべて貼り付けます）</span>
            </label>
            <label class="flex items-center gap-2 text-sm text-gray-200 cursor-pointer">
              <input type="radio" class="accent-blue-500" name="ai-attach" :value="false" v-model="aiIncludeFullCode">
              <span class="font-bold text-gray-100">コード添付を省略</span>
              <span class="text-[11px] text-gray-500">（AIが既にコードを把握している前提）</span>
            </label>
          </div>
        </div>

                <div class="flex justify-end gap-3 mt-2">
          <button @click="modals.ai = false" class="px-4 py-2 rounded bg-gray-700 hover:bg-gray-600 text-sm">閉じる</button>
          <button @click="generateAndCopyPrompt"
                  class="px-6 py-2 rounded font-bold text-white shadow-lg flex items-center gap-2"
                  :class="aiTab==='full' ? 'bg-blue-600 hover:bg-blue-500' : (aiTab==='json' ? 'bg-pink-600 hover:bg-pink-500' : 'bg-yellow-600 hover:bg-yellow-500')">
            <i class="fas fa-magic"></i> プロンプト生成＆コピー
          </button>
        </div>

        <div v-if="aiMessage" class="mt-2 text-center text-xs text-green-400 font-bold">
          {{ aiMessage }}
        </div>
      </div>
    </div>
  </div>

  <div v-if="modals.save" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 backdrop-blur-sm">
    <div class="glass-panel p-6 rounded-lg w-[480px] shadow-2xl border border-gray-600">
      <h3 class="text-lg font-bold mb-3 text-white flex items-center gap-2">
        <i class="fas fa-save text-blue-400"></i> ファイル保存
      </h3>

      <div class="mb-3 text-[11px] text-gray-400">
        <span v-if="appMode==='project'">
          保存先: <span class="font-bold text-gray-100">プロジェクトフォルダ内</span>
        </span>
        <span v-else>
          保存先: <span class="font-bold text-gray-100">毎回指定</span>（フォルダも含めて選択できます）
        </span>
      </div>

      <div class="mb-4">
        <label class="block text-xs text-gray-400 mb-1">ファイル名 (編集可能)</label>
        <input v-model="saveFilename" type="text"
               class="w-full bg-gray-800 border border-gray-600 rounded p-2 text-sm text-white focus:border-blue-500 outline-none">
        <p class="text-[10px] text-gray-500 mt-1">※自動的に日時が付与されます（変更可）。</p>
      </div>

      <div class="mb-4">
        <label class="block text-xs text-gray-400 mb-1">変更履歴メモ（AI指示が自動入力）</label>
        <textarea v-model="saveComment"
                  class="w-full h-20 bg-gray-800 border border-gray-600 rounded p-2 text-sm text-white focus:border-blue-500 outline-none resize-none"></textarea>
      </div>

      <div class="flex justify-end gap-2">
        <button @click="modals.save = false" class="px-4 py-2 text-sm rounded bg-gray-700 hover:bg-gray-600">キャンセル</button>
        <button @click="performSave" class="px-4 py-2 text-sm rounded bg-blue-600 hover:bg-blue-500 text-white font-bold shadow-lg">保存実行</button>
      </div>
    </div>
  </div>

  <div v-if="modals.patch" class="fixed inset-0 bg-black bg-opacity-70 z-50 backdrop-blur-sm flex items-center justify-center">
    <div class="glass-panel p-0 rounded-lg w-[92%] max-w-[980px] h-[90vh] shadow-2xl border border-gray-600 flex flex-col overflow-hidden">
      <div class="flex border-b border-gray-600 bg-gray-800 flex-shrink-0">
        <button @click="patchMode='manual'"
                class="flex-1 py-3 text-sm font-bold transition"
                :class="patchMode==='manual' ? 'bg-forge-700 text-yellow-400 border-b-2 border-yellow-400' : 'text-gray-400 hover:text-white'">
          ① 手動パッチ (Manual)
        </button>
        <button @click="patchMode='json'"
                class="flex-1 py-3 text-sm font-bold transition"
                :class="patchMode==='json' ? 'bg-forge-700 text-pink-400 border-b-2 border-pink-400' : 'text-gray-400 hover:text-white'">
          ② JSONオート (Auto)
        </button>
      </div>

      <div class="p-6 flex-1 flex flex-col overflow-hidden bg-forge-900">
        <template v-if="patchMode==='manual'">
          <div class="flex items-center justify-between gap-2 flex-shrink-0">
            <p class="text-xs text-gray-400">
              AIが出力した「変更前のコード」と「変更後のコード」を貼り付けてください。
            </p>
            <label class="flex items-center gap-2 text-xs text-gray-200 select-none cursor-pointer bg-gray-900/40 border border-gray-700 rounded px-3 py-1.5">
              <input type="checkbox" v-model="patchIgnoreWhitespace" class="accent-yellow-500">
              <span class="font-bold">改行・スペースを無視して検索</span>
              <span class="text-gray-500">(デフォルトON)</span>
            </label>
          </div>

          <div class="flex-1 flex flex-col gap-3 overflow-hidden mt-3">
            <div class="flex-1 flex flex-col min-h-[180px]">
              <div class="flex justify-between items-end mb-1">
                <label class="text-xs font-bold text-red-300"><i class="fas fa-search"></i> 検索するコード (置換元)</label>
                <span v-if="patchFindInput" class="text-xs font-bold"
                      :class="patchMatchCount > 0 ? 'text-red-400' : 'text-gray-500'">
                  {{ patchMatchMessage }}
                </span>
              </div>
              <textarea v-model="patchFindInput"
                        class="flex-1 bg-gray-900 border border-red-900/50 rounded p-3 font-mono text-xs text-gray-200 focus:border-red-500 outline-none resize-y whitespace-pre"
                        placeholder="ここに置換元のコードをそのまま貼り付け（改行OK）..."></textarea>
            </div>
            <div class="flex justify-center items-center flex-shrink-0 text-gray-500 h-4">
              <i class="fas fa-arrow-down"></i>
            </div>
            <div class="flex-1 flex flex-col min-h-[180px]">
              <label class="text-xs font-bold text-green-300 mb-1"><i class="fas fa-pen"></i> 置換後のコード (新しいコード)</label>
              <textarea v-model="patchReplaceInput"
                        class="flex-1 bg-gray-900 border border-green-900/50 rounded p-3 font-mono text-xs text-gray-200 focus:border-green-500 outline-none resize-y whitespace-pre"
                        placeholder="...ここに置換後のコードをそのまま貼り付け（改行OK）"></textarea>
            </div>
          </div>

          <div class="flex justify-end gap-2 mt-3 flex-shrink-0">
            <button @click="modals.patch = false" class="px-4 py-2 text-sm rounded bg-gray-700 hover:bg-gray-600">閉じる</button>
            <button @click="applyPatch" class="px-6 py-2 text-sm rounded bg-yellow-700 hover:bg-yellow-600 text-white font-bold shadow-lg">
              置換を実行する
            </button>
          </div>
        </template>

        <template v-else>
          <div class="flex items-center justify-between gap-2 flex-shrink-0">
            <p class="text-xs text-gray-400">
              AIが出力したJSONコードブロック（<code>[{ "search": "...", "replace": "..." }]</code>）をそのまま貼り付けてください。
            </p>
            <label class="flex items-center gap-2 text-xs text-gray-200 select-none cursor-pointer bg-gray-900/40 border border-gray-700 rounded px-3 py-1.5">
              <input type="checkbox" v-model="patchIgnoreWhitespace" class="accent-pink-500">
              <span class="font-bold">改行・スペースを無視</span>
            </label>
          </div>

          <div class="flex-1 flex flex-col mt-3">
            <textarea v-model="patchJsonInput"
                      class="flex-1 bg-gray-900 border border-pink-900/50 rounded p-3 font-mono text-xs text-gray-200 focus:border-pink-500 outline-none resize-none whitespace-pre"
                      placeholder='[
  {
    "search": "...",
    "replace": "..."
  }
]'></textarea>
          </div>

          <div class="flex justify-end gap-2 mt-3 flex-shrink-0">
            <button @click="modals.patch = false" class="px-4 py-2 text-sm rounded bg-gray-700 hover:bg-gray-600">閉じる</button>
            <button @click="applyAutoJsonPatch" class="px-6 py-2 text-sm rounded bg-pink-700 hover:bg-pink-600 text-white font-bold shadow-lg">
              <i class="fas fa-magic mr-1"></i> JSONオート置換を実行
            </button>
          </div>
        </template>
      </div>
    </div>
  </div>

  <div v-if="modals.db" class="fixed inset-0 bg-black bg-opacity-70 z-50 backdrop-blur-sm flex items-center justify-center">
    <div class="glass-panel p-6 rounded-lg w-[92%] max-w-[900px] h-[84vh] shadow-2xl border border-gray-600 flex flex-col">
      <div class="flex items-center justify-between">
        <h3 class="text-lg font-bold text-blue-300 flex items-center gap-2">
          <i class="fas fa-database"></i> IndexedDB 簡易表示
        </h3>
        <div class="flex items-center gap-2">
          <button @click="refreshDbDump"
                  class="px-3 py-1.5 rounded bg-gray-800 hover:bg-gray-700 border border-gray-700 text-xs font-bold">
            <i class="fas fa-rotate"></i> 再取得
          </button>
          <button @click="modals.db=false"
                  class="px-3 py-1.5 rounded bg-gray-800 hover:bg-gray-700 border border-gray-700 text-xs font-bold">
            <i class="fas fa-times"></i> 閉じる
          </button>
        </div>
      </div>

      <div class="mt-2 text-[11px] text-gray-400 leading-relaxed">
        ・プレビュー側(iframe)に対してメッセージで取得します。<br>
        ・対応ブラウザでは <span class="kbd">indexedDB.databases()</span> を使います（未対応の場合は一部情報のみ）。
      </div>

      <div class="mt-4 flex-1 overflow-auto bg-gray-900/50 border border-gray-700 rounded p-3">
        <div v-if="dbDump.loading" class="text-gray-400 text-sm">
          <i class="fas fa-spinner fa-spin"></i> 取得中...
        </div>

        <div v-else-if="dbDump.error" class="text-red-300 text-sm whitespace-pre-wrap">
          {{ dbDump.error }}
        </div>

        <div v-else-if="dbDump.items.length===0" class="text-gray-400 text-sm">
          データベースが見つかりません（または未対応）。
        </div>

        <div v-else class="space-y-3">
          <div v-for="db in dbDump.items" :key="db.name"
               class="rounded border border-gray-700 bg-gray-800/60 overflow-hidden">
            <div class="px-3 py-2 bg-gray-900/70 border-b border-gray-700 flex items-center justify-between gap-2">
              <div class="min-w-0">
                <div class="text-sm font-bold text-gray-100 truncate">
                  {{ db.name }} <span class="text-[11px] text-gray-400 font-normal">v{{ db.version }}</span>
                </div>
                <div class="text-[11px] text-gray-400">
                  stores: {{ db.stores?.length || 0 }}
                </div>
              </div>
              <button class="px-2 py-1 text-[10px] rounded bg-gray-800 hover:bg-gray-700 border border-gray-700"
                      @click="db.open=!db.open">
                {{ db.open ? '閉じる' : '開く' }}
              </button>
            </div>

            <div v-if="db.open" class="p-3 space-y-2">
              <div v-if="(db.stores||[]).length===0" class="text-gray-400 text-sm">
                store情報なし（取得できませんでした）
              </div>
              <div v-for="st in (db.stores||[])" :key="st.name"
                   class="rounded border border-gray-700 bg-gray-900/60 p-2">
                <div class="flex items-center justify-between">
                  <div class="text-sm font-bold text-blue-200">{{ st.name }}</div>
                  <div class="text-[11px] text-gray-400">count: {{ st.count }}</div>
                </div>
                <div class="text-[11px] text-gray-400 mt-1 break-all">
                  keyPath: {{ st.keyPath ?? '(none)' }} / autoIncrement: {{ st.autoIncrement ? 'true' : 'false' }}
                </div>
                <details class="mt-2">
                  <summary class="text-[11px] text-gray-300 cursor-pointer">サンプルキー（最大20件）</summary>
                  <pre class="mt-2 text-[10px] text-gray-200 whitespace-pre-wrap">{{ JSON.stringify(st.sampleKeys||[], null, 2) }}</pre>
                </details>
              </div>
            </div>
          </div>
        </div>

        <div class="text-[10px] text-gray-500">
          ※ セキュリティ上、プレビュー側のDB取得は「読み取りのみ」です（削除/更新はしません）。
        </div>
      </div>
    </div>
  </div>

  <div v-if="modals.help" class="fixed inset-0 bg-black bg-opacity-70 z-50 backdrop-blur-sm flex items-center justify-center">
    <div class="glass-panel p-0 rounded-lg w-[800px] max-w-full h-[85vh] shadow-2xl border border-gray-600 flex flex-col overflow-hidden">
      <div class="flex items-center justify-between px-6 py-4 bg-gray-800 border-b border-gray-700">
        <h3 class="text-lg font-bold text-white flex items-center gap-2">
          <i class="fas fa-book-open text-green-400"></i> AppStudio 使い方ガイド
        </h3>
        <button @click="markHelpSeen" class="text-gray-400 hover:text-white">
          <i class="fas fa-times"></i>
        </button>
      </div>

      <div class="flex-1 overflow-y-auto p-8 text-gray-300 space-y-10 bg-forge-900">

        <section class="space-y-4">
          <h4 class="text-2xl font-bold text-white border-b border-gray-700 pb-2">
            🚀 Vibe Coding をはじめよう
          </h4>
          <p class="text-sm leading-relaxed">
            AppStudioは、<b>「AIにコードを書いてもらい、人間は指示と確認に徹する」</b>という新しい開発スタイル（Vibe Coding）を、誰でも簡単に実践できるように設計された統合開発環境です。
            ブラウザだけで動作し、作成したファイルは全てあなたのPC（ローカルフォルダ）に保存されます。面倒な環境構築は一切不要です。
                        WEBサイトで使用されているhtml形式のプログラムに特化し、エクセルVBAでは実現できない多様な機能をもつアプリを開発できます。
          </p>
          <div class="bg-blue-900/30 border border-blue-800 p-3 rounded text-xs text-blue-200 mt-4">
            <i class="fas fa-hammer mr-1"></i> <b>Dogfooding:</b><br>
            『AppStudio』自体も、AppStudioを使って開発・改良されています。「欲しいツールは自分で作る」という体験を、ぜひあなたも体感してください。
          </div>
        </section>

        <section>
          <h4 class="text-lg font-bold text-blue-300 mb-4 flex items-center gap-2">
            <i class="fas fa-route"></i> 開発の4ステップ
          </h4>
          
          <div class="space-y-6 relative border-l-2 border-gray-700 ml-3 pl-6 pb-2">
            
            <div class="relative">
              <span class="absolute -left-[33px] top-0 w-8 h-8 bg-blue-900 border-2 border-blue-500 rounded-full flex items-center justify-center text-white font-bold text-xs">1</span>
              <h5 class="font-bold text-white mb-1">プロジェクトの準備</h5>
              <p class="text-xs text-gray-400 mb-2">
                まずは左上のフォルダアイコン <i class="fas fa-folder text-yellow-500"></i> から開発モードを選びます。
              </p>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-xs">
                <div class="bg-gray-800 p-2 rounded border border-gray-700">
                  <strong class="text-blue-300">📁 プロジェクトモード (推奨)</strong><br>
                  フォルダを1つ指定してアプリを作ります。保存するたびに履歴がファイルとして残るため、いつでも過去の状態に戻せます。
                </div>
                <div class="bg-gray-800 p-2 rounded border border-gray-700">
                  <strong class="text-green-300">📄 単発アプリモード</strong><br>
                  履歴管理なしで、1枚のHTMLファイルをサクッと作りたい時に使います。
                </div>
              </div>
            </div>

            <div class="relative">
              <span class="absolute -left-[33px] top-0 w-8 h-8 bg-gray-700 border-2 border-gray-500 rounded-full flex items-center justify-center text-white font-bold text-xs">2</span>
              <h5 class="font-bold text-white mb-1">実行・プレビュー</h5>
              <p class="text-xs text-gray-400 mb-2">
                エディタにコードがある状態で <button class="px-2 py-0.5 bg-green-700 text-white rounded text-[10px]"><i class="fas fa-play"></i> 実行</button> を押すと、右側の画面でアプリが動きます。
              </p>
              <ul class="list-disc list-inside text-xs text-gray-400">
                <li>デバイス切り替えボタンで、スマホやPCの画面サイズを確認できます。</li>
                <li><i class="fas fa-external-link-alt"></i> <b>別ウインドウ表示</b>を使うと、ブラウザの全画面で動作確認でき、開発者ツール(F12)も利用可能です。</li>
              </ul>
            </div>

            <div class="relative">
              <span class="absolute -left-[33px] top-0 w-8 h-8 bg-purple-900 border-2 border-purple-500 rounded-full flex items-center justify-center text-white font-bold text-xs">3</span>
              <h5 class="font-bold text-white mb-1">AIに指示・修正 (Vibe Coding)</h5>
              <p class="text-xs text-gray-400 mb-2">
                <button class="px-2 py-0.5 bg-purple-800 text-purple-100 border border-purple-600 rounded text-[10px]"><i class="fas fa-robot"></i> AI指示</button> ボタンが開発の要です。
              </p>
              <div class="space-y-2">
                <div class="bg-gray-800/50 p-2 rounded border border-gray-600">
                  <span class="text-blue-300 font-bold text-xs">① 全コード生成 (初期作成)</span>
                  <p class="text-[11px] text-gray-400">
                    「TODOアプリを作って」のように指示し、AIにコード全体を書かせます。出来上がったコードをエディタに<b>「全クリア」→「貼り付け」</b>して実行します。
                  </p>
                </div>
                                <div class="bg-gray-800/50 p-2 rounded border border-gray-600">
                  <span class="text-yellow-300 font-bold text-xs">② 部分修正 (手動パッチ)</span>
                  <p class="text-[11px] text-gray-400">
                    「ボタンを赤くして」のように指示し、AIに変更前後の差分コードだけを出力させます。<br>
                    それをコピーして <button class="px-2 py-0.5 bg-yellow-700 text-white border border-yellow-600 rounded text-[10px]"><i class="fas fa-sync-alt"></i> コード置換</button> 画面（手動パッチ）に貼り付けるだけで、ピンポイントに修正できます。<br>
                    <span class="text-yellow-500">※長いコード全体を再生成させるとバグりやすいため、部分修正が効率的です。</span>
                  </p>
                </div>
                <div class="bg-gray-800/50 p-2 rounded border border-gray-600">
                  <span class="text-pink-300 font-bold text-xs">③ 部分修正 (JSONオート)</span>
                  <p class="text-[11px] text-gray-400">
                    複数の修正を一括で行う場合に便利です。AIが生成したJSONコードをコピーし、<button class="px-2 py-0.5 bg-pink-700 text-white border border-pink-600 rounded text-[10px]"><i class="fas fa-magic"></i> JSONオート</button> 画面に貼り付けると、すべて自動で適用されます。
                  </p>
                </div>
              </div>
            </div>

            <div class="relative">
              <span class="absolute -left-[33px] top-0 w-8 h-8 bg-blue-900 border-2 border-blue-500 rounded-full flex items-center justify-center text-white font-bold text-xs">4</span>
              <h5 class="font-bold text-white mb-1">保存・履歴管理</h5>
              <p class="text-xs text-gray-400">
                <button class="px-2 py-0.5 bg-blue-600 text-white rounded text-[10px]"><i class="fas fa-save"></i> 保存</button> を押すとファイルに保存されます。<br>
                プロジェクトモードなら、保存のたびに日時付きファイルとして履歴が積み上がります。
                左側のサイドバーからいつでも過去のバージョンをクリックして復元（読み込み）が可能です。
              </p>
            </div>

          </div>
        </section>

                <section>
          <h4 class="text-lg font-bold text-white mb-3 border-b border-gray-700 pb-2">
            <i class="fas fa-star text-yellow-400 mr-2"></i>その他の機能
          </h4>
          <ul class="grid grid-cols-2 gap-4 text-xs text-gray-300">
            <li class="bg-gray-800 p-3 rounded h-full">
              <strong class="text-green-300 block mb-1"><i class="fas fa-cog"></i> 保存先設定</strong>
              よく使うプロジェクト保存フォルダを固定し、選択の手間を省けます。
            </li>
            <li class="bg-gray-800 p-3 rounded h-full">
              <strong class="text-red-400 block mb-1"><i class="fas fa-shield-alt"></i> セキュリティ設定</strong>
              AIへの指示に「通信禁止」「CDN禁止」等を自動付与し、安全性を高めます。
            </li>
          </ul>
        </section>

                <section>
          <h4 class="text-lg font-bold text-white mb-3 border-b border-gray-700 pb-2">
            <i class="fas fa-lightbulb text-orange-400 mr-2"></i>開発のヒント (初心者向け)
          </h4>
          <div class="space-y-3 text-xs text-gray-300">
            <div class="bg-gray-800 p-3 rounded border border-gray-700">
              <strong class="text-yellow-300 block mb-1">Q. 最初の指示のコツは？</strong>
              <p>
                最初は<b>「絶対に考慮してほしいこと」だけを最小限</b>伝えて、細かい設計はAIに任せてプロトタイプを作らせましょう。<br>
                まずは動くものを作り、そこから「部分修正」で理想に近づけていくスタイルのほうが、AI開発はうまくいきます。
              </p>
            </div>
            <div class="bg-gray-800 p-3 rounded border border-gray-700">
              <strong class="text-orange-300 block mb-1">Q. 何を作ればいいかわからない時は？</strong>
              <p class="mb-2">
                <b>「AIに直接相談する」</b>のが近道です。AIのチャット欄から直接、相談しましょう。アプリのコードを一緒に貼れば、AIはそれをもとに考えてくれます。
              </p>
              <div class="bg-black/30 p-2 rounded text-gray-400 font-mono mb-2">
                「初心者が作れる、面白いブラウザゲームのアイデアを3つ出してください」<br>
                「家計簿アプリを作ったけど、どんな追加機能があると便利ですか？コードを貼るのでアドバイスしてください。」
              </div>
              <p>
                AIが提案してくれたアイデアの中から「これだ！」と思うものを選んで、開発方針に取り入れましょう。


              </p>
            </div>

                        <div class="bg-gray-800 p-3 rounded border border-gray-700">
              <strong class="text-pink-300 block mb-1">Q. うまく動かない、直し方がわからない時は？</strong>
              <p class="mb-2">
                悩まずに、現在の状況をAIに伝えましょう。「AI指示」→<b>「③部分修正 (JSONオート)」</b>を選び、フルコードを含めて質問するのがコツです。
              </p>
              <div class="bg-black/30 p-2 rounded text-gray-400 font-mono">
                「今こんなエラーが出て動きません。原因と直し方を教えて、修正用のJSONデータを出力してください」<br>
                                「もっとデザインをカッコよくしたい。修正案をひとつ考え、JSONオート修正で適用してください」
              </div>
            </div>
          </div>
        </section>

        <section>
          <h4 class="text-lg font-bold text-white mb-3 border-b border-gray-700 pb-2">
            <i class="fas fa-shapes text-purple-400 mr-2"></i>作れるアプリの例
          </h4>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 text-xs text-gray-300">
            <div class="bg-gray-800 p-3 rounded border border-gray-700">
              <strong class="text-blue-300 block mb-1"><i class="fas fa-briefcase"></i> 仕事に役立つ</strong>
              <ul class="list-disc list-inside opacity-80">
                <li>会議用カウントダウンタイマー</li>
                <li>Markdownメモエディタ</li>
                <li>見積書・請求書PDF生成ツール</li>
                <li>カンバン方式タスク管理ボード</li>
              </ul>
            </div>
            <div class="bg-gray-800 p-3 rounded border border-gray-700">
              <strong class="text-green-300 block mb-1"><i class="fas fa-coffee"></i> 生活に役立つ</strong>
              <ul class="list-disc list-inside opacity-80">
                <li>買い物リスト・冷蔵庫在庫管理</li>
                <li>習慣トラッカー（ハビットチェーン）</li>
                <li>シンプルな家計簿・支出グラフ</li>
                <li>ポモドーロ・タイマー</li>
              </ul>
            </div>
            <div class="bg-gray-800 p-3 rounded border border-gray-700">
              <strong class="text-pink-300 block mb-1"><i class="fas fa-language"></i> 語学学習に役立つ</strong>
              <ul class="list-disc list-inside opacity-80">
                <li>英単語フラッシュカード</li>
                <li>音声認識を使った発音チェックアプリ</li>
                <li>AIと会話する英会話チャットボット</li>
                <li>ディクテーション練習プレーヤー</li>
              </ul>
            </div>
            <div class="bg-gray-800 p-3 rounded border border-gray-700">
              <strong class="text-yellow-300 block mb-1"><i class="fas fa-gamepad"></i> ゲーム・エンタメ</strong>
              <ul class="list-disc list-inside opacity-80">
                <li>落ち物パズル（テトリス風）</li>
                <li>ブロック崩し・インベーダー風</li>
                <li>選択肢で進むノベルゲーム</li>
                <li>放置系クリッカーゲーム</li>
              </ul>
            </div>
          </div>
        </section>

      </div>
<div class="p-4 bg-gray-800 border-t border-gray-700 flex justify-end">
        <button @click="markHelpSeen" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded font-bold transition shadow-lg">
          理解した
        </button>
      </div>
    </div>
  </div>

  <div v-if="modals.settings" class="fixed inset-0 bg-black bg-opacity-70 z-50 backdrop-blur-sm flex items-center justify-center">
    <div class="glass-panel p-6 rounded-lg w-[420px] shadow-2xl border border-gray-600">
      <h3 class="text-lg font-bold mb-4 text-gray-200 flex items-center gap-2"><i class="fas fa-cog"></i> 設定</h3>
      <div class="mb-4">
        <label class="block text-xs font-bold text-gray-400 mb-2">このサイトで変更を保存できる場所 (プロジェクト保存先)</label>
        <div v-if="projectRootHandle" class="text-xs text-green-400 mb-3 flex items-center gap-2 bg-green-900/30 p-2 rounded border border-green-800">
           <i class="fas fa-check-circle"></i> 指定済み: <span class="font-mono">{{ projectRootHandle.name }}</span>
        </div>
        <div v-else class="text-xs text-gray-500 mb-3 bg-gray-800 p-2 rounded border border-gray-700">
           未指定 (作成のたびに選択します)
        </div>
                <button @click="setProjectRoot" class="w-full py-2 bg-gray-700 hover:bg-gray-600 rounded text-xs text-white border border-gray-600 flex items-center justify-center gap-2">
           <i class="fas fa-folder-tree"></i> プロジェクト保存フォルダを指定
        </button>
      </div>

      <div class="mb-4 border-t border-gray-700 pt-4">
        <label class="block text-xs font-bold text-gray-400 mb-2"><i class="fas fa-shield-alt"></i> セキュリティ設定 (AI指示へ自動追加)</label>
        <label class="flex items-center gap-2 text-xs text-gray-200 mb-2 cursor-pointer hover:bg-gray-800 p-1 rounded">
          <input type="checkbox" v-model="securitySettings.noFetch" @change="saveSecuritySettings" class="accent-red-500">
          <span>外部ウェブサイトからの情報取得禁止</span>
          <span class="text-gray-500 text-[10px]">(CDN等は使わず自己完結)</span>
        </label>
        <label class="flex items-center gap-2 text-xs text-gray-200 cursor-pointer hover:bg-gray-800 p-1 rounded">
          <input type="checkbox" v-model="securitySettings.noTransmit" @change="saveSecuritySettings" class="accent-red-500">
          <span>外部への情報伝送禁止</span>
          <span class="text-gray-500 text-[10px]">(外部サーバ通信を行わない)</span>
        </label>
      </div>

      <div class="flex justify-end pt-2 border-t border-gray-700">
        <button @click="modals.settings=false" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded text-xs text-white">閉じる</button>
      </div>
    </div>
  </div>

</div>

<script type="text/template" id="default-code">
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Welcome</title>
  <style>
    body { font-family: sans-serif; display:flex; justify-content:center; align-items:center; min-height:100vh; margin:0; background:#f0f9ff; color:#334155; }
    .card { background:white; padding:2rem; border-radius:12px; box-shadow:0 4px 6px -1px rgba(0,0,0,0.1); width:min(90%, 400px); }
    h2 { color:#0ea5e9; margin:0 0 1.5rem; font-size:1.5rem; text-align:center; }
    .step { display:flex; gap:12px; margin-bottom:1.2rem; align-items:start; }
    .num { background:#0ea5e9; color:white; width:24px; height:24px; border-radius:50%; display:grid; place-items:center; font-weight:bold; font-size:12px; flex-shrink:0; margin-top:2px; }
    p { margin:0; font-size:0.9rem; line-height:1.6; }
    .btn { display:block; width:100%; padding:0.8rem; background:#0ea5e9; color:white; text-align:center; border-radius:8px; text-decoration:none; font-weight:bold; margin-top:1.5rem; border:none; cursor:pointer; transition:0.2s; }
    .btn:hover { background:#0284c7; }
  </style>
</head>
<body>
  <div class="card">
    <h2>🚀 Vibe Codingへようこそ</h2>
    
    <div class="step">
      <div class="num">1</div>
      <p>まずは<b>「AI指示」</b>ボタンから、作りたいアプリをざっくり指示して全コードを生成・貼付します。</p>
    </div>

    <div class="step">
      <div class="num">2</div>
      <p>少しずつ要望を足して<b>「JSONオート」</b>で部分修正を繰り返すと、効率よく完成度を高められます。</p>
    </div>

        <div style="margin-top: 2rem; text-align: center; font-size: 0.85rem; color: #64748b; background: #f1f5f9; padding: 0.8rem; border-radius: 8px;">
      <i style="font-style: normal;">💡</i> 詳しい使い方は、<br>画面右上の <b>ヘルプ</b> ボタンへ
    </div>
  </div>




















































<script id="lfs-meta" type="application/json">
{
  "appId": "3af38cc9d541d668dc7682a3ecc0a65e",
  "createdAt": "2026-01-03T20:11:20.821Z",
  "schema": 2,
  "title": "AppStudio",
  "savedAt": "2026-01-08T22:56:23.383Z",
  "aiInstruction": "JSONオート修正時に、エンティティ修正を本当に実行したときだけ、修正完了通知にその旨を記載して。",
  "comment": "JSONオート修正時に、エンティティ修正を本当に実行したときだけ、修正完了通知にその旨を記載して。",
  "sourceMode": "project",
  "runId": "46d9381285a5eea60845b4fa7f9dce8a"
}
</script>
</body>
</html>
</script>

<script>
const { createApp, ref, reactive, onMounted, nextTick, computed, watch } = Vue;

createApp({
  setup() {
    // --- STATE ---
    const appMode = ref('single'); // 'project' | 'single'
    const projectHandle = ref(null);
    const projectDisplayName = ref('開発をはじめる');
    const currentFileHandle = ref(null);
    const currentFileName = ref('');

        // Library / History
    const libraryFiles = ref([]);
    const libraryScanStatus = ref('');

    // History Tooltip
    const hoveredHistory = ref(null);
    const showHistoryDetail = (e, text) => {
      if (!text) return;
      const rect = e.target.getBoundingClientRect();
      // Adjust position to avoid bottom overflow
      const top = Math.min(rect.top, window.innerHeight - 200);
      hoveredHistory.value = { text, top, left: rect.right + 12 };
    };
    const hideHistoryDetail = () => { hoveredHistory.value = null; };

    // History mode
    const historyMode = ref('flat'); // 'flat' (履歴) | 'group' (RootからのPJ一覧)

    // UI state
        const menus = reactive({ file: false });
    const modals = reactive({ ai: false, save: false, patch: false, db: false, settings: false, help: false });
    const projectRootHandle = ref(null);
    const securitySettings = reactive({ noFetch: true, noTransmit: true });
    const isSidebarOpen = ref(true);

        const aiTab = ref('json'); // 'full' | 'patch' | 'json''
    const aiInstruction = ref(''); // 蓄積用(①)
    const aiPromptInput = ref(''); // モーダル入力用
    const aiMessage = ref('');
    const aiIncludeFullCode = ref(true);

    const saveComment = ref('');
    const saveFilename = ref('');

    const patchMode = ref('manual'); // 'manual' | 'json'
    const patchFindInput = ref('');
    const patchReplaceInput = ref('');
    const patchJsonInput = ref('');
    const patchIgnoreWhitespace = ref(true);

    // Patch Status
    const patchMatchCount = ref(0);
    const patchMatchMessage = ref('');

    const updatePatchStatus = () => {
      if (!editor || !patchFindInput.value) {
        patchMatchCount.value = 0;
        patchMatchMessage.value = '';
        return;
      }
      const find = patchFindInput.value;
      const full = editor.getValue();
      let count = 0;

      if (!patchIgnoreWhitespace.value) {
        // 完全一致
        let pos = 0;
        while (true) {
          const idx = full.indexOf(find, pos);
          if (idx === -1) break;
          count++;
          pos = idx + find.length;
        }
      } else {
        // 空白無視
        const normFind = normalizeFind(find);
        if (!normFind) { count = 0; }
        else {
          const { compact } = buildCompacted(full);
          let pos = 0;
          while (true) {
            const idx = compact.indexOf(normFind, pos);
            if (idx === -1) break;
            count++;
            pos = idx + normFind.length;
          }
        }
      }
      patchMatchCount.value = count;
      patchMatchMessage.value = count > 0 ? `該当箇所あり (${count}件)` : '該当なし';
    };

    watch([patchFindInput, patchIgnoreWhitespace], updatePatchStatus);

    // Emulator Device Mode
    const deviceModes = [
      { name: 'PC/スマホ/タブレット', width: '100%', height: '100%', icon: 'fa-desktop' },
      { name: 'iPhone SE', width: '375px', height: '667px', icon: 'fa-mobile-screen-button' },
      { name: 'iPhone 14/15', width: '393px', height: '852px', icon: 'fa-mobile-screen' },
      { name: 'iPad Air', width: '820px', height: '1180px', icon: 'fa-tablet-screen-button' },
      { name: 'Android (Pixel)', width: '412px', height: '915px', icon: 'fa-mobile' },
    ];
    const currentDevice = ref(deviceModes[0]);

    // Find/Replace custom UI
    const findUI = reactive({
      open: false,
      mode: 'find',
      find: '',
      replace: '',
      matchCount: 0,
      ignoreWhitespace: true,
      x: 8,
      y: 8
    });
    const findInputEl = ref(null);
    const replaceInputEl = ref(null);
    let lastFindDirection = 1;

    // Drag state for Find UI
    let dragActive = false;
    let dragStartX = 0, dragStartY = 0;
    let dragBaseX = 0, dragBaseY = 0;

    // Editor & logs
    const editorStats = reactive({ lines: 0, chars: 0 });
    const consoleLogs = ref([]);
    let editor = null;

    // Full window handle
    let fullWin = null;
    let lastRunId = null;

    // Current identity
    const currentAppTitle = ref('');
    const currentGroupKey = ref('');
    const currentMeta = reactive({});

    // DB dump state
    const dbDump = reactive({ loading: false, error: '', items: [] });

    // Toast
    const toasts = ref([]);
    const pushToast = (title, message, iconClass='fa-circle-info text-sky-300', timeout=2200) => {
      const id = crypto.getRandomValues(new Uint32Array(1))[0].toString(16) + Date.now().toString(16);
      toasts.value.push({ id, title, message, iconClass });
      setTimeout(() => {
        const idx = toasts.value.findIndex(t => t.id === id);
        if (idx >= 0) toasts.value.splice(idx, 1);
      }, Math.max(900, timeout|0));
    };

        // --- SETTINGS DB ---
    const DB_CFG = { name: 'AppStudio_DB', store: 'handles', key: 'root_dir' };
    const getDB = () => new Promise((res, rej) => {
      const r = indexedDB.open(DB_CFG.name, 1);
      r.onupgradeneeded = e => {
        const db = e.target.result;
        if(!db.objectStoreNames.contains(DB_CFG.store)) db.createObjectStore(DB_CFG.store);
      };
      r.onsuccess = () => res(r.result);
      r.onerror = () => rej(r.error);
    });
    const saveRootHandle = async (h) => {
      try { const db = await getDB(); db.transaction(DB_CFG.store, 'readwrite').objectStore(DB_CFG.store).put(h, DB_CFG.key); } catch(e){}
    };
    const loadRootHandle = async () => {
      try {
        const db = await getDB();
        return new Promise(r => {
          const req = db.transaction(DB_CFG.store, 'readonly').objectStore(DB_CFG.store).get(DB_CFG.key);
          req.onsuccess = () => r(req.result);
          req.onerror = () => r(null);
        });
      } catch { return null; }
    };
    const saveSecuritySettings = async () => {
      try {
        const db = await getDB();
        const tx = db.transaction(DB_CFG.store, 'readwrite').objectStore(DB_CFG.store);
        tx.put(securitySettings.noFetch, 'sec_no_fetch');
        tx.put(securitySettings.noTransmit, 'sec_no_transmit');
      } catch(e){}
    };
    const loadSecuritySettings = async () => {
      try {
        const db = await getDB();
        const store = db.transaction(DB_CFG.store, 'readonly').objectStore(DB_CFG.store);
        const g1 = new Promise(r => store.get('sec_no_fetch').onsuccess = e => r(e.target.result));
        const g2 = new Promise(r => store.get('sec_no_transmit').onsuccess = e => r(e.target.result));
        const [v1, v2] = await Promise.all([g1, g2]);
        if (v1 !== undefined) securitySettings.noFetch = v1;
        if (v2 !== undefined) securitySettings.noTransmit = v2;
      } catch { }
    };

    // --- UTIL ---
    const genId = () => {
      const buf = new Uint8Array(16);
      crypto.getRandomValues(buf);
      return Array.from(buf).map(b=>b.toString(16).padStart(2,'0')).join('');
    };

    const safeParseJSON = (s) => {
      try { return JSON.parse(s); } catch { return null; }
    };

    const extractTitleFromHtml = (html) => {
      const m = html.match(/<title>([\s\S]*?)<\/title>/i);
      return m ? m[1].trim() : '';
    };

    const extractMeta = (html) => {
      const m = html.match(/<script id="lfs-meta"\s+type="application\/json">\s*([\s\S]*?)\s*<\/script>/i);
      if (!m) return {};
      const j = safeParseJSON(m[1]);
      return j && typeof j === 'object' ? j : {};
    };

    const normalizeTs = (isoOrAny) => {
      if (!isoOrAny) return null;
      const d = new Date(isoOrAny);
      if (isNaN(d.getTime())) return null;
      return d;
    };

    const formatLocal = (d) => {
      try { return d.toLocaleString(); } catch { return String(d); }
    };

const injectMeta = (code, metaObj) => {
      const meta = JSON.stringify(metaObj, null, 2);
      // 自己置換回避: このコード自体が検索に引っかからないよう、タグ文字列を分割して結合する
      const tagOpen = '<script id="lfs-meta" ' + 'type="application/json">';
      const tagClose = '<\/script>';
      const tag = `\n${tagOpen}\n${meta}\n${tagClose}\n`;

      // 検索厳密化: コード内のregexリテラル(\s+等)にマッチしないよう、属性間のスペースも厳密なパターンにする
      const pattern = /<script id="lfs-meta" type="application\/json">[\s\S]*?<\/script>\s*/i;

      if (pattern.test(code)) {
        return code.replace(pattern, () => tag);
      }
      if (code.match(/<\/body>/i)) return code.replace(/<\/body>/i, () => tag + '</body>');
      return code + tag;
    };

    const miniHash = (s) => {
      // fast, stable (not crypto) - enough for grouping fallback
      let h = 2166136261;
      for (let i=0;i<s.length;i++){
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h>>>0).toString(16).padStart(8,'0');
    };

    const stableGroupKeyFromFile = (text, meta, fileName) => {
      // Priority: meta.appId > meta.createdAt > (title + first 200 chars hash)
      if (meta && typeof meta.appId === 'string' && meta.appId.length >= 8) return `app:${meta.appId}`;
      if (meta && typeof meta.createdAt === 'string' && meta.createdAt.length >= 8) return `crt:${meta.createdAt}`;
      const title = (meta && meta.title) ? String(meta.title) : (extractTitleFromHtml(text) || '');
      const head = (text || '').slice(0, 240);
      return `h:${miniHash(title + '|' + head + '|' + (fileName||''))}`;
    };

    const syncIdentityFromCode = (code) => {
      const meta = extractMeta(code);
      const title = meta.title || extractTitleFromHtml(code) || 'App';
      const groupKey = stableGroupKeyFromFile(code, meta, currentFileName.value);

      currentAppTitle.value = title;
      currentGroupKey.value = groupKey;

      Object.keys(currentMeta).forEach(k => delete currentMeta[k]);
      Object.assign(currentMeta, meta);
    };

    const markHelpSeen = () => {
      modals.help = false;
      try { localStorage.setItem('appstudio_v4_help_seen', '1'); } catch(e){}
    };

    // --- MONACO INIT ---
    onMounted(async () => {
      // 初回訪問ならヘルプを表示
      try {
        if (!localStorage.getItem('appstudio_v4_help_seen')) {
          modals.help = true;
        }
      } catch(e){}

      initMonaco();

            // 設定保存されたフォルダハンドルの復元
      const saved = await loadRootHandle();
      if (saved) projectRootHandle.value = saved;
      await loadSecuritySettings();

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.relative')) menus.file = false;
      });

      window.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); runEmulator(); return; }
        if ((e.ctrlKey || e.metaKey) && (e.key === 'f' || e.key === 'F')) { e.preventDefault(); openFindReplace('find'); return; }
        if ((e.ctrlKey || e.metaKey) && (e.key === 'h' || e.key === 'H')) { e.preventDefault(); openFindReplace('replace'); return; }
        if (e.key === 'Escape' && findUI.open) { e.preventDefault(); closeFindReplace(); return; }
      });

      // message receiver from preview iframes/windows
      window.addEventListener('message', (e) => {
        const d = e.data || {};
        if (d?.type === 'console') {
          consoleLogs.value.push({ type: d.l, message: d.m });
          return;
        }
        if (d?.type === 'idb_dump_result') {
          if (d?.runId && d.runId !== lastRunId) return;
          dbDump.loading = false;
          dbDump.error = d.error || '';
          dbDump.items = Array.isArray(d.items) ? d.items : [];
          return;
        }
      });
    });

    const initMonaco = () => {
      require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@0.45.0/min/vs' }});
      require(['vs/editor/editor.main'], function () {
        editor = monaco.editor.create(document.getElementById('editor-container'), {
          value: document.getElementById('default-code').innerHTML.trim(),
          language: 'html',
          theme: 'vs-dark',
          automaticLayout: true,
          minimap: { enabled: false },
          fontSize: 14,
          scrollBeyondLastLine: false,
        });

        const updateStats = () => {
          const model = editor.getModel();
          editorStats.lines = model.getLineCount();
          editorStats.chars = model.getValueLength();
        };

        editor.onDidChangeModelContent(() => {
          updateStats();
          if (findUI.open) recomputeMatchCount();
        });
        updateStats();

        editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyF, () => openFindReplace('find'));
        editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyH, () => openFindReplace('replace'));
        editor.addCommand(monaco.KeyCode.Escape, () => { if(findUI.open) closeFindReplace(); });

        // identity from initial code
        syncIdentityFromCode(editor.getValue());
        runEmulator();
      });
    };

        // --- FIND/REPLACE (WHITESPACE-IGNORING SUPPORTED) ---
    const buildCompacted = (src) => {
      const compactChars = [];
      const mapNormToOrig = [];
      for (let i = 0; i < src.length; i++) {
        const ch = src[i];
        // Ignore whitespace, quotes, and backticks for robust AI matching
        if (/[\s'"`]/.test(ch)) continue;
        mapNormToOrig.push(i);
        compactChars.push(ch);
      }
      return { compact: compactChars.join(""), mapNormToOrig };
    };
    const normalizeFind = (src) => (src || '').replace(/[\s'"`]+/g, '');

    const getMatches = () => {
      if(!editor) return [];
      const qRaw = findUI.find || '';
      if(!qRaw) { findUI.matchCount = 0; return []; }

      const model = editor.getModel();
      const full = model.getValue();

      if(!findUI.ignoreWhitespace) {
        const matches = model.findMatches(qRaw, true, false, false, null, true);
        findUI.matchCount = matches.length;
        return matches;
      }

      const compactFind = normalizeFind(qRaw);
      if(!compactFind) { findUI.matchCount = 0; return []; }

      const { compact: compactFull, mapNormToOrig } = buildCompacted(full);

      const ranges = [];
      let idx = 0;
      while(true) {
        const p = compactFull.indexOf(compactFind, idx);
        if (p === -1) break;

        const startOrig = mapNormToOrig[p];
        const endOrig = mapNormToOrig[p + compactFind.length - 1] + 1;

        const startPos = model.getPositionAt(startOrig);
        const endPos = model.getPositionAt(endOrig);
        const range = new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column);

        ranges.push({ range });
        idx = p + Math.max(1, compactFind.length);
      }

      findUI.matchCount = ranges.length;
      return ranges;
    };

    const recomputeMatchCount = () => { getMatches(); };

    const selectMatch = (match) => {
      if(!editor || !match?.range) return;
      editor.setSelection(match.range);
      editor.revealRangeInCenter(match.range);
      editor.focus();
    };

    const openFindReplace = (mode='find') => {
      findUI.open = true;
      findUI.mode = mode;

      recomputeMatchCount();
      setTimeout(() => {
        if (mode === 'replace') (replaceInputEl.value || findInputEl.value)?.focus?.();
        else (findInputEl.value || replaceInputEl.value)?.focus?.();
      }, 0);
    };

    const closeFindReplace = () => {
      findUI.open = false;
      editor?.focus?.();
      stopDragFindUI();
    };

    const findNext = () => {
      if(!editor) return;
      lastFindDirection = 1;
      const matches = getMatches();
      if(!matches.length) return;

      const model = editor.getModel();
      const sel = editor.getSelection();
      const curOffset = sel ? model.getOffsetAt(sel.getStartPosition()) : 0;

      let next = null;
      for (const m of matches) {
        const off = model.getOffsetAt(m.range.getStartPosition());
        if (off > curOffset) { next = m; break; }
      }
      if(!next) next = matches[0];
      selectMatch(next);
    };

    const findPrev = () => {
      if(!editor) return;
      lastFindDirection = -1;
      const matches = getMatches();
      if(!matches.length) return;

      const model = editor.getModel();
      const sel = editor.getSelection();
      const curOffset = sel ? model.getOffsetAt(sel.getStartPosition()) : 0;

      let prev = null;
      for (let i = matches.length - 1; i >= 0; i--) {
        const off = model.getOffsetAt(matches[i].range.getStartPosition());
        if (off < curOffset) { prev = matches[i]; break; }
      }
      if(!prev) prev = matches[matches.length - 1];
      selectMatch(prev);
    };

    const replaceOne = () => {
      if(!editor) return;
      const qRaw = findUI.find || '';
      if(!qRaw) return;

      (lastFindDirection === -1 ? findPrev : findNext)();
      const model = editor.getModel();
      const sel = editor.getSelection();
      if(!sel || sel.isEmpty()) return;

      const selectedText = model.getValueInRange(sel);

      if(!findUI.ignoreWhitespace) {
        if(selectedText !== qRaw) return;
        editor.executeEdits('findui-replace-one', [{ range: sel, text: findUI.replace }]);
        editor.pushUndoStop();
        findUI.find = ''; findUI.replace = ''; // 成功時にクリア
        recomputeMatchCount();
        pushToast('置換が完了しました', '1件置換しました。', 'fa-circle-check text-emerald-300', 1800);
        return;
      }

      if (normalizeFind(selectedText) !== normalizeFind(qRaw)) return;

      editor.executeEdits('findui-replace-one', [{ range: sel, text: findUI.replace }]);
      editor.pushUndoStop();
      findUI.find = ''; findUI.replace = ''; // 成功時にクリア
      recomputeMatchCount();
      pushToast('置換が完了しました', '1件置換しました。（空白無視）', 'fa-circle-check text-emerald-300', 2000);
    };

    const replaceAll = () => {
      if(!editor) return;
      const qRaw = findUI.find || '';
      if(!qRaw) return;

      const model = editor.getModel();
      const full = model.getValue();
      const replaceText = findUI.replace;

      if(!findUI.ignoreWhitespace) {
        const matches = model.findMatches(qRaw, true, false, false, null, true);
        findUI.matchCount = matches.length;
        if(!matches.length) return;

        const edits = matches
          .slice()
          .sort((a,b) => model.getOffsetAt(b.range.getStartPosition()) - model.getOffsetAt(a.range.getStartPosition()))
          .map(m => ({ range: m.range, text: replaceText }));

        editor.pushUndoStop();
        editor.executeEdits('findui-replace-all', edits);
        editor.pushUndoStop();
        findUI.find = ''; findUI.replace = ''; // 成功時にクリア
        recomputeMatchCount();
        pushToast('全置換が完了しました', `${edits.length}件置換しました。`, 'fa-circle-check text-emerald-300', 2200);
        return;
      }

      const compactFind = normalizeFind(qRaw);
      if(!compactFind) return;

      const { compact: compactFull, mapNormToOrig } = buildCompacted(full);

      const found = [];
      let idx = 0;
      while(true) {
        const p = compactFull.indexOf(compactFind, idx);
        if (p === -1) break;

        const startOrig = mapNormToOrig[p];
        const endOrig = mapNormToOrig[p + compactFind.length - 1] + 1;

        const startPos = model.getPositionAt(startOrig);
        const endPos = model.getPositionAt(endOrig);
        const range = new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column);
        found.push(range);

        idx = p + Math.max(1, compactFind.length);
      }

      findUI.matchCount = found.length;
      if (!found.length) return;

      const edits = found
        .slice()
        .sort((a,b) => model.getOffsetAt(b.getStartPosition()) - model.getOffsetAt(a.getStartPosition()))
        .map(r => ({ range: r, text: replaceText }));

      editor.pushUndoStop();
      editor.executeEdits('findui-replace-all', edits);
      editor.pushUndoStop();
      findUI.find = ''; findUI.replace = ''; // 成功時にクリア
      recomputeMatchCount();
      pushToast('全置換が完了しました', `${edits.length}件置換しました。（空白無視）`, 'fa-circle-check text-emerald-300', 2400);
    };

    // --- DRAG FIND UI ---
    const startDragFindUI = (e) => {
      dragActive = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragBaseX = findUI.x || 0;
      dragBaseY = findUI.y || 0;

      window.addEventListener('mousemove', onDragFindUI);
      window.addEventListener('mouseup', stopDragFindUI, { once: true });
    };

    const onDragFindUI = (e) => {
      if (!dragActive) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;

      const pane = document.getElementById('editor-pane');
      const rect = pane ? pane.getBoundingClientRect() : { left:0, top:0, width: window.innerWidth, height: window.innerHeight };

      const maxX = Math.max(8, rect.width - 60);
      const maxY = Math.max(8, rect.height - 60);

      let nx = dragBaseX + dx;
      let ny = dragBaseY + dy;

      nx = Math.min(maxX, Math.max(8, nx));
      ny = Math.min(maxY, Math.max(8, ny));

      findUI.x = nx;
      findUI.y = ny;
    };

    const stopDragFindUI = () => {
      dragActive = false;
      window.removeEventListener('mousemove', onDragFindUI);
    };

    // --- PROJECT & FILE OPS ---
    const setProject = async (handle, name) => {
      projectHandle.value = handle;
      projectDisplayName.value = name;
      appMode.value = 'project';
      menus.file = false;
    };

    const ensureDirPermission = async (dir) => {
      try{
        if (!dir) return false;
        if (!dir.queryPermission) return true;
        let p = await dir.queryPermission({ mode: 'readwrite' });
        if (p !== 'granted') p = await dir.requestPermission({ mode: 'readwrite' });
        return p === 'granted';
      } catch {
        return true;
      }
    };

    const refreshLibrary = async () => {
      // CLEAR
      libraryFiles.value = [];
      libraryScanStatus.value = 'scanning...';

      // MODE CHECK
      const isProjectListMode = (historyMode.value === 'group');
      const targetHandle = isProjectListMode ? projectRootHandle.value : projectHandle.value;

      if (!targetHandle) {
        libraryScanStatus.value = isProjectListMode ? 'Root folder not set' : 'No project selected';
        if(isProjectListMode) {
          pushToast('設定が必要です', '「設定」からプロジェクト保存先の親フォルダ(Root)を指定してください。', 'fa-cog text-gray-300', 4000);
          modals.settings = true;
        }
        return;
      }

      // PERMISSION CHECK
      const ok = await ensureDirPermission(targetHandle);
      if (!ok) {
        libraryScanStatus.value = 'permission denied';
        pushToast('アクセス権限エラー', 'フォルダへのアクセスが拒否されました。再度選択してください。', 'fa-triangle-exclamation text-amber-300', 3400);
        return;
      }

      const files = [];
      let scanned = 0;
      let readable = 0;
      let failed = 0;

      try {
        if (isProjectListMode) {
          // --- ROOT SCAN (Project List) ---
          // ルート直下のフォルダを列挙し、各フォルダ内で「最も新しいHTML」を1つ探す
          for await (const entry of targetHandle.values()) {
            if (entry.kind !== 'directory') continue; // プロジェクトフォルダのみ対象
            
            scanned++;
            let latestFile = null;
            let latestTime = 0;

            // 各プロジェクトフォルダ内を浅くスキャンして最新を探す
            try {
               for await (const subEntry of entry.values()) {
                 if (subEntry.kind !== 'file') continue;
                 const low = subEntry.name.toLowerCase();
                 if(!(low.endsWith('.html') || low.endsWith('.htm'))) continue;
                 
                 const file = await subEntry.getFile();
                 const mTime = file.lastModified;
                 if (mTime > latestTime) {
                   latestTime = mTime;
                   latestFile = { handle: subEntry, file: file };
                 }
               }
            } catch(e) { console.warn("Subfolder scan error", e); }

            if (latestFile) {
               try {
                 const text = await latestFile.file.text();
                 const meta = extractMeta(text);
                 const title = meta.title || entry.name; // メタタイトル優先、なければフォルダ名
                 const savedAt = new Date(latestTime);
                 
                 // プロジェクト一覧モードでは、グループキーを「フォルダ名」にする
                 const groupKey = entry.name; 

                 readable++;
                 files.push({
                    name: entry.name + '/' + latestFile.handle.name,
                    handle: latestFile.handle,
                    content: text,
                    meta,
                    displayTitle: title,
                    savedAt,
                    savedAtStr: formatLocal(savedAt),
                    groupKey,
                    relPath: entry.name + '/',
                    projectDirHandle: entry,
                    projectName: entry.name
                  });
               } catch (e) {
                 failed++;
               }
            }
          }
        } else {
          // --- CURRENT PROJECT SCAN (Flat History) ---
          // 既存の再帰スキャン
          const walk = async (dirHandle, relPath, depth) => {
            if (depth > 10) return;
            for await (const entry of dirHandle.values()) {
              if(entry.kind === 'directory') {
                await walk(entry, relPath + entry.name + '/', depth + 1);
                continue;
              }
              if(entry.kind !== 'file') continue;
              const low = entry.name.toLowerCase();
              if(!(low.endsWith('.html') || low.endsWith('.htm'))) continue;

              scanned++;
              try {
                const file = await entry.getFile();
                const text = await file.text();
                const meta = extractMeta(text);
                const title = meta.title || extractTitleFromHtml(text) || entry.name;
                const savedAt = normalizeTs(meta.savedAt) || new Date(file.lastModified);
                const groupKey = stableGroupKeyFromFile(text, meta, entry.name);

                readable++;
                files.push({
                  name: relPath + entry.name,
                  handle: entry,
                  content: text,
                  meta,
                  displayTitle: title,
                  savedAt,
                  savedAtStr: formatLocal(savedAt),
                  groupKey,
                  relPath
                });
              } catch(e) {
                failed++;
                files.push({
                  name: relPath + entry.name,
                  handle: entry,
                  content: '',
                  meta: {},
                  displayTitle: entry.name,
                  savedAt: new Date(0),
                  savedAtStr: '(read error)',
                  groupKey: stableGroupKeyFromFile(entry.name, {}, entry.name),
                  relPath,
                  readError: true
                });
              }
            }
          };
          await walk(targetHandle, '', 0);
        }

        // ソート: 新しい順
        files.sort((a,b) => (b.savedAt?.getTime?.()||0) - (a.savedAt?.getTime?.()||0));
        libraryFiles.value = files;

        libraryScanStatus.value = `done (scanned:${scanned}, items:${files.length})`;
        
        if (files.length === 0) {
          pushToast('アイテムが見つかりません', '対象フォルダにHTMLが見つかりませんでした。', 'fa-circle-info text-sky-300', 2000);
        } else {
          const modeName = isProjectListMode ? 'プロジェクト一覧' : '履歴';
          pushToast(`${modeName}を更新`, `${files.length}件 読み込みました。`, 'fa-rotate text-teal-300', 1500);
        }

      } catch(e) {
        libraryScanStatus.value = 'error';
        console.error(e);
        pushToast('読込エラー', e?.message || String(e), 'fa-triangle-exclamation text-rose-300', 3600);
      }
    };

    const revealCurrentFolder = async () => {
      const h = (historyMode.value === 'group') ? projectRootHandle.value : projectHandle.value;
      if (!h) {
        pushToast('確認不可', 'フォルダが選択されていません。', 'fa-triangle-exclamation text-amber-300');
        return;
      }
      // Browser Security Limitation: Cannot open explorer directly.
      alert(`【現在の保存フォルダ】\n📂 ${h.name}\n\n※ブラウザのセキュリティ制限により、直接エクスプローラを起動することはできません。\n上記フォルダを手動で開いてください。`);
    };

    const setProjectRoot = async () => {
      try {
        const handle = await window.showDirectoryPicker({ id: 'localforge_root', mode: 'readwrite' });
        projectRootHandle.value = handle;
        await saveRootHandle(handle);
        pushToast('設定完了', `親フォルダを「${handle.name}」に設定・保存しました。`, 'fa-check text-green-300');
      } catch(e) { /* cancel */ }
    };

    const createNewProject = async () => {
      try {
        // 設定済みの親フォルダがあればそれを使う（フォルダ選択ダイアログをスキップ）
        let parentHandle = projectRootHandle.value;
        if (!parentHandle) {
          parentHandle = await window.showDirectoryPicker({ id: 'localforge_root', mode: 'readwrite' });
        } else {
          // 権限確認のみ行う（ダイアログは出ない、または権限許可のみ）
          await ensureDirPermission(parentHandle);
        }

        const name = prompt("新規プロジェクトフォルダ名を入力してください:", "NewApp");
        if(!name) return;

        const newDirHandle = await parentHandle.getDirectoryHandle(name, { create: true });
        await setProject(newDirHandle, name);

        const fileHandle = await newDirHandle.getFileHandle('index_v1.html', { create: true });
        const writable = await fileHandle.createWritable();
        
        // 新規時はテンプレートを使わず、エディタを空にする
        const seed = "";

        const nowIso = new Date().toISOString();
        const seedMeta = {
          schema: 2,
          appId: genId(),
          createdAt: nowIso,
          savedAt: nowIso,
          title: 'New App',
          aiInstruction: '',
          comment: 'initial',
          runId: ''
        };
        
                const initialContent = injectMeta(seed, seedMeta);
        await writable.write(initialContent);
        await writable.close();

        // 作成した空ファイルをエディタに即時ロード
        editor.setValue(''); // エディタ上は空欄スタート
        currentFileName.value = 'index_v1.html';
        syncIdentityFromCode(initialContent); // メタ情報はメモリに保持
        runEmulator();

                await refreshLibrary();
        pushToast('作成完了', `プロジェクト「${name}」を作成し、エディタをクリアしました。`, 'fa-check text-green-300', 2000);
        
        // 初心者向け誘導トースト
        setTimeout(() => {
          pushToast('💡 次のステップ', 'まずは「AI指示」ボタンから「全コード生成」を試してみましょう！', 'fa-robot text-purple-300', 4000);
        }, 1200);
      } catch(e) {
        console.error(e);
        if(e.name !== 'AbortError') alert("作成エラー: " + e.message);
      }
    };

    const openProjectFolder = async () => {
      try {
        // 設定済みの親フォルダがあればそこを起点に開く
        const opts = { id: 'localforge_root', mode: 'readwrite' };
        if (projectRootHandle.value) opts.startIn = projectRootHandle.value;

        const handle = await window.showDirectoryPicker(opts);
        await setProject(handle, handle.name);

        isSidebarOpen.value = true;
        historyMode.value = 'flat';

        await refreshLibrary();
      } catch(e) { if(e.name !== 'AbortError') alert(e.message); }
    };

    const openSingleFile = async () => {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{ description: 'HTML Files', accept: {'text/html': ['.html', '.htm']} }]
        });
        const file = await handle.getFile();
        const text = await file.text();

        editor.setValue(text);
        currentFileHandle.value = handle;
        currentFileName.value = file.name;
        projectDisplayName.value = file.name + " (単発)";
        appMode.value = 'single';
        menus.file = false;

        syncIdentityFromCode(text);
        runEmulator();
      } catch(e) { if(e.name !== 'AbortError') alert(e.message); }
    };

const createNewSingleApp = async () => {
  // 目的：単発新規＝エディタを完全ブランク（コピペ即開始）
  menus.file = false;

  appMode.value = 'single';
      projectHandle.value = null;
      currentFileHandle.value = null;
      currentFileName.value = '';
      projectDisplayName.value = '開発をはじめる';

      // ★ここが本題：テンプレを入れず空にする
  editor.setValue('');

  // identity / meta を空コードとして同期
  syncIdentityFromCode('');
  aiInstruction.value = '';
  saveComment.value = '';

// プレビューは「空コード」表示にする（エディタは空のまま）
    runEmulator();
  pushToast('単発新規', 'エディタを空にしました。ここにそのまま貼り付けできます。', 'fa-circle-check text-emerald-300', 2200);

  // 初心者向け誘導トースト
  setTimeout(() => {
    pushToast('💡 次のステップ', 'まずは「AI指示」ボタンから「全コード生成」を試してみましょう！', 'fa-robot text-purple-300', 4000);
  }, 1200);
};

    const openProjectFromList = async (fileItem) => {
      // 1. ファイルをロード
      await loadFile(fileItem.handle);

      // 2. そのプロジェクトフォルダを選択状態にする
      if (fileItem.projectDirHandle) {
        await setProject(fileItem.projectDirHandle, fileItem.projectName);
        
        // 3. モードを「このPJの履歴」に切り替え
        historyMode.value = 'flat';
        
        // 4. 新しいプロジェクトで履歴再スキャン
        await refreshLibrary();
        
        pushToast('プロジェクトを開きました', `${fileItem.projectName} に切り替えました。`, 'fa-folder-open text-blue-300');
      }
    };

    const loadFile = async (handle) => {
      const file = await handle.getFile();
      const text = await file.text();

      editor.setValue(text);
      currentFileName.value = handle.name;

      syncIdentityFromCode(text);

      // 新たに開いたときはリセット（引き継がない）
      aiInstruction.value = '';
      aiPromptInput.value = '';
      saveComment.value = '';

      runEmulator();
    };

    const runExternal = async (fileEntry) => {
      // fileEntry can be from grouped/flat, should include handle
      try{
        const file = await fileEntry.handle.getFile();
        const text = await file.text();
        const runId = genId();
        const shim = buildPreviewShim(runId);
        const safeCode = injectShimIntoHtml(text, shim);
        const blob = new Blob([safeCode], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        // 新規タブで開く (_blank)
        window.open(url, '_blank', 'noopener,noreferrer');
      } catch(e){
        alert("別窓実行に失敗: " + (e.message || String(e)));
      }
    };

    // --- COMPUTED: GROUPED HISTORY ---
    const libraryFilesFlat = computed(() => libraryFiles.value);

    const groupedApps = computed(() => {
      const map = new Map();
      for (const f of libraryFiles.value) {
        const key = f.groupKey || 'unknown';
        if (!map.has(key)) map.set(key, { groupKey: key, versions: [], open: false });
        map.get(key).versions.push(f);
      }

      const arr = Array.from(map.values()).map(grp => {
        const versions = grp.versions.slice().sort((a,b)=> (b.savedAt?.getTime?.()||0) - (a.savedAt?.getTime?.()||0));
        const latest = versions[0];
        const latestTitle = latest?.displayTitle || '';
        const latestAiInstruction = (latest?.meta?.aiInstruction || latest?.meta?.comment || '').trim();

        return {
          groupKey: grp.groupKey,
          open: grp.open,
          versions,
          latestTitle,
          latestAiInstruction
        };
      });

      arr.sort((a,b)=> {
        const at = a.versions[0]?.savedAt?.getTime?.()||0;
        const bt = b.versions[0]?.savedAt?.getTime?.()||0;
        return bt - at;
      });

      return arr;
    });

// --- SAVE LOGIC ---
    const openSaveModal = () => {
      // ①(蓄積)を②(初期値)に同期。ハンド修正(③)が空なら入れる。
      if (!saveComment.value && aiInstruction.value) {
        saveComment.value = aiInstruction.value;
      }

      const now = new Date();
      const ts =
        now.getFullYear() +
        (now.getMonth()+1).toString().padStart(2,'0') +
        now.getDate().toString().padStart(2,'0') + '_' +
        now.getHours().toString().padStart(2,'0') +
        now.getMinutes().toString().padStart(2,'0');

      let base = (currentAppTitle.value || 'App').replace(/[\\\/:*?"<>|]/g,'_').slice(0,40);
      if(!base) base = 'App';

      saveFilename.value = `${base}_${ts}.html`;

      // 単発アプリの場合は編集ログモーダルをスキップし、OS標準の保存ダイアログへ直行
      if (appMode.value === 'single') {
        performSave();
        return;
      }

      modals.save = true;
    };

    const performSave = async () => {
      try {
        let filename = saveFilename.value || 'App.html';
        if(!filename.toLowerCase().endsWith('.html')) filename += '.html';

        const rawCode = editor.getValue();
        const metaExisting = extractMeta(rawCode);

        const nowIso = new Date().toISOString();

                // Ensure identifiers
        const title = metaExisting.title || extractTitleFromHtml(rawCode) || currentAppTitle.value || 'App';

        // We keep appId stable if present; otherwise create (and set createdAt)
        const finalMeta = { ...metaExisting };
        
        // エディタが空でタグがない場合、メモリ上の現在の情報を引き継ぐ
        if (!finalMeta.appId && currentMeta.appId) finalMeta.appId = currentMeta.appId;
        if (!finalMeta.createdAt && currentMeta.createdAt) finalMeta.createdAt = currentMeta.createdAt;

        if (!finalMeta.appId) finalMeta.appId = genId();
        if (!finalMeta.createdAt) finalMeta.createdAt = nowIso;

        finalMeta.schema = 2;
        finalMeta.title = title;
        finalMeta.savedAt = nowIso;
        
        // ③が④に反映される（ハンド修正内容を正として両方に記録）
        const finalNote = (saveComment.value || '').trim();
        finalMeta.aiInstruction = finalNote;
        finalMeta.comment = finalNote;
        
        finalMeta.sourceMode = appMode.value;
        finalMeta.runId = lastRunId || '';

        const codeWithMeta = injectMeta(rawCode, finalMeta);

        if (appMode.value === 'project') {
          if(!projectHandle.value) throw new Error("プロジェクトが未選択です。");

          const newHandle = await projectHandle.value.getFileHandle(filename, { create: true });
          const writable = await newHandle.createWritable();
          await writable.write(codeWithMeta);
          await writable.close();

          currentFileName.value = filename;
          syncIdentityFromCode(codeWithMeta);

          await refreshLibrary();
          modals.save = false;
          // 保存完了でリセット
          saveComment.value = '';
          aiInstruction.value = '';
          aiPromptInput.value = '';

          editor.setValue(codeWithMeta);
          alert("保存しました（プロジェクト内）: " + filename);
          return;
        }

        if ('showSaveFilePicker' in window) {
          const picker = await window.showSaveFilePicker({
            suggestedName: filename,
            types: [{ description: 'HTML Files', accept: { 'text/html': ['.html', '.htm'] } }]
          });
          const writable = await picker.createWritable();
          await writable.write(codeWithMeta);
          await writable.close();

          currentFileHandle.value = picker;
          currentFileName.value = filename;
          projectDisplayName.value = filename + " (単発)";
          syncIdentityFromCode(codeWithMeta);

          modals.save = false;
          // 保存完了でリセット
          saveComment.value = '';
          aiInstruction.value = '';
          aiPromptInput.value = '';

          editor.setValue(codeWithMeta);
          alert("保存しました（指定先）: " + filename);
          return;
        }

        // Fallback download
        const blob = new Blob([codeWithMeta], {type: 'text/html'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();

        currentFileName.value = filename;
        projectDisplayName.value = filename + " (単発)";
        syncIdentityFromCode(codeWithMeta);

        modals.save = false;
        saveComment.value = '';
        aiInstruction.value = '';
        aiPromptInput.value = '';
        editor.setValue(codeWithMeta);
        alert("ダウンロードで保存しました: " + filename);

      } catch(e) {
        if(e.name !== 'AbortError') alert("保存失敗: " + (e.message || String(e)));
      }
    };

    // --- AI PROMPT ---
    const openAiModal = () => {
      modals.ai = true;
      aiMessage.value = '';
      aiPromptInput.value = ''; // 入力欄は常にクリア（過去の読込はしない）
    };

        const generateAndCopyPrompt = () => {
      const input = (aiPromptInput.value || '').trim();
      
      // ①: 蓄積 (複数ある場合は連結)
      if (input) {
        const sep = aiInstruction.value ? '\n\n' : '';
        aiInstruction.value = aiInstruction.value + sep + input;
      }
      // プロンプトには今回の入力を使う（空なら蓄積全体を使う）
      const baseInst = input || aiInstruction.value || '';
      const fullCode = editor ? editor.getValue() : '';

      // セキュリティ指示の構成
      let secNote = "";
      if (securitySettings.noFetch) secNote += "\n- [セキュリティ制約] 外部ウェブサイトからの情報取得禁止: CDNや外部APIからのfetchは絶対に行わないでください。外部リソース(画像等)はDataURIかプレースホルダを使用し、JSライブラリが必要な場合はコード内にバンドルできる小規模なもののみ書いてください。\n";
      if (securitySettings.noTransmit) secNote += "\n- [セキュリティ制約] 外部への情報伝送禁止: 外部サーバーへのデータ送信(POST/GET等)を含むコードは絶対に作成しないでください。localStorageやIndexedDBなどブラウザ内完結の保存機能のみ使用してください。\n";
      
      const inst = baseInst + (secNote ? ("\n\n[重要:セキュリティ設定]\n" + secNote) : "");

      const cdnRule = securitySettings.noFetch
         ? "- 外部ライブラリ(CDN)の使用は禁止します。必要なロジックはバニラJSで書くか、最小限のコードを内包してください。"
         : "- 外部ライブラリはCDN(Tailwind, Vue, React等)を使用してよい。";

            let prompt = "";
      if(aiTab.value === 'full') {
        const commonInst = `\n[出力形式]\n1. 冒頭に、修正箇所・制約条件・改善提案を簡潔なコメントで記述してください。\n2. その後、修正済みの完全なHTMLフルコードを出力してください。`;

        if (aiIncludeFullCode.value) {
          prompt =
`あなたはプロのWebエンジニアです。以下の現在のコードと指示に基づいて、単一のHTMLファイルで動作するウェブアプリを再構築（または新規作成）してください。

[現在のコード]
\`\`\`html
${fullCode}
\`\`\`

[指示]
${inst}

[制約]
- HTML, CSS, JSを一つのファイルにまとめること。
${cdnRule}
${commonInst}`; 
        } else {
          prompt =
`あなたはプロのWebエンジニアです。以下の指示に基づいて、単一のHTMLファイルで動作するウェブアプリを作成してください。

[指示]
${inst}

[制約]
- HTML, CSS, JSを一つのファイルにまとめること。
${cdnRule}
${commonInst}`; 
        }
            } else if (aiTab.value !== 'json') {
        const patchInst = `\n[重要：出力形式]\n私が手動でコードを置換しやすいように、以下の順序で出力してください。\n\n1. 修正方針・制約・改善案の簡潔な解説\n\n2. 変更コード（以下のフォーマット）\n\n★検索するコード (Search)\n\`\`\`\n(ここに置換対象となる、現在のコードのユニークな数行～ブロックをそのまま書く)\n\`\`\`\n\n★置換後のコード (Replace)\n\`\`\`\n(ここに新しく置き換えるコードを書く)\n\`\`\`\n`;
        if (aiIncludeFullCode.value) {
          prompt =
`あなたはコード修正のエキスパートです。以下のアプリコードの一部を修正してください。

[対象コード(全体)]
\`\`\`html
${fullCode}
\`\`\`

[修正指示]
${inst}
${patchInst}`; 
        } else {
          prompt =
`あなたはコード修正のエキスパートです。以下の修正指示に従って、既存アプリの一部修正パッチを作成してください。
（※コードはここでは添付しません。）

[修正指示]
${inst}
${patchInst}`; 
        }
      } else {
        // JSON Auto Mode
        const codeBlock = aiIncludeFullCode.value ? `[対象コード(全体)]\n\`\`\`html\n${fullCode}\n\`\`\`\n` : '';
        prompt =
`あなたはコード修正のエキスパートです。以下のアプリコードの一部を修正してください。

${codeBlock}
[修正指示]
${inst}

[重要：出力形式]
ツールで自動置換を行うため、以下の手順で出力してください。

1. まず、修正方針・制約・改善案を簡潔に解説してください。
2. 次に、コード置換用のJSONデータを **Markdownコードブロック(\`\`\`json ... \`\`\`)** で出力してください。

\`\`\`json
[
  {
    "search": "(置換対象となる、現在のコードのユニークな数行～ブロックをそのまま書く。改行コード含む)",
    "replace": "(新しく置き換えるコード)"
  },
  {
    "search": "...",
    "replace": "..."
  }
]
\`\`\`
`;
      }

      navigator.clipboard.writeText(prompt).then(() => {
        aiMessage.value = "📋 コピーしました！AIチャットに貼り付けてください。";
        setTimeout(() => aiMessage.value = '', 3000);
      });
    };

        // --- PATCH ---
    const openPatchModal = () => {
      // 直前のAI指示モードに合わせて初期タブを切り替え
      if (aiTab.value === 'json') {
        patchMode.value = 'json';
      } else {
        patchMode.value = 'manual';
      }

      patchFindInput.value = '';
      patchReplaceInput.value = '';
      patchJsonInput.value = '';
      patchIgnoreWhitespace.value = true;
      patchMatchCount.value = 0;
      patchMatchMessage.value = '';
      modals.patch = true;
    };

        const applyPatch = () => {
      try {
        const findTextRaw = patchFindInput.value;
        const replaceText = patchReplaceInput.value;

        if (!findTextRaw || !replaceText) {
          alert("検索コードと置換コードの両方を入力してください。");
          return;
        }

        const model = editor.getModel();
        const full = model.getValue();

        if (!patchIgnoreWhitespace.value) {
          const idx = full.indexOf(findTextRaw);
          if (idx === -1) { alert("一致する箇所が見つかりません（完全一致）。"); return; }
          const idx2 = full.indexOf(findTextRaw, idx + 1);
          if (idx2 !== -1) {
            alert("一致する箇所が複数あります。意図しない変更を防ぐため、より長いコードを指定して一意に定めてください。");
            return;
          }

          const startPos = model.getPositionAt(idx);
          const endPos = model.getPositionAt(idx + findTextRaw.length);
          const range = new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column);

          editor.executeEdits("manual-patch", [{ range, text: replaceText }]);
          modals.patch = false;
          runEmulator();
          alert("コードを置換しました！（完全一致）");
          return;
        }

        const { compact: compactFull, mapNormToOrig } = buildCompacted(full);
        const compactFind = normalizeFind(findTextRaw);
        if (!compactFind) { alert("検索コードが空白のみです。"); return; }

        const normIdx = compactFull.indexOf(compactFind);
        if (normIdx === -1) { alert("一致する箇所が見つかりません（空白無視）。"); return; }
        const normIdx2 = compactFull.indexOf(compactFind, normIdx + 1);
        if (normIdx2 !== -1) {
          alert("一致する箇所が複数あります（空白無視）。意図しない変更を防ぐため、より長いコードを指定して一意に定めてください。");
          return;
        }

        const startOrig = mapNormToOrig[normIdx];
        const endOrig = mapNormToOrig[normIdx + compactFind.length - 1] + 1;

        const startPos = model.getPositionAt(startOrig);
        const endPos = model.getPositionAt(endOrig);
        const range = new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column);

        editor.executeEdits("manual-patch", [{ range, text: replaceText }]);
        modals.patch = false;
        runEmulator();
        alert("コードを置換しました！（空白・改行は無視）");
      } catch (e) {
        alert("エラー: " + (e.message || String(e)));
      }
    };

            const applyAutoJsonPatch = () => {
      let items = [];
      try {
        let jsonStr = patchJsonInput.value.trim();
        const start = jsonStr.indexOf('[');
        const end = jsonStr.lastIndexOf(']');
        if (start !== -1 && end !== -1 && end > start) {
          jsonStr = jsonStr.substring(start, end + 1);
        } else {
          jsonStr = jsonStr.replace(/^```json/, '').replace(/^```/, '').replace(/```$/, '');
        }
        items = JSON.parse(jsonStr);
        if (!Array.isArray(items)) throw new Error("JSON is not an array");
      } catch(e) {
                alert("JSON解析エラー: " + e.message + "\n\n【💡 対応のヒント】\nAIの出力形式が崩れている可能性があります。\n\n● 方法A: 「①手動パッチ」モードに切り替え、コードを手動で書き換える\n● 方法B: 「①全コード生成」を選択し、コード全体を作り直して置き換える");
        return;
      }

            const model = editor.getModel();
      const full = model.getValue();
      const edits = [];
      let entityAdjusted = false;
      
      let compactData = null;
      if (patchIgnoreWhitespace.value) {
        compactData = buildCompacted(full);
      }

      // Helper: Entity conversion
      const decodeEnt = (s) => s.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&amp;/g, '&').replace(/&#039;/g, "'");
      const encodeEnt = (s) => s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');

      for (const item of items) {
        if (!item.search || typeof item.replace !== 'string') continue;

        // Generate candidates to handle entity fluctuations
        const raw = item.search;
        const cands = new Set([raw, decodeEnt(raw), decodeEnt(decodeEnt(raw)), encodeEnt(raw)]);
        
        let bestCand = null;
        let bestRange = null;
        let totalMatches = 0;

        for (const cand of cands) {
            let ranges = [];
            if (!patchIgnoreWhitespace.value) {
                // Exact match
                let pos = 0;
                while(true) {
                    const idx = full.indexOf(cand, pos);
                    if (idx === -1) break;
                    ranges.push({ s: idx, e: idx + cand.length });
                    pos = idx + 1;
                }
            } else {
                // Ignore whitespace
                const { compact: compactFull, mapNormToOrig } = compactData;
                const compactFind = normalizeFind(cand);
                if (!compactFind) continue;

                let idx = 0;
                while(true) {
                    const p = compactFull.indexOf(compactFind, idx);
                    if (p === -1) break;
                    const s = mapNormToOrig[p];
                    const e = mapNormToOrig[p + compactFind.length - 1] + 1;
                    ranges.push({ s, e });
                    idx = p + 1;
                }
            }

            if (ranges.length > 0) {
                totalMatches += ranges.length;
                if (ranges.length === 1) {
                    bestCand = cand;
                    const startPos = model.getPositionAt(ranges[0].s);
                    const endPos = model.getPositionAt(ranges[0].e);
                    bestRange = new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column);
                }
            }
        }

        if (totalMatches === 0) {
                        alert(`以下のコードが見つかりませんでした (処理中止):\n\n${raw.slice(0, 100)}...\n\n【💡 対応のヒント】\nAIが古いコードを参照しているか、ハルシネーションの可能性があります。\n\n● 方法A: 「①手動パッチ」で該当箇所を探して書き換える\n● 方法B: 「①全コード生成」で全体を作り直す`);
            return;
        }
        if (totalMatches > 1) {
                          alert(`以下のコードが複数箇所見つかりました (処理中止):\n\n${raw.slice(0, 100)}...\n\n検索コードを長くして一意に特定してください。\n\n【💡 対応のヒント】\n解決しない場合は「①手動パッチ」で該当箇所を目視確認しながら修正するのが確実です。`);
             return;
        }

        // Single unique match found!
        let finalReplace = item.replace;

                // Adjust replace text to match the found candidate's entity style
        if (bestCand !== raw) {
            entityAdjusted = true;
            if (bestCand === decodeEnt(raw)) finalReplace = decodeEnt(finalReplace);
            else if (bestCand === encodeEnt(raw)) finalReplace = encodeEnt(finalReplace);
            else if (bestCand === decodeEnt(decodeEnt(raw))) finalReplace = decodeEnt(decodeEnt(finalReplace));
        }

        edits.push({ range: bestRange, text: finalReplace });
      }
      
      if (edits.length === 0) {
                alert("適用するパッチがありませんでした。\n\n【💡 対応のヒント】\n自動置換がうまくいかない場合は、以下の方法をお試しください。\n\n● 方法A: 「①手動パッチ」モードを使う\n● 方法B: 「①全コード生成」でコード全体を作り直す");
        return;
      }
      
            editor.executeEdits("auto-json-patch", edits);
      modals.patch = false;
      runEmulator();
      const msg = `${edits.length}箇所の修正を自動適用しました！` + (entityAdjusted ? "\n(エンティティ揺らぎを自動補正)" : "");
      alert(msg);
    };

    // --- PREVIEW SHIM (console + idb dump) ---
    const buildPreviewShim = (runId) => {
      return `
<script>
(() => {
  const RUN_ID = ${JSON.stringify(runId)};
  const send = (obj) => { try { window.parent?.postMessage(obj, "*"); } catch(e){} };

  const _log = console.log.bind(console);
  const _err = console.error.bind(console);
  const _warn = console.warn.bind(console);
  console.log = (...a)=>{ _log(...a); send({ type: "console", l: "info", m: a.map(x=>{try{return typeof x==="string"?x:JSON.stringify(x)}catch(e){return String(x)}}).join(" ") }); };
  console.error = (...a)=>{ _err(...a); send({ type: "console", l: "error", m: a.map(x=>{try{return typeof x==="string"?x:JSON.stringify(x)}catch(e){return String(x)}}).join(" ") }); };
  console.warn = (...a)=>{ _warn(...a); send({ type: "console", l: "warn", m: a.map(x=>{try{return typeof x==="string"?x:JSON.stringify(x)}catch(e){return String(x)}}).join(" ") }); };

  async function dumpIdb() {
    const items = [];
    const databasesFn = indexedDB.databases ? indexedDB.databases.bind(indexedDB) : null;
    if (!databasesFn) {
      return { items: [], warning: "indexedDB.databases() が未対応のため、DB一覧は取得できません。" };
    }
    const dbs = await databasesFn();
    for (const d of (dbs||[])) {
      const name = d.name;
      const version = d.version || 0;
      if (!name) continue;

      const info = { name, version, stores: [], open: true };

      await new Promise((resolve) => {
        const req = indexedDB.open(name);
        req.onerror = () => resolve();
        req.onsuccess = () => {
          const db = req.result;
          try {
            info.version = db.version || info.version;
            const storeNames = Array.from(db.objectStoreNames || []);
            const tx = db.transaction(storeNames, "readonly");
            const storeInfos = [];

            let pending = storeNames.length;
            if (pending === 0) { try{db.close()}catch(e){}; info.stores = []; resolve(); return; }

            storeNames.forEach(sn => {
              try {
                const st = tx.objectStore(sn);
                const stInfo = {
                  name: sn,
                  keyPath: st.keyPath ?? null,
                  autoIncrement: !!st.autoIncrement,
                  count: 0,
                  sampleKeys: []
                };

                const cReq = st.count();
                cReq.onsuccess = () => { stInfo.count = cReq.result || 0; maybeDone(); };
                cReq.onerror = () => { maybeDone(); };

                const keys = [];
                const kReq = st.openKeyCursor();
                kReq.onsuccess = (ev) => {
                  const cur = ev.target.result;
                  if (cur && keys.length < 20) { keys.push(cur.key); cur.continue(); }
                  else { stInfo.sampleKeys = keys; }
                };
                kReq.onerror = () => {};

                storeInfos.push(stInfo);
              } catch(e) {
                pending = Math.max(0, pending - 1);
              }
            });

            function maybeDone(){
              pending = Math.max(0, pending - 1);
              if (pending === 0) {
                info.stores = storeInfos.sort((a,b)=>String(a.name).localeCompare(String(b.name)));
                try { db.close(); } catch(e){}
                resolve();
              }
            }
          } catch(e) {
            try { db.close(); } catch(_){}
            resolve();
          }
        };
      });

      items.push(info);
    }

    items.sort((a,b)=>String(a.name).localeCompare(String(b.name)));
    return { items };
  }

  window.addEventListener("message", async (ev) => {
    const data = ev.data || {};
    if (data.type === "idb_dump_request" && data.runId === RUN_ID) {
      try {
        const res = await dumpIdb();
        send({ type: "idb_dump_result", runId: RUN_ID, items: res.items || [], error: res.warning || "" });
      } catch(e) {
        send({ type: "idb_dump_result", runId: RUN_ID, items: [], error: String(e && e.message ? e.message : e) });
      }
    }
  });
})();
<\/script>`;
    };

    const injectShimIntoHtml = (code, shim) => {
      if (code.match(/<head[^>]*>/i)) return code.replace(/<head[^>]*>/i, (m)=> m + shim);
      return shim + code;
    };

    // --- PREVIEW (iframe) ---
const runEmulator = () => {
  if(!editor) return;

  const frame = document.getElementById('emulator-frame');
  const code = editor.getValue() || '';
  syncIdentityFromCode(code);

  lastRunId = genId();
  const shim = buildPreviewShim(lastRunId);

  // ★空コードの場合：エディタは空のまま、プレビューだけ説明表示
  if (code.trim() === '') {
    const emptyHtml =
`<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>(empty)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:0; display:grid; place-items:center; height:100vh; background:#f3f4f6; color:#111827;}
  .card{background:#fff; border:1px solid #e5e7eb; border-radius:16px; padding:18px 16px; width:min(92vw,520px); box-shadow:0 10px 24px rgba(0,0,0,.08);}
  h1{font-size:16px; margin:0 0 6px;}
  p{font-size:12px; margin:0; color:#6b7280; line-height:1.6;}
  code{background:#f9fafb; border:1px solid #e5e7eb; padding:2px 6px; border-radius:8px;}
</style>
</head>
<body>
  <div class="card">
    <h1>プレビュー：コードが空です</h1>
    <p>エディタは <b>完全に空</b> の状態です。<br>そのままHTMLを貼り付けて <code>実行</code> してください。</p>
  </div>
</body>
</html>`;
    const safe = injectShimIntoHtml(emptyHtml, shim);
    frame.srcdoc = safe;
    return;
  }

  const safeCode = injectShimIntoHtml(code, shim);
  frame.srcdoc = safeCode;
};


    const stopEmulator = () => {
      const frame = document.getElementById('emulator-frame');
      frame.src = 'about:blank';
      consoleLogs.value.push({type:'info', message:'プレビューを停止しました。'});

      if (fullWin && !fullWin.closed) {
        try { fullWin.close(); } catch {}
      }
      fullWin = null;
    };

    // --- FULLSCREEN (separate window) ---
    const openFullWindow = () => {
      if(!editor) return;

      const code = editor.getValue();
      syncIdentityFromCode(code);

      const runId = genId();
      const shim = buildPreviewShim(runId);
      const safeCode = injectShimIntoHtml(code, shim);

      const blob = new Blob([safeCode], { type: 'text/html' });
      const url = URL.createObjectURL(blob);

      // 常に新規タブで開く (_blank)
      // ※一部環境で開いているのにwinがnull判定されるケースがあるため、アラート判定は削除
      window.open(url, '_blank', 'noopener,noreferrer');
    };

        // --- DB MODAL ---
    const openDbModal = async () => {
      if (!confirm("【注意】\nIndexedDB簡易表示は現在、機能が不完全なため停止推奨となっています。\n\n無理に実行するとブラウザがフリーズする可能性がありますが、それでも実行しますか？")) return;

      modals.db = true;
      await refreshDbDump();
    };

    const refreshDbDump = async () => {
      dbDump.loading = true;
      dbDump.error = '';
      dbDump.items = [];

      const frame = document.getElementById('emulator-frame');
      if (!frame || !frame.contentWindow) {
        dbDump.loading = false;
        dbDump.error = "プレビューが起動していません。先に「実行」してください。";
        return;
      }
      if (!lastRunId) {
        dbDump.loading = false;
        dbDump.error = "runId が未設定です。いったん「実行」を押してください。";
        return;
      }

      try {
        frame.contentWindow.postMessage({ type: 'idb_dump_request', runId: lastRunId }, '*');
        setTimeout(() => {
          if (dbDump.loading) {
            dbDump.loading = false;
            dbDump.error = "タイムアウトしました。プレビュー側が応答しませんでした。";
          }
        }, 4000);
      } catch(e) {
        dbDump.loading = false;
        dbDump.error = "DB取得に失敗: " + (e.message || String(e));
      }
    };

    // --- OTHER HELPERS ---
const clearCode = () => {
      if(!confirm("本当にコードを全消去しますか？")) return;

      // エディタを完全に空にする
      editor.setValue('');

      // 内部状態のリセット（メタ情報やAI指示もクリア）
      syncIdentityFromCode('');
      aiInstruction.value = '';
      saveComment.value = '';

      // プレビューとトースト通知
      runEmulator();
      pushToast('全クリア', 'エディタを空にしました。', 'fa-trash-alt text-red-300', 1500);
    };
    const copyFullCode = async () => {
      try{
        await navigator.clipboard.writeText(editor.getValue());
        pushToast('コピーしました', 'フルコードをクリップボードにコピーしました。', 'fa-circle-check text-emerald-300', 1600);
      }catch(e){
        alert("コピー失敗: " + (e.message || String(e)));
      }
    };

    const toggleSidebar = () => { isSidebarOpen.value = !isSidebarOpen.value; };

    // --- RESIZE ---
    let resizing = false;
    const startResize = (e) => {
      resizing = true;
      const editorPane = document.getElementById('editor-pane');
      const emulatorPane = document.getElementById('emulator-pane');
      const root = editorPane.parentElement;

      const onMove = (ev) => {
        if(!resizing) return;
        const rect = root.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const w = rect.width;
        const left = Math.max(260, Math.min(w - 260, x));
        editorPane.style.flex = 'none';
        emulatorPane.style.flex = 'none';
        editorPane.style.width = left + 'px';
        emulatorPane.style.width = (w - left - 6) + 'px';
      };
      const onUp = () => {
        resizing = false;
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
      };

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    };

    return {
      // state
      appMode, projectDisplayName, menus, modals, isSidebarOpen,
      aiTab, aiInstruction, aiPromptInput, aiMessage, aiIncludeFullCode,
          saveComment, saveFilename,
      patchMode, patchFindInput, patchReplaceInput, patchJsonInput, patchIgnoreWhitespace,
      patchMatchCount, patchMatchMessage,
      applyAutoJsonPatch,
      deviceModes, currentDevice,
      findUI, findInputEl, replaceInputEl,
            editorStats, consoleLogs,
      libraryFiles, libraryFilesFlat, groupedApps, historyMode,
      currentAppTitle, currentGroupKey, libraryScanStatus,
      hoveredHistory, showHistoryDetail, hideHistoryDetail,

      // actions
      toggleSidebar,
      createNewProject, openProjectFolder, openSingleFile, createNewSingleApp,
      refreshLibrary, revealCurrentFolder,
      loadFile, runExternal,
      runEmulator, stopEmulator, openFullWindow,
      openAiModal, generateAndCopyPrompt,
      openSaveModal, performSave,
      openPatchModal, applyPatch,
      openDbModal, refreshDbDump,
      openFindReplace, closeFindReplace,
      startDragFindUI,
      findNext, findPrev, replaceOne, replaceAll, recomputeMatchCount,
      clearCode, copyFullCode,
      startResize,
            toasts,
      projectRootHandle, setProjectRoot,
      securitySettings, saveSecuritySettings,
      markHelpSeen
    };
  }
}).mount('#app');
</script>
</body>
</html>