<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, viewport-fit=cover, user-scalable=no"/>
<title>Taiko Sim / å¤ªé¼“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆã‚¬ã‚¤ãƒ‰æ¼”å¥ã¤ãï¼‰</title>
<style>
  :root{
    --bg0:#070a10; --bg1:#0b1220;
    --card:#121826cc; --line:#243047;
    --ink:#e8eefc; --muted:#a7b0c2;
    --pri:#4da3ff; --ok:#17c964; --warn:#ffb020; --danger:#ff4d4f;
    --shadow: 0 14px 34px rgba(0,0,0,.35);
    --r:16px;
    --pad:14px;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; color:var(--ink); font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;}
  body{
    background: radial-gradient(1200px 800px at 30% 10%, #14223f 0%, transparent 60%),
                linear-gradient(180deg, var(--bg0), var(--bg1));
    overflow:hidden;
  }
  .wrap{position:fixed; inset:0; display:flex; flex-direction:column;}
  header{
    padding: max(env(safe-area-inset-top), 10px) var(--pad) 10px var(--pad);
    display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  .title{display:flex; flex-direction:column; gap:2px; min-width:0;}
  .title b{font-size:15px; letter-spacing:.3px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .title span{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .chiprow{display:flex; flex-wrap:wrap; gap:8px; justify-content:flex-end; align-items:center;}
  .chip{
    border:1px solid var(--line);
    background: #0f1524cc;
    padding:8px 10px; border-radius:999px;
    display:flex; align-items:center; gap:8px;
    box-shadow: var(--shadow);
    user-select:none;
  }
  .chip label{font-size:12px; color:var(--muted)}
  select, input[type="range"], input[type="file"]{
    accent-color: var(--pri);
  }
  select{
    background:#0b1220; color:var(--ink);
    border:1px solid var(--line); border-radius:10px;
    padding:6px 8px; font-size:12px;
  }
  .btn{
    border:1px solid var(--line);
    background: linear-gradient(180deg, #1a2b4d, #0f1524);
    color:var(--ink);
    padding:10px 12px; border-radius:12px;
    box-shadow: var(--shadow);
    font-weight:700; font-size:12.5px;
    cursor:pointer;
    user-select:none;
    touch-action: manipulation;
  }
  .btn:active{transform: translateY(1px)}
  .btn.primary{border-color:#2c67a8; background: linear-gradient(180deg, #2e7ad0, #1b3f72);}
  .btn.danger{border-color:#7a2e34; background: linear-gradient(180deg, #8f3640, #3b1c22);}
  .btn.ghost{background: #0f1524cc;}
  main{flex:1; position:relative;}
  canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}
  .hud{
    position:absolute; left:var(--pad); right:var(--pad); bottom:max(env(safe-area-inset-bottom), 12px);
    display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end; justify-content:space-between;
    pointer-events:none;
  }
  .panel{
    pointer-events:auto;
    background: var(--card);
    border:1px solid var(--line);
    border-radius: var(--r);
    box-shadow: var(--shadow);
    padding: 10px 12px;
    min-width: 220px;
  }
  .panel h3{margin:0 0 6px 0; font-size:12.5px; color:var(--muted); font-weight:700;}
  .row{display:flex; align-items:center; justify-content:space-between; gap:10px;}
  .kpis{display:flex; gap:10px; flex-wrap:wrap;}
  .kpi{
    background:#0b1220aa;
    border:1px solid var(--line);
    border-radius: 14px;
    padding: 8px 10px;
    min-width: 92px;
  }
  .kpi small{display:block; color:var(--muted); font-weight:700; font-size:11px;}
  .kpi b{display:block; font-size:16px; margin-top:2px;}
  .hint{
    position:absolute; top:64px; left:50%; transform:translateX(-50%);
    padding: 8px 12px;
    border:1px solid var(--line);
    background:#0f1524cc;
    border-radius:999px;
    box-shadow: var(--shadow);
    font-size:12px; color:var(--muted);
    user-select:none;
  }
  .toast{
    position:absolute; top:110px; left:50%; transform:translateX(-50%);
    padding: 10px 14px;
    border-radius: 14px;
    border:1px solid var(--line);
    background:#0b1220ee;
    box-shadow: var(--shadow);
    font-weight:900;
    opacity:0; pointer-events:none;
    transition: opacity .15s ease, transform .15s ease;
    white-space:nowrap;
  }
  .toast.show{opacity:1; transform:translateX(-50%) translateY(-4px);}
  .toast.good{border-color:#2a5; color:#caffd8;}
  .toast.ok{border-color:#bb7; color:#fff4cc;}
  .toast.bad{border-color:#a33; color:#ffd2d2;}
  .overlay{
    position:absolute; inset:0;
    background: radial-gradient(900px 650px at 50% 35%, rgba(26,48,90,.92), rgba(8,10,16,.95));
    display:none;
    align-items:center; justify-content:center;
    padding: 18px;
  }
  .overlay.show{display:flex;}
  .modal{
    width:min(720px, 100%);
    background:#0b1220f2;
    border:1px solid var(--line);
    border-radius: 20px;
    box-shadow: var(--shadow);
    padding: 16px 16px 14px;
  }
  .modal h2{margin:0 0 6px 0; font-size:16px;}
  .modal p{margin: 8px 0; color:var(--muted); line-height:1.5; font-size:13px;}
  .grid{
    display:grid; grid-template-columns: repeat(2, minmax(0,1fr));
    gap:10px;
  }
  .card{
    background:#0f1524cc; border:1px solid var(--line);
    border-radius: 16px;
    padding: 10px 12px;
  }
  .card b{display:block; font-size:13px;}
  .card span{display:block; color:var(--muted); font-size:12px; margin-top:4px; line-height:1.4;}
  .footer{display:flex; justify-content:flex-end; gap:10px; margin-top:12px;}
  .small{font-size:12px; color:var(--muted);}
  @media (max-width: 520px){
    .panel{min-width: 100%;}
    header{flex-direction:column; align-items:stretch;}
    .chiprow{justify-content:flex-start;}
    .hint{top:86px;}
    .toast{top:132px;}
    .grid{grid-template-columns: 1fr;}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">
      <b>Taiko Sim / å¤ªé¼“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</b>
      <span>ä¸­å¿ƒ=Don / ç¸=Kaï½œã‚¬ã‚¤ãƒ‰è­œé¢ã«åˆã‚ã›ã¦å©ã“ã†ï¼ˆiOSã¯æœ€åˆã«ã€ŒéŸ³å£°è§£éŒ ã€ï¼‰</span>
    </div>

    <div class="chiprow">
      <div class="chip">
        <label>ãƒ¢ãƒ¼ãƒ‰</label>
        <select id="modeSel">
          <option value="free">ãƒ•ãƒªãƒ¼æ¼”å¥</option>
          <option value="guide">ã‚¬ã‚¤ãƒ‰æ¼”å¥ï¼ˆè­œé¢ï¼‰</option>
        </select>
      </div>

      <div class="chip">
        <label>ãƒ‘ã‚¿ãƒ¼ãƒ³</label>
        <select id="patSel"></select>
      </div>

      <div class="chip">
        <label>BPM</label>
        <input id="bpm" type="range" min="60" max="180" value="110"/>
        <span id="bpmTxt" style="font-size:12px; min-width:38px; text-align:right;">110</span>
      </div>

      <button id="unlockBtn" class="btn ghost" title="iOSã¯å¿…é ˆ">ğŸ”Š éŸ³å£°è§£éŒ </button>
      <button id="startBtn" class="btn primary">â–¶ é–‹å§‹</button>
      <button id="stopBtn" class="btn danger" style="display:none;">â–  åœæ­¢</button>
      <button id="helpBtn" class="btn ghost">ï¼Ÿ ä½¿ã„æ–¹</button>
    </div>
  </header>

  <main>
    <canvas id="cv"></canvas>
    <div class="hint" id="hint">ã‚¿ãƒƒãƒ—ã§å©ãï¼šä¸­å¿ƒ=Don / ç¸=Kaï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼šF/J=Don, D/K=Kaï¼‰</div>
    <div class="toast" id="toast">Perfect</div>

    <div class="hud">
      <div class="panel">
        <h3>ã‚µã‚¦ãƒ³ãƒ‰ / BGM</h3>
        <div class="row" style="margin-bottom:8px;">
          <div class="kpi" style="min-width:120px;">
            <small>å¤ªé¼“ éŸ³é‡</small>
            <input id="volDrum" type="range" min="0" max="1" step="0.01" value="0.9" style="width:100%;">
          </div>
          <div class="kpi" style="min-width:120px;">
            <small>BGM éŸ³é‡</small>
            <input id="volBgm" type="range" min="0" max="1" step="0.01" value="0.5" style="width:100%;">
          </div>
        </div>
        <div class="row">
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <label class="small"><input id="bgmOn" type="checkbox" checked> BGM ON</label>
            <select id="bgmType">
              <option value="synth">å†…è”µï¼ˆç¥­ã‚Šé¢¨ã‚·ãƒ³ã‚»ï¼‰</option>
              <option value="file">éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆèª­è¾¼ï¼‰</option>
              <option value="met">ãƒ¡ãƒˆãƒ­ãƒãƒ¼ãƒ ã®ã¿</option>
            </select>
          </div>
        </div>
        <div id="bgmFileWrap" style="margin-top:8px; display:none;">
          <input id="bgmFile" type="file" accept="audio/*" style="width:100%;">
          <div class="small" style="margin-top:6px;">â€»ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç«¯æœ«å†…ã§ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¦å†ç”Ÿï¼ˆå¤–éƒ¨é€ä¿¡ãªã—ï¼‰</div>
        </div>
      </div>

      <div class="panel">
        <h3>ã‚¬ã‚¤ãƒ‰æˆç¸¾ï¼ˆã‚¬ã‚¤ãƒ‰æ¼”å¥æ™‚ï¼‰</h3>
        <div class="kpis">
          <div class="kpi"><small>ã‚¹ã‚³ã‚¢</small><b id="scoreTxt">0</b></div>
          <div class="kpi"><small>ã‚³ãƒ³ãƒœ</small><b id="comboTxt">0</b></div>
          <div class="kpi"><small>åˆ¤å®š</small><b id="judgeTxt">-</b></div>
        </div>
      </div>
    </div>

    <div class="overlay" id="overlay">
      <div class="modal">
        <h2>ä½¿ã„æ–¹</h2>
        <p>
          ç”»é¢ã®å¤ªé¼“ã‚’ã‚¿ãƒƒãƒ—ã—ã¦æ¼”å¥ã§ãã¾ã™ã€‚<br>
          <b>ä¸­å¿ƒï¼ˆçš®ï¼‰= Don</b> / <b>ç¸ï¼ˆãƒªãƒ ï¼‰= Ka</b>ã€‚ã‚¬ã‚¤ãƒ‰æ¼”å¥ã§ã¯ä¸Šã‹ã‚‰ãƒãƒ¼ãƒ„ãŒè½ã¡ã¦ãã‚‹ã®ã§ã€ãƒ©ã‚¤ãƒ³ã«é‡ãªã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å©ã„ã¦ãã ã•ã„ã€‚
        </p>
        <div class="grid">
          <div class="card">
            <b>iPhone / iPadã®æ³¨æ„</b>
            <span>æœ€åˆã« <b>ğŸ”Š éŸ³å£°è§£éŒ </b> ã‚’æŠ¼ã—ã¦ã‹ã‚‰é–‹å§‹ã—ã¦ãã ã•ã„ï¼ˆiOSã®éŸ³å£°åˆ¶é™å¯¾ç­–ï¼‰ã€‚</span>
          </div>
          <div class="card">
            <b>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰</b>
            <span><b>F / J</b> = Donã€<b>D / K</b> = Kaï¼ˆPCã§ç·´ç¿’ã«ä¾¿åˆ©ï¼‰</span>
          </div>
          <div class="card">
            <b>BGM</b>
            <span>å†…è”µã‚·ãƒ³ã‚» or éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§å†ç”Ÿã§ãã¾ã™ã€‚ã‚¬ã‚¤ãƒ‰ã¨åŒæ™‚ã«é³´ã‚‰ã›ã¾ã™ã€‚</span>
          </div>
          <div class="card">
            <b>ãƒ‘ã‚¿ãƒ¼ãƒ³</b>
            <span>ã€ŒåŸºæœ¬ãƒªã‚ºãƒ ã€ä¸­å¿ƒã®ç·´ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åéŒ²ï¼ˆä¼çµ±çš„æ¼”å¥ã®é›°å›²æ°—ã‚’å†ç¾ï¼‰ã€‚</span>
          </div>
        </div>
        <div class="footer">
          <button class="btn ghost" id="closeHelp">é–‰ã˜ã‚‹</button>
        </div>
      </div>
    </div>

  </main>
</div>

<script>
(() => {
  // ====== Utilities ======
  const $ = (id) => document.getElementById(id);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const now = ()=> (audioCtx ? audioCtx.currentTime : performance.now()/1000);
  const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints>0;

  // ====== Canvas ======
  const cv = $("cv");
  const ctx2d = cv.getContext("2d", { alpha:true });
  let W=0,H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
    W = Math.floor(cv.clientWidth * DPR);
    H = Math.floor(cv.clientHeight * DPR);
    cv.width = W; cv.height = H;
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  // ====== Audio ======
  let audioCtx = null;
  let master = null, drumBus=null, bgmBus=null;
  let bgmBuffer = null;
  let bgmSource = null;
  let metOn = false;

  function ensureAudio(){
    if(audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC({ latencyHint:"interactive" });
    master = audioCtx.createGain(); master.gain.value = 0.95;
    drumBus = audioCtx.createGain(); drumBus.gain.value = parseFloat($("volDrum").value);
    bgmBus  = audioCtx.createGain();  bgmBus.gain.value  = parseFloat($("volBgm").value);
    drumBus.connect(master);
    bgmBus.connect(master);
    master.connect(audioCtx.destination);
  }

  async function unlockAudio(){
    ensureAudio();
    // iOS unlock: resume + play tiny silent tick
    try{ await audioCtx.resume(); }catch(e){}
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.00001, t+0.03);
    osc.frequency.value = 440;
    osc.connect(g).connect(master);
    osc.start(t); osc.stop(t+0.03);
    toast("ğŸ”“ Audio unlocked", "good", 900);
  }

  function setDrumVol(v){ if(drumBus) drumBus.gain.value = v; }
  function setBgmVol(v){ if(bgmBus) bgmBus.gain.value = v; }

  $("volDrum").addEventListener("input", e=>setDrumVol(parseFloat(e.target.value)));
  $("volBgm").addEventListener("input", e=>setBgmVol(parseFloat(e.target.value)));

  // ====== Drum Synth ======
  function drumDon(t, vel=1){
    // low body + noisy slap
    const dur = 0.22;
    const body = audioCtx.createOscillator();
    const bodyGain = audioCtx.createGain();
    body.type = "sine";
    body.frequency.setValueAtTime(165, t);
    body.frequency.exponentialRampToValueAtTime(80, t+dur);

    bodyGain.gain.setValueAtTime(0.0001, t);
    bodyGain.gain.exponentialRampToValueAtTime(0.9*vel, t+0.008);
    bodyGain.gain.exponentialRampToValueAtTime(0.0001, t+dur);

    // Noise
    const noiseBuf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.12), audioCtx.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for(let i=0;i<data.length;i++){
      const x = (Math.random()*2-1);
      data[i] = x * (1 - i/data.length);
    }
    const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuf;
    const bp = audioCtx.createBiquadFilter();
    bp.type="bandpass"; bp.frequency.value=1400; bp.Q.value=0.8;
    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(0.0001, t);
    ng.gain.exponentialRampToValueAtTime(0.55*vel, t+0.004);
    ng.gain.exponentialRampToValueAtTime(0.0001, t+0.08);

    // Gentle saturation
    const sh = audioCtx.createWaveShaper();
    sh.curve = makeSaturationCurve(420);
    sh.oversample = "2x";

    body.connect(bodyGain);
    noise.connect(bp); bp.connect(ng);
    bodyGain.connect(sh);
    ng.connect(sh);
    sh.connect(drumBus);

    body.start(t); body.stop(t+dur+0.01);
    noise.start(t); noise.stop(t+0.12);
  }

  function drumKa(t, vel=1){
    // rim: higher, short, clicky
    const dur=0.09;
    const osc = audioCtx.createOscillator();
    osc.type="triangle";
    osc.frequency.setValueAtTime(680, t);
    osc.frequency.exponentialRampToValueAtTime(480, t+dur);

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.55*vel, t+0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);

    // tiny noise click
    const noiseBuf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.04), audioCtx.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for(let i=0;i<data.length;i++){
      data[i] = (Math.random()*2-1) * (1 - i/data.length);
    }
    const noise = audioCtx.createBufferSource(); noise.buffer=noiseBuf;
    const hp = audioCtx.createBiquadFilter();
    hp.type="highpass"; hp.frequency.value=2400;
    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(0.0001, t);
    ng.gain.exponentialRampToValueAtTime(0.35*vel, t+0.002);
    ng.gain.exponentialRampToValueAtTime(0.0001, t+0.02);

    const sh = audioCtx.createWaveShaper();
    sh.curve = makeSaturationCurve(260);
    sh.oversample = "2x";

    osc.connect(g);
    noise.connect(hp); hp.connect(ng);
    g.connect(sh); ng.connect(sh);
    sh.connect(drumBus);

    osc.start(t); osc.stop(t+dur+0.02);
    noise.start(t); noise.stop(t+0.04);
  }

  function makeSaturationCurve(k=400){
    const n=1024, curve=new Float32Array(n);
    for(let i=0;i<n;i++){
      const x = (i/(n-1))*2-1;
      curve[i] = (1+k)*x/(1+k*Math.abs(x));
    }
    return curve;
  }

  // ====== BGM ======
  function stopBgm(){
    if(bgmSource){
      try{ bgmSource.stop(); }catch(e){}
      try{ bgmSource.disconnect(); }catch(e){}
      bgmSource = null;
    }
  }

  function startBgm(startTime){
    if(!$("bgmOn").checked) return;
    const type = $("bgmType").value;
    stopBgm();
    metOn = (type === "met");

    if(type === "file"){
      if(!bgmBuffer){
        toast("BGMãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„", "ok", 1200);
        return;
      }
      const src = audioCtx.createBufferSource();
      src.buffer = bgmBuffer;
      src.loop = true;
      src.connect(bgmBus);
      src.start(startTime);
      bgmSource = src;
      return;
    }

    if(type === "synth"){
      // Festival-ish pentatonic backing (simple "ç¬›é¢¨" lead + soft pad)
      const bpm = getBpm();
      const beatDur = 60/bpm;
      const seqLenBeats = 16;
      const base = 440; // A4
      const scale = [0,3,5,7,10,12]; // minor pentatonic-ish
      const pattern = [0,2,3,2, 0,2,4,2, 0,2,3,5, 4,2,0,2];

      // We'll schedule a rolling synth with a Script-like scheduler (lookahead)
      const sched = {
        nextIdx: 0,
        nextTime: startTime,
        running: true
      };

      const pad = audioCtx.createOscillator();
      pad.type="sine";
      const padGain = audioCtx.createGain();
      padGain.gain.value = 0.06;
      pad.frequency.setValueAtTime(110, startTime);
      pad.connect(padGain).connect(bgmBus);
      pad.start(startTime);

      const noise = audioCtx.createBufferSource();
      noise.buffer = (() => {
        const b = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.5), audioCtx.sampleRate);
        const d = b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.25;
        return b;
      })();
      noise.loop = true;
      const nFilt = audioCtx.createBiquadFilter();
      nFilt.type="bandpass"; nFilt.frequency.value=900; nFilt.Q.value=0.7;
      const nGain = audioCtx.createGain();
      nGain.gain.value = 0.015;
      noise.connect(nFilt).connect(nGain).connect(bgmBus);
      noise.start(startTime);

      bgmSource = { stop: () => {
        sched.running=false;
        try{ pad.stop(); }catch(e){}
        try{ noise.stop(); }catch(e){}
      }};

      function scheduleLeadNote(t, semis, lenBeats, vel){
        const o = audioCtx.createOscillator();
        o.type="triangle";
        const g = audioCtx.createGain();
        const f = base * Math.pow(2, semis/12);
        o.frequency.setValueAtTime(f, t);
        // flute-ish filter
        const lp = audioCtx.createBiquadFilter();
        lp.type="lowpass"; lp.frequency.value=2200; lp.Q.value=0.2;

        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.15*vel, t+0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t+lenBeats*beatDur*0.85);

        o.connect(lp).connect(g).connect(bgmBus);
        o.start(t);
        o.stop(t+lenBeats*beatDur+0.03);
      }

      function tick(){
        if(!sched.running) return;
        const tNow = audioCtx.currentTime;
        while(sched.nextTime < tNow + 0.18){
          const i = sched.nextIdx % seqLenBeats;
          const deg = pattern[i];
          const semis = scale[deg % scale.length];
          const vel = (i%4===0) ? 1.0 : 0.7;
          scheduleLeadNote(sched.nextTime, semis, 1, vel);

          // light claps on 2&4
          if(i%4===2){
            const tt=sched.nextTime;
            // tiny "clap" noise burst
            const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.02), audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for(let k=0;k<d.length;k++) d[k]=(Math.random()*2-1)*(1-k/d.length);
            const src = audioCtx.createBufferSource(); src.buffer=buf;
            const hp = audioCtx.createBiquadFilter(); hp.type="highpass"; hp.frequency.value=1600;
            const gg = audioCtx.createGain();
            gg.gain.setValueAtTime(0.0001, tt);
            gg.gain.exponentialRampToValueAtTime(0.12, tt+0.002);
            gg.gain.exponentialRampToValueAtTime(0.0001, tt+0.02);
            src.connect(hp).connect(gg).connect(bgmBus);
            src.start(tt); src.stop(tt+0.03);
          }

          sched.nextIdx++;
          sched.nextTime += beatDur; // 1 beat step
        }
        requestAnimationFrame(tick);
      }
      tick();
    }
  }

  $("bgmType").addEventListener("change", ()=>{
    $("bgmFileWrap").style.display = ($("bgmType").value === "file") ? "block" : "none";
  });

  $("bgmFile").addEventListener("change", async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    ensureAudio();
    try{
      const ab = await f.arrayBuffer();
      bgmBuffer = await audioCtx.decodeAudioData(ab);
      toast("BGMãƒ•ã‚¡ã‚¤ãƒ«èª­è¾¼OK", "good", 1200);
    }catch(err){
      console.error(err);
      toast("BGMèª­è¾¼ã«å¤±æ•—ï¼ˆåˆ¥å½¢å¼ã‚’è©¦ã—ã¦ï¼‰", "bad", 1400);
      bgmBuffer = null;
    }
  });

  // ====== Patterns ======
  // note: time is in beats (can be fractional), type "don" or "ka".
  const patterns = [
    {
      id:"matsuri_basic",
      name:"ç¥­ã‚Šãƒ»åŸºæœ¬ï¼ˆ4/4ï¼‰",
      desc:"ãƒ‰ãƒ³ãƒ»ãƒ‰ãƒ³ãƒ»ã‚«ãƒƒãƒ»ã‚« ã®åŸºæœ¬ã€‚ã¾ãšã¯ã“ã“ã‹ã‚‰ã€‚",
      beatsPerBar:4, bars:4,
      notes:(()=>{
        const out=[];
        // bar pattern (1 bar = 4 beats): Don on 1,2; Ka on 3&,4&
        const bar = [
          {t:0, type:"don"},
          {t:1, type:"don"},
          {t:2.5, type:"ka"},
          {t:3.5, type:"ka"},
        ];
        for(let b=0;b<4;b++){
          const base = b*4;
          for(const n of bar) out.push({beat: base + n.t, type:n.type});
        }
        return out;
      })()
    },
    {
      id:"bon_odori",
      name:"ç›†è¸Šã‚Šãƒ»è»½å¿«ï¼ˆ2/4ï¼‰",
      desc:"ã‚«ãƒ»ãƒ‰ãƒ³ãƒ»ã‚« / ã‚«ãƒ»ãƒ‰ãƒ³ãƒ»ãƒ‰ãƒ³ ã®åå¾©ã€‚",
      beatsPerBar:2, bars:8,
      notes:(()=>{
        const out=[];
        // two-bar motif over 4 beats
        const motif = [
          {t:0, type:"ka"},
          {t:0.5, type:"don"},
          {t:1, type:"ka"},
          {t:2, type:"ka"},
          {t:2.5, type:"don"},
          {t:3, type:"don"},
        ];
        const totalBeats = 16; // 2/4 x 8 bars = 16 beats
        for(let base=0;base<totalBeats;base+=4){
          for(const n of motif) out.push({beat: base + n.t, type:n.type});
        }
        return out;
      })()
    },
    {
      id:"kagura_3",
      name:"ç¥æ¥½é¢¨ï¼ˆ3/4ï¼‰",
      desc:"3æ‹å­ã®æºã‚Œã€‚ãƒ‰ãƒ³ï¼ˆ1æ‹ç›®ï¼‰ã‚’å®‰å®šã•ã›ã‚‹ç·´ç¿’ã€‚",
      beatsPerBar:3, bars:6,
      notes:(()=>{
        const out=[];
        // per bar: Don on 1, Ka on 2&, Don on 3
        const bar = [
          {t:0, type:"don"},
          {t:1.5, type:"ka"},
          {t:2, type:"don"},
        ];
        for(let b=0;b<6;b++){
          const base=b*3;
          for(const n of bar) out.push({beat:base+n.t, type:n.type});
        }
        return out;
      })()
    },
    {
      id:"warmup_16",
      name:"åŸºç¤ï¼š16åˆ†ãƒˆãƒ¬ï¼ˆ4/4ï¼‰",
      desc:"å‡ç­‰ãªåˆ»ã¿ã€‚Don/Kaã‚’äº¤äº’ã«å‡ºã™ç·´ç¿’ã€‚",
      beatsPerBar:4, bars:2,
      notes:(()=>{
        const out=[];
        // 2 bars, 16th notes (0.25 beat step)
        const totalBeats = 8;
        let flip=false;
        for(let t=0;t<totalBeats;t+=0.25){
          out.push({beat:t, type: flip ? "ka":"don"});
          flip=!flip;
        }
        return out;
      })()
    }
  ];

  const patSel = $("patSel");
  for(const p of patterns){
    const opt=document.createElement("option");
    opt.value=p.id; opt.textContent=p.name;
    patSel.appendChild(opt);
  }
  function getPattern(){
    return patterns.find(p=>p.id===patSel.value) || patterns[0];
  }

  // ====== Game State ======
  const state = {
    mode:"free",
    running:false,
    startTime:0,
    countInBeats:4,
    score:0,
    combo:0,
    judge:"-",
    // guide
    notes:[],
    nextNoteIdx:0,
    hitWindowPerfect: 0.08, // beats
    hitWindowGood:    0.14,
    hitWindowOk:      0.20,
    laneX: { don:0, ka:0 },
    hitLineY: 0,
    // visuals
    hitFx: [],
    lastTapT: 0,
  };

  function resetScore(){
    state.score=0; state.combo=0; state.judge="-";
    $("scoreTxt").textContent=0;
    $("comboTxt").textContent=0;
    $("judgeTxt").textContent="-";
  }

  function setJudge(j){
    state.judge=j;
    $("judgeTxt").textContent=j;
  }

  function addScore(points){
    state.score += points;
    $("scoreTxt").textContent = state.score;
  }

  function setCombo(c){
    state.combo=c;
    $("comboTxt").textContent=c;
  }

  function getBpm(){ return parseInt($("bpm").value,10); }

  $("bpm").addEventListener("input", ()=>{
    $("bpmTxt").textContent = $("bpm").value;
  });

  $("modeSel").addEventListener("change", ()=>{
    state.mode = $("modeSel").value;
    state.running=false;
    $("stopBtn").style.display="none";
    $("startBtn").style.display="";
    resetScore();
  });

  // ====== Input / Hit detection ======
  function hit(type, x, y, velocity=1){
    ensureAudio();
    if(audioCtx.state !== "running"){
      // try resume on first interaction
      audioCtx.resume().catch(()=>{});
    }
    const t = audioCtx.currentTime + 0.0005;

    if(type==="don") drumDon(t, velocity);
    else drumKa(t, velocity);

    // visuals
    spawnHitFx(type, x, y);

    // scoring only in guide mode & running
    if(state.mode === "guide" && state.running){
      judgeHit(type);
    }
  }

  function judgeHit(type){
    const bpm = getBpm();
    const beatDur = 60/bpm;
    const tNow = audioCtx.currentTime;
    const curBeat = (tNow - state.startTime) / beatDur;

    // Find closest upcoming/nearby note of that type that isn't hit yet
    let bestIdx = -1;
    let bestDiff = 999;

    for(let i=state.nextNoteIdx; i<state.notes.length; i++){
      const n = state.notes[i];
      if(n.hit) continue;
      // skip other type quickly but still allow looking a little ahead
      if(n.type !== type){
        if(n.beat < curBeat - state.hitWindowOk) { n.miss=true; n.hit=true; continue; }
        continue;
      }
      const diff = Math.abs(n.beat - curBeat);
      if(diff < bestDiff){
        bestDiff = diff; bestIdx = i;
      }
      // notes are sorted; if we're far past window, mark as miss
      if(n.beat < curBeat - state.hitWindowOk){
        n.miss=true; n.hit=true;
      }
      // stop searching too far ahead
      if(n.beat > curBeat + state.hitWindowOk) break;
    }

    if(bestIdx === -1 || bestDiff > state.hitWindowOk){
      // stray hit
      setJudge("MISS");
      toast("MISS", "bad", 700);
      setCombo(0);
      return;
    }

    const n = state.notes[bestIdx];
    n.hit = true;

    // update nextNoteIdx
    while(state.nextNoteIdx < state.notes.length && state.notes[state.nextNoteIdx].hit) state.nextNoteIdx++;

    if(bestDiff <= state.hitWindowPerfect){
      setJudge("PERFECT");
      toast("PERFECT", "good", 650);
      addScore(100);
      setCombo(state.combo+1);
      n.j="p";
    }else if(bestDiff <= state.hitWindowGood){
      setJudge("GOOD");
      toast("GOOD", "good", 650);
      addScore(70);
      setCombo(state.combo+1);
      n.j="g";
    }else{
      setJudge("OK");
      toast("OK", "ok", 650);
      addScore(40);
      setCombo(state.combo+1);
      n.j="o";
    }
  }

  // Mark misses as time passes
  function updateMisses(curBeat){
    for(let i=state.nextNoteIdx; i<state.notes.length; i++){
      const n = state.notes[i];
      if(n.hit) continue;
      if(n.beat < curBeat - state.hitWindowOk){
        n.hit=true; n.miss=true; n.j="m";
        setJudge("MISS");
        toast("MISS", "bad", 600);
        setCombo(0);
        // advance nextNoteIdx
        while(state.nextNoteIdx < state.notes.length && state.notes[state.nextNoteIdx].hit) state.nextNoteIdx++;
      } else {
        break;
      }
    }
  }

  // ====== Pointer handling on canvas ======
  function clientToCanvas(e){
    const rect = cv.getBoundingClientRect();
    const cx = (e.clientX - rect.left) * DPR;
    const cy = (e.clientY - rect.top) * DPR;
    return {x:cx,y:cy};
  }

  function detectZone(x,y){
    // Drum is drawn centered at (W/2, H*0.68), radius depends on screen
    const cx = W*0.5;
    const cy = H*0.68;
    const r = Math.min(W,H)*0.23;
    const dx=x-cx, dy=y-cy;
    const d = Math.hypot(dx,dy);
    if(d > r*1.03) return null;
    if(d < r*0.62) return "don";
    return "ka";
  }

  cv.addEventListener("pointerdown", (e)=>{
    cv.setPointerCapture(e.pointerId);
    const p = clientToCanvas(e);
    const z = detectZone(p.x,p.y);
    if(!z) return;

    // estimate velocity from tap speed (very light heuristic)
    const t = performance.now();
    let vel = 1;
    if(state.lastTapT){
      const dt = (t - state.lastTapT);
      vel = clamp(1.2 - dt/300, 0.55, 1.2);
    }
    state.lastTapT = t;

    hit(z, p.x, p.y, vel);
  }, {passive:true});

  // Keyboard support
  window.addEventListener("keydown", (e)=>{
    if(e.repeat) return;
    const k = e.key.toLowerCase();
    // F/J = Don
    if(k==="f" || k==="j"){
      hit("don", W*0.5, H*0.68, 1);
    }
    // D/K = Ka
    if(k==="d" || k==="k"){
      // approximate rim point
      hit("ka", W*0.5 + Math.min(W,H)*0.18, H*0.68, 1);
    }
  });

  // ====== UI ======
  const toastEl = $("toast");
  let toastTimer = 0;
  function toast(msg, kind="ok", ms=800){
    toastEl.textContent = msg;
    toastEl.classList.remove("good","ok","bad","show");
    toastEl.classList.add(kind==="good"?"good":kind==="bad"?"bad":"ok");
    toastEl.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toastEl.classList.remove("show"), ms);
  }

  $("helpBtn").addEventListener("click", ()=>$("overlay").classList.add("show"));
  $("closeHelp").addEventListener("click", ()=>$("overlay").classList.remove("show"));
  $("overlay").addEventListener("click", (e)=>{ if(e.target.id==="overlay") $("overlay").classList.remove("show"); });

  $("unlockBtn").addEventListener("click", unlockAudio);

  // ====== Start/Stop ======
  $("startBtn").addEventListener("click", async ()=>{
    ensureAudio();
    try{ await audioCtx.resume(); }catch(e){}
    start();
  });
  $("stopBtn").addEventListener("click", stop);

  function buildNotesForPattern(p){
    // sort by beat
    const ns = p.notes.map(n=>({beat:n.beat, type:n.type, hit:false, miss:false, j:""}))
                      .sort((a,b)=>a.beat-b.beat);
    return ns;
  }

  function start(){
    if(state.running) return;
    resetScore();
    state.running = true;
    $("startBtn").style.display="none";
    $("stopBtn").style.display="";

    const bpm = getBpm();
    const beatDur = 60/bpm;

    const p = getPattern();

    // set notes only in guide
    if(state.mode==="guide"){
      state.notes = buildNotesForPattern(p);
      state.nextNoteIdx = 0;
    }else{
      state.notes = [];
      state.nextNoteIdx = 0;
    }

    // count-in for stable start
    state.startTime = audioCtx.currentTime + 1.0; // a bit later
    const countInBeats = (state.mode==="guide") ? state.countInBeats : 0;

    // metronome clicks during count-in (and optionally always)
    scheduleCountIn(state.startTime, countInBeats, bpm);

    // start bgm at same startTime
    startBgm(state.startTime);

    toast(state.mode==="guide" ? "Ready..." : "Free Play", "ok", 800);
  }

  function stop(){
    state.running = false;
    $("stopBtn").style.display="none";
    $("startBtn").style.display="";
    stopBgm();
    metOn=false;
    toast("Stopped", "ok", 700);
  }

  function scheduleCountIn(startTime, countBeats, bpm){
    const beatDur = 60/bpm;
    if(countBeats<=0) return;
    // a simple click sound
    for(let i=0;i<countBeats;i++){
      const t = startTime + (i-countBeats)*beatDur;
      // schedule in the near future only (avoid negative)
      if(t < audioCtx.currentTime) continue;
      click(t, i===countBeats-1 ? 1200 : 900, 0.12);
    }
  }

  function click(t, freq=900, vol=0.1){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type="square"; o.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(vol, t+0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.03);
    o.connect(g).connect(bgmBus);
    o.start(t); o.stop(t+0.04);
  }

  // ====== Visual Effects ======
  function spawnHitFx(type, x, y){
    const col = (type==="don") ? "rgba(77,163,255," : "rgba(255,176,32,";
    state.hitFx.push({
      x,y, t:performance.now(),
      r0: (type==="don") ? 20*DPR : 18*DPR,
      col
    });
  }

  // ====== Rendering ======
  function draw(){
    requestAnimationFrame(draw);
    if(W!==cv.width || H!==cv.height) resize();

    // background
    ctx2d.clearRect(0,0,W,H);

    // subtle vignette
    const vg = ctx2d.createRadialGradient(W*0.5,H*0.55,Math.min(W,H)*0.15, W*0.5,H*0.55, Math.min(W,H)*0.65);
    vg.addColorStop(0, "rgba(255,255,255,0.02)");
    vg.addColorStop(1, "rgba(0,0,0,0.45)");
    ctx2d.fillStyle = vg;
    ctx2d.fillRect(0,0,W,H);

    const drum = getDrumGeom();
    drawNoteHighway(drum);
    drawDrum(drum);
    drawHitFx();

    // game update
    if(state.mode==="guide" && state.running){
      const bpm = getBpm();
      const beatDur = 60/bpm;
      const curBeat = (audioCtx.currentTime - state.startTime)/beatDur;
      updateMisses(curBeat);

      // end condition
      const p = getPattern();
      const totalBeats = p.beatsPerBar * p.bars;
      if(curBeat > totalBeats + 1.2){
        stop();
        toast("Finish!", "good", 1200);
      }
    }
  }

  function getDrumGeom(){
    const cx = W*0.5;
    const cy = H*0.68;
    const r = Math.min(W,H)*0.23;
    return {cx,cy,r, inner:r*0.62, outer:r*1.0};
  }

  function drawDrum(d){
    const {cx,cy,r,inner} = d;

    // shadow
    ctx2d.save();
    ctx2d.beginPath();
    ctx2d.ellipse(cx, cy + r*0.55, r*0.92, r*0.28, 0, 0, Math.PI*2);
    ctx2d.fillStyle = "rgba(0,0,0,0.35)";
    ctx2d.fill();
    ctx2d.restore();

    // body (wood)
    const wood = ctx2d.createLinearGradient(cx-r,cy, cx+r, cy);
    wood.addColorStop(0, "#3a2416");
    wood.addColorStop(0.45, "#6b3e1f");
    wood.addColorStop(1, "#2a1a10");

    ctx2d.save();
    ctx2d.beginPath();
    ctx2d.ellipse(cx, cy, r, r*0.85, 0, 0, Math.PI*2);
    ctx2d.fillStyle = wood;
    ctx2d.fill();
    ctx2d.restore();

    // rim ring
    ctx2d.save();
    ctx2d.beginPath();
    ctx2d.ellipse(cx, cy, r*0.98, r*0.84, 0, 0, Math.PI*2);
    ctx2d.lineWidth = Math.max(2, r*0.08);
    ctx2d.strokeStyle = "rgba(240,210,170,0.85)";
    ctx2d.stroke();
    ctx2d.restore();

    // skin surface (slightly textured)
    const skin = ctx2d.createRadialGradient(cx-r*0.18, cy-r*0.20, r*0.06, cx, cy, r*0.86);
    skin.addColorStop(0, "#f1dfc6");
    skin.addColorStop(0.55, "#e4caa7");
    skin.addColorStop(1, "#b99162");

    ctx2d.save();
    ctx2d.beginPath();
    ctx2d.ellipse(cx, cy, r*0.86, r*0.73, 0, 0, Math.PI*2);
    ctx2d.fillStyle = skin;
    ctx2d.fill();
    ctx2d.restore();

    // inner zone hint
    ctx2d.save();
    ctx2d.beginPath();
    ctx2d.ellipse(cx, cy, inner*0.96, inner*0.82, 0, 0, Math.PI*2);
    ctx2d.strokeStyle = "rgba(20,20,20,0.18)";
    ctx2d.lineWidth = Math.max(1, r*0.012);
    ctx2d.setLineDash([6*DPR, 10*DPR]);
    ctx2d.stroke();
    ctx2d.restore();

    // nails (dots around rim)
    ctx2d.save();
    const nailN=22;
    for(let i=0;i<nailN;i++){
      const a = (i/nailN)*Math.PI*2;
      const rx = r*0.83, ry=r*0.70;
      const x = cx + Math.cos(a)*rx;
      const y = cy + Math.sin(a)*ry;
      ctx2d.beginPath();
      ctx2d.arc(x,y, Math.max(1.6*DPR, r*0.018), 0, Math.PI*2);
      ctx2d.fillStyle = "rgba(40,30,24,0.55)";
      ctx2d.fill();
    }
    ctx2d.restore();

    // labels
    ctx2d.save();
    ctx2d.font = `${Math.max(12*DPR, r*0.11)}px system-ui, -apple-system, "Segoe UI"`;
    ctx2d.fillStyle = "rgba(255,255,255,0.55)";
    ctx2d.textAlign="center";
    ctx2d.fillText("Don", cx, cy + r*0.02);
    ctx2d.font = `${Math.max(10*DPR, r*0.085)}px system-ui, -apple-system, "Segoe UI"`;
    ctx2d.fillStyle = "rgba(255,255,255,0.35)";
    ctx2d.fillText("Ka (rim)", cx, cy + r*0.28);
    ctx2d.restore();
  }

  function drawHitFx(){
    const t = performance.now();
    const keep=[];
    for(const fx of state.hitFx){
      const age = (t - fx.t)/1000;
      if(age>0.22) continue;
      keep.push(fx);
      const a = 1 - age/0.22;
      const rr = fx.r0 + age*180*DPR;
      ctx2d.save();
      ctx2d.beginPath();
      ctx2d.arc(fx.x, fx.y, rr, 0, Math.PI*2);
      ctx2d.strokeStyle = fx.col + (0.22*a) + ")";
      ctx2d.lineWidth = 6*DPR*a;
      ctx2d.stroke();
      ctx2d.restore();
    }
    state.hitFx = keep;
  }

  function drawNoteHighway(drum){
    // Draw lanes and falling notes (guide mode)
    const topY = H*0.12;
    const laneW = Math.min(W*0.34, 520*DPR);
    const laneH = Math.min(H*0.34, 440*DPR);
    const laneX = W*0.5 - laneW*0.5;
    const laneY = topY;

    // hit line near drum
    const hitY = H*0.48;
    state.hitLineY = hitY;

    // lane positions
    const donX = laneX + laneW*0.35;
    const kaX  = laneX + laneW*0.65;
    state.laneX.don = donX;
    state.laneX.ka  = kaX;

    // frame
    ctx2d.save();
    ctx2d.globalAlpha = 0.92;
    roundRect(ctx2d, laneX, laneY, laneW, laneH, 18*DPR);
    ctx2d.fillStyle = "rgba(12,16,26,0.55)";
    ctx2d.fill();
    ctx2d.strokeStyle = "rgba(36,48,71,0.85)";
    ctx2d.lineWidth = 2*DPR;
    ctx2d.stroke();

    // lane guides
    ctx2d.strokeStyle = "rgba(120,131,155,0.22)";
    ctx2d.lineWidth = 2*DPR;
    ctx2d.beginPath();
    ctx2d.moveTo(donX, laneY+12*DPR); ctx2d.lineTo(donX, laneY+laneH-12*DPR);
    ctx2d.moveTo(kaX,  laneY+12*DPR); ctx2d.lineTo(kaX,  laneY+laneH-12*DPR);
    ctx2d.stroke();

    // labels
    ctx2d.fillStyle = "rgba(232,238,252,0.55)";
    ctx2d.font = `${Math.max(11*DPR, 12*DPR)}px system-ui, -apple-system, "Segoe UI"`;
    ctx2d.textAlign="center";
    ctx2d.fillText("DON", donX, laneY+18*DPR);
    ctx2d.fillText("KA",  kaX,  laneY+18*DPR);

    // hit line
    ctx2d.strokeStyle = "rgba(77,163,255,0.35)";
    ctx2d.lineWidth = 3*DPR;
    ctx2d.beginPath();
    const lineY = clamp(hitY, laneY+40*DPR, laneY+laneH-20*DPR);
    ctx2d.moveTo(laneX+16*DPR, lineY);
    ctx2d.lineTo(laneX+laneW-16*DPR, lineY);
    ctx2d.stroke();

    // countdown indicator
    if(state.running && state.mode==="guide"){
      const bpm = getBpm();
      const beatDur = 60/bpm;
      const curBeat = (audioCtx.currentTime - state.startTime)/beatDur;
      const p = getPattern();
      const totalBeats = p.beatsPerBar*p.bars;

      // show bar/beat
      const bar = Math.floor(curBeat / p.beatsPerBar) + 1;
      const inbar = (curBeat % p.beatsPerBar);
      const beatN = Math.floor(inbar) + 1;

      ctx2d.fillStyle = "rgba(232,238,252,0.45)";
      ctx2d.textAlign="left";
      ctx2d.font = `${Math.max(11*DPR, 12*DPR)}px system-ui, -apple-system, "Segoe UI"`;
      ctx2d.fillText(`BAR ${clamp(bar,1,p.bars)} / ${p.bars}  |  BEAT ${clamp(beatN,1,p.beatsPerBar)} / ${p.beatsPerBar}`, laneX+14*DPR, laneY+laneH-12*DPR);

      // progress bar
      const prog = clamp(curBeat/totalBeats, 0, 1);
      roundRect(ctx2d, laneX+14*DPR, laneY+laneH-28*DPR, laneW-28*DPR, 8*DPR, 999);
      ctx2d.fillStyle="rgba(36,48,71,0.55)";
      ctx2d.fill();
      roundRect(ctx2d, laneX+14*DPR, laneY+laneH-28*DPR, (laneW-28*DPR)*prog, 8*DPR, 999);
      ctx2d.fillStyle="rgba(77,163,255,0.55)";
      ctx2d.fill();
    } else {
      // show pattern desc while idle
      const p = getPattern();
      ctx2d.fillStyle = "rgba(232,238,252,0.35)";
      ctx2d.textAlign="center";
      ctx2d.font = `${Math.max(11*DPR, 12*DPR)}px system-ui, -apple-system, "Segoe UI"`;
      ctx2d.fillText(`${p.desc}`, W*0.5, laneY+laneH-14*DPR);
    }

    // notes rendering
    if(state.mode==="guide"){
      const bpm = getBpm();
      const beatDur = 60/bpm;
      const curBeat = (state.running) ? (audioCtx.currentTime - state.startTime)/beatDur : -999;
      // fall window in beats
      const lookAheadBeats = 4.0;
      const lookBehindBeats = 0.5;

      for(let i=0;i<state.notes.length;i++){
        const n = state.notes[i];
        const dt = n.beat - curBeat;
        if(dt > lookAheadBeats) break;
        if(dt < -lookBehindBeats) continue;

        const x = (n.type==="don") ? donX : kaX;
        // Map dt to y position: dt=lookAhead -> top, dt=0 -> lineY
        const yTop = laneY + 34*DPR;
        const yLine = lineY;
        const tNorm = clamp(1 - dt/lookAheadBeats, 0, 1);
        const y = lerp(yTop, yLine, tNorm);

        const r = 10*DPR;
        const baseCol = (n.type==="don") ? [77,163,255] : [255,176,32];

        // draw hit/miss status
        let alpha = 0.95;
        if(n.hit && n.j){
          alpha = 0.22;
        }
        if(n.miss){
          alpha = 0.18;
        }

        // glow
        ctx2d.save();
        ctx2d.beginPath();
        ctx2d.arc(x, y, r*1.9, 0, Math.PI*2);
        ctx2d.fillStyle = `rgba(${baseCol[0]},${baseCol[1]},${baseCol[2]},${0.18*alpha})`;
        ctx2d.fill();
        ctx2d.restore();

        // note
        ctx2d.save();
        ctx2d.beginPath();
        ctx2d.arc(x, y, r, 0, Math.PI*2);
        ctx2d.fillStyle = `rgba(${baseCol[0]},${baseCol[1]},${baseCol[2]},${0.75*alpha})`;
        ctx2d.fill();
        ctx2d.lineWidth = 2*DPR;
        ctx2d.strokeStyle = `rgba(232,238,252,${0.45*alpha})`;
        ctx2d.stroke();
        ctx2d.restore();

        // if it was judged, show tiny label
        if(n.hit && n.j && dt < 0.1){
          ctx2d.save();
          ctx2d.font = `${Math.max(10*DPR, 11*DPR)}px system-ui, -apple-system, "Segoe UI"`;
          ctx2d.textAlign="center";
          ctx2d.fillStyle="rgba(232,238,252,0.35)";
          const lab = (n.j==="p")?"P":(n.j==="g")?"G":(n.j==="o")?"O":"M";
          ctx2d.fillText(lab, x, y - 16*DPR);
          ctx2d.restore();
        }
      }
    }

    ctx2d.restore();

    // If metronome-only selected, generate subtle clicks in realtime while running
    if(state.running && $("bgmOn").checked && $("bgmType").value==="met"){
      scheduleMetronome();
    }
  }

  // Metronome scheduler (simple)
  let metNextTime = 0;
  let metNextBeat = 0;
  function scheduleMetronome(){
    if(!audioCtx) return;
    if(metNextTime===0){
      metNextTime = state.startTime;
      metNextBeat = 0;
    }
    const bpm = getBpm();
    const beatDur = 60/bpm;
    const tNow = audioCtx.currentTime;

    // if stopped, reset
    if(!state.running){
      metNextTime = 0;
      metNextBeat = 0;
      return;
    }

    while(metNextTime < tNow + 0.18){
      const isDownbeat = (metNextBeat % 4 === 0);
      click(metNextTime, isDownbeat ? 1100 : 850, isDownbeat ? 0.11 : 0.075);
      metNextTime += beatDur;
      metNextBeat++;
    }
  }

  function roundRect(c, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+rr, y);
    c.arcTo(x+w, y, x+w, y+h, rr);
    c.arcTo(x+w, y+h, x, y+h, rr);
    c.arcTo(x, y+h, x, y, rr);
    c.arcTo(x, y, x+w, y, rr);
    c.closePath();
  }

  // ====== Animation loop start ======
  draw();

  // ====== small UX ======
  if(isTouch){
    $("hint").textContent = "ã‚¿ãƒƒãƒ—ã§å©ãï¼šä¸­å¿ƒ=Don / ç¸=Kaï¼ˆiOSã¯ã€ŒéŸ³å£°è§£éŒ ã€â†’é–‹å§‹ï¼‰";
  }

})();
</script>
</body>
</html>
