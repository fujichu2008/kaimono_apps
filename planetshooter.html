<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, viewport-fit=cover, user-scalable=no" />
<title>惑星シューター（MVP / 三人称・横向き）</title>
<style>
  :root{
    --bg0:#070A12; --bg1:#0b1430;
    --card: rgba(255,255,255,.07);
    --card2: rgba(255,255,255,.10);
    --line: rgba(255,255,255,.14);
    --text:#EAF1FF; --muted:#A8B4D6;
    --pri:#58B6FF; --ok:#2EE59D; --warn:#FFC857; --danger:#FF5C7A;
    --shadow: 0 18px 50px rgba(0,0,0,.45);
    --r:18px;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; overflow:hidden;
    background: radial-gradient(1200px 700px at 60% 20%, #10224c, var(--bg0));
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
  }
  /* 横向き前提：縦向きは案内 */
  #rotateHint{
    position:fixed; inset:0; display:none;
    align-items:center; justify-content:center;
    background: rgba(0,0,0,.78);
    padding:24px; text-align:center; z-index:50;
  }
  #rotateHint .box{
    max-width:520px; background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.15); border-radius:18px;
    padding:18px 16px; box-shadow: var(--shadow);
  }
  #rotateHint h2{ margin:0 0 8px; font-size:18px }
  #rotateHint p{ margin:0; color:var(--muted); line-height:1.5 }

  canvas{ display:block; width:100vw; height:100vh; touch-action:none; }

  /* HUD */
  #hud{
    position:fixed; inset:0; pointer-events:none; z-index:10;
  }
  .hudTop{
    position:absolute; left:16px; right:16px; top:12px;
    display:flex; gap:10px; align-items:flex-start; justify-content:space-between;
  }
  .pill{
    pointer-events:none;
    display:flex; gap:10px; align-items:center;
    padding:10px 12px; border-radius:999px;
    background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
    backdrop-filter: blur(10px);
  }
  .mini{ font-size:12px; color:var(--muted) }
  .big{ font-size:14px; font-weight:700 }
  .barWrap{
    width:220px; height:10px; border-radius:999px;
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .bar{
    height:100%; width:50%;
    background:linear-gradient(90deg, var(--pri), #9ad2ff);
  }
  .bar.ok{ background:linear-gradient(90deg, var(--ok), #7dffce); }
  .bar.warn{ background:linear-gradient(90deg, var(--warn), #ffe4a3); }
  .bar.danger{ background:linear-gradient(90deg, var(--danger), #ff9ab0); }

  #centerReticle{
    position:absolute; left:50%; top:50%;
    width:26px; height:26px; transform:translate(-50%,-50%);
    opacity:.95;
  }
  #centerReticle:before, #centerReticle:after{
    content:""; position:absolute; inset:0;
    border-radius:50%;
    border:1px solid rgba(255,255,255,.55);
  }
  #centerReticle:after{
    inset:9px; border:1px solid rgba(255,255,255,.35);
  }
  #centerDot{
    position:absolute; left:50%; top:50%;
    width:3px; height:3px; transform:translate(-50%,-50%);
    background:rgba(255,255,255,.85); border-radius:50%;
  }

  /* ステータス（右下） */
  #cooldowns{
    position:absolute; right:14px; bottom:14px;
    display:flex; gap:10px; pointer-events:none;
  }
  .cdCard{
    min-width:92px;
    padding:10px 10px;
    border-radius:16px;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
    backdrop-filter: blur(10px);
    box-shadow: 0 10px 25px rgba(0,0,0,.30);
  }
  .cdRow{ display:flex; justify-content:space-between; gap:10px; align-items:baseline; }
  .cdName{ font-size:12px; color:var(--muted) }
  .cdVal{ font-size:13px; font-weight:800 }
  .cdMeter{
    margin-top:8px;
    width:100%; height:7px; border-radius:999px; overflow:hidden;
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
  }
  .cdFill{ height:100%; width:100%; background:linear-gradient(90deg, var(--pri), #9ad2ff); }

  /* 画面（Start / Upgrade / Result） */
  .screen{
    position:fixed; inset:0;
    display:none;
    align-items:center; justify-content:center;
    background: radial-gradient(900px 600px at 50% 20%, rgba(80,160,255,.22), rgba(0,0,0,.65));
    z-index:20;
  }
  .panel{
    width:min(920px, calc(100vw - 28px));
    border-radius:22px;
    background:rgba(10,14,26,.70);
    border:1px solid rgba(255,255,255,.14);
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    padding:18px;
  }
  .panel h1{ margin:0; font-size:22px; letter-spacing:.02em }
  .panel p{ margin:10px 0 0; color:var(--muted); line-height:1.55 }
  .row{ display:flex; gap:12px; flex-wrap:wrap; margin-top:14px; }
  .btn{
    pointer-events:auto;
    appearance:none; border:0; cursor:pointer;
    border-radius:16px; padding:12px 14px;
    background:linear-gradient(180deg, rgba(88,182,255,.92), rgba(88,182,255,.70));
    color:#061224; font-weight:900;
    box-shadow: 0 14px 30px rgba(0,0,0,.28);
  }
  .btn.secondary{
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.16);
    color:var(--text); font-weight:800;
  }
  .kbd{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px; padding:1px 6px; border-radius:8px;
    border:1px solid rgba(255,255,255,.22);
    background:rgba(255,255,255,.08);
    color:#dfe8ff;
  }
  .grid2{
    display:grid; grid-template-columns:1fr 1fr; gap:12px;
    margin-top:12px;
  }
  @media (max-width:820px){
    .grid2{ grid-template-columns:1fr; }
  }
  .card{
    border-radius:18px;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
    padding:12px;
  }
  .card h3{ margin:0 0 6px; font-size:14px }
  .card p{ margin:0; color:var(--muted); font-size:13px; line-height:1.5 }

  /* Upgrade */
  .upGrid{ display:grid; grid-template-columns:repeat(3, 1fr); gap:12px; margin-top:14px; }
  @media (max-width:820px){ .upGrid{ grid-template-columns:1fr; } }
  .upBtn{
    pointer-events:auto;
    text-align:left;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.14);
    border-radius:18px;
    padding:12px;
    cursor:pointer;
  }
  .upBtn:hover{ border-color:rgba(88,182,255,.55); }
  .upTitle{ font-weight:900; margin:0 0 6px; }
  .upDesc{ margin:0; color:var(--muted); font-size:13px; line-height:1.5; }

  /* Touch UI */
  #touchUI{
    position:fixed; inset:0; z-index:15;
    display:none;
    pointer-events:none;
  }
  .joy{
    position:absolute;
    width:170px; height:170px;
    border-radius:50%;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
    backdrop-filter: blur(10px);
    pointer-events:auto;
    touch-action:none;
  }
  .joy .knob{
    position:absolute; left:50%; top:50%;
    width:70px; height:70px;
    transform:translate(-50%,-50%);
    border-radius:50%;
    background:rgba(88,182,255,.28);
    border:1px solid rgba(88,182,255,.55);
    box-shadow: 0 10px 24px rgba(0,0,0,.35);
  }
  #joyL{ left:18px; bottom:18px; }
  #joyR{ right:18px; bottom:18px; }

  .touchBtns{
    position:absolute; right:204px; bottom:20px;
    display:flex; flex-direction:column; gap:10px;
    pointer-events:none;
  }
  .tbtnRow{ display:flex; gap:10px; justify-content:flex-end; pointer-events:none; }
  .tbtn{
    pointer-events:auto;
    width:112px; height:54px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.07);
    color:var(--text);
    font-weight:900;
    display:flex; align-items:center; justify-content:center;
    user-select:none;
    touch-action:none;
  }
  .tbtn.primary{
    background:linear-gradient(180deg, rgba(88,182,255,.92), rgba(88,182,255,.62));
    color:#061224;
    border-color:rgba(88,182,255,.35);
  }

  /* Jammer noise overlay */
  #noise{
    position:fixed; inset:0; z-index:12;
    pointer-events:none;
    opacity:0;
    background:
      repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.10) 0px,
        rgba(255,255,255,.06) 2px,
        rgba(0,0,0,0) 4px,
        rgba(0,0,0,0) 6px
      );
    mix-blend-mode: overlay;
    transition: opacity .18s ease;
  }
  #noise.on{ opacity:.35; }
  #noise:after{
    content:"";
    position:absolute; inset:-40px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='80'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='80' height='80' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
    opacity:.35;
    animation: drift 1.4s linear infinite;
  }
  @keyframes drift{
    0%{ transform:translate3d(0,0,0); }
    100%{ transform:translate3d(-40px, 20px, 0); }
  }
</style>
</head>
<body>

<div id="rotateHint">
  <div class="box">
    <h2>横向きでプレイしてください</h2>
    <p>このゲームは横向き（ランドスケープ）前提です。<br/>端末を回転して、もう一度お試しください。</p>
  </div>
</div>

<canvas id="c"></canvas>

<div id="noise"></div>

<div id="hud">
  <div class="hudTop">
    <div class="pill">
      <div>
        <div class="mini">自機 HP</div>
        <div class="barWrap"><div id="hpBar" class="bar"></div></div>
      </div>
      <div style="width:1px;height:34px;background:rgba(255,255,255,.14)"></div>
      <div>
        <div class="mini">惑星シールド</div>
        <div class="barWrap"><div id="shieldBar" class="bar ok"></div></div>
      </div>
    </div>
    <div class="pill" style="gap:12px;">
      <div>
        <div class="mini">Wave</div>
        <div id="waveTxt" class="big">-</div>
      </div>
      <div style="width:1px;height:34px;background:rgba(255,255,255,.14)"></div>
      <div>
        <div class="mini">Score</div>
        <div id="scoreTxt" class="big">0</div>
      </div>
      <div style="width:1px;height:34px;background:rgba(255,255,255,.14)"></div>
      <div>
        <div class="mini">Combo</div>
        <div id="comboTxt" class="big">x1.0</div>
      </div>
    </div>
  </div>

  <div id="centerReticle">
    <div id="centerDot"></div>
  </div>

  <div id="cooldowns">
    <div class="cdCard">
      <div class="cdRow"><div class="cdName">回避</div><div id="cdDodge" class="cdVal">OK</div></div>
      <div class="cdMeter"><div id="cdDodgeFill" class="cdFill"></div></div>
    </div>
    <div class="cdCard">
      <div class="cdRow"><div class="cdName">ブースト</div><div id="cdBoost" class="cdVal">OK</div></div>
      <div class="cdMeter"><div id="cdBoostFill" class="cdFill"></div></div>
    </div>
    <div class="cdCard">
      <div class="cdRow"><div class="cdName">リングマイン</div><div id="cdMine" class="cdVal">OK</div></div>
      <div class="cdMeter"><div id="cdMineFill" class="cdFill"></div></div>
    </div>
  </div>
</div>

<!-- Touch UI -->
<div id="touchUI">
  <div id="joyL" class="joy"><div class="knob"></div></div>
  <div id="joyR" class="joy"><div class="knob"></div></div>

  <div class="touchBtns">
    <div class="tbtnRow">
      <div id="btnMine" class="tbtn">MINE</div>
      <div id="btnDodge" class="tbtn">DODGE</div>
    </div>
    <div class="tbtnRow">
      <div id="btnBoost" class="tbtn">BOOST</div>
      <div id="btnFire" class="tbtn primary">FIRE</div>
    </div>
  </div>
</div>

<!-- Start Screen -->
<div id="startScreen" class="screen" style="display:flex;">
  <div class="panel">
    <h1>惑星シューター（MVP）</h1>
    <p>三人称チェイス視点で、惑星の周回軌道を飛びながら侵略ドローンを撃退します。<br/>
      <b>横向き前提</b>。まずは <b>Wave5 → ボス撃破</b>を目指してください。</p>

    <div class="grid2">
      <div class="card">
        <h3>PC 操作</h3>
        <p>
          移動：<span class="kbd">A</span>/<span class="kbd">D</span>（周回）、
          <span class="kbd">W</span>/<span class="kbd">S</span>（高度）<br/>
          射撃：<span class="kbd">左クリック</span>（長押し可） / チャージ：<span class="kbd">右クリック</span><br/>
          回避：<span class="kbd">Space</span> / ブースト：<span class="kbd">Shift</span> / リングマイン：<span class="kbd">E</span><br/>
          視点：可能なら開始後にキャンバスをクリックして <b>ポインタロック</b>（マウスで照準）
        </p>
      </div>
      <div class="card">
        <h3>iPad / タッチ</h3>
        <p>
          左ジョイスティック：周回・高度<br/>
          右ジョイスティック：照準（ヨー/ピッチ）<br/>
          <b>FIRE</b>長押しで連射、<b>BOOST</b>/<b>DODGE</b>/<b>MINE</b>で回避・加速・必殺
        </p>
      </div>
    </div>

    <div class="row">
      <button id="btnStart" class="btn">START</button>
      <button id="btnHow" class="btn secondary">コツ</button>
      <div id="howText" style="display:none; margin-top:10px; width:100%; color:var(--muted); line-height:1.55;">
        ・惑星シールド（左上）を守るのが最優先。敵が地表に到達すると減ります。<br/>
        ・Jammer（妨害機）が近いとノイズが出ます。優先撃破！<br/>
        ・Wave間のアップグレードは、<b>火力</b>か<b>回避</b>を伸ばすと安定します。
      </div>
    </div>
  </div>
</div>

<!-- Upgrade Screen -->
<div id="upgradeScreen" class="screen">
  <div class="panel">
    <h1>補給タイム：アップグレードを1つ選択</h1>
    <p>Wave間に3回だけ選べます。迷ったら「ダメージ」がおすすめ。</p>
    <div class="upGrid">
      <button class="upBtn" id="upA">
        <div class="upTitle">連射 +15%</div>
        <p class="upDesc">ショット間隔が短くなります。群れ処理がラク。</p>
      </button>
      <button class="upBtn" id="upB">
        <div class="upTitle">ダメージ +20%</div>
        <p class="upDesc">単発火力アップ。隕石・ボスが削りやすい。</p>
      </button>
      <button class="upBtn" id="upC">
        <div class="upTitle">回避CD -20%（＋HP回復）</div>
        <p class="upDesc">回避が回る。おまけでHPを少し回復。</p>
      </button>
    </div>
  </div>
</div>

<!-- Result Screen -->
<div id="resultScreen" class="screen">
  <div class="panel">
    <h1 id="resultTitle">Result</h1>
    <p id="resultDesc">-</p>
    <div class="row">
      <button id="btnRetry" class="btn">RETRY</button>
      <button id="btnBack" class="btn secondary">TITLE</button>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:false});
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x070a12, 0.0075);

const camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 35, 120);

const clock = new THREE.Clock();

/* ---------- Orientation hint (landscape) ---------- */
const rotateHint = document.getElementById("rotateHint");
function updateRotateHint(){
  const isPortrait = window.innerHeight > window.innerWidth;
  rotateHint.style.display = isPortrait ? "flex" : "none";
}
updateRotateHint();

/* ---------- Lights ---------- */
const hemi = new THREE.HemisphereLight(0x9ad2ff, 0x06070b, 0.95);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 1.25);
dir.position.set(80, 120, 60);
scene.add(dir);

/* ---------- Starfield ---------- */
function makeStarfield(){
  const g = new THREE.BufferGeometry();
  const n = 1800;
  const pos = new Float32Array(n*3);
  for(let i=0;i<n;i++){
    const r = 700 + Math.random()*900;
    const u = Math.random();
    const v = Math.random();
    const theta = 2*Math.PI*u;
    const phi = Math.acos(2*v-1);
    pos[i*3+0] = r * Math.sin(phi)*Math.cos(theta);
    pos[i*3+1] = r * Math.cos(phi);
    pos[i*3+2] = r * Math.sin(phi)*Math.sin(theta);
  }
  g.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  const m = new THREE.PointsMaterial({color:0xffffff, size:1.2, sizeAttenuation:true, transparent:true, opacity:0.7});
  const p = new THREE.Points(g,m);
  scene.add(p);
}
makeStarfield();

/* ---------- Planet textures (grid + clouds generated) ---------- */
function makeGridTexture(size=512){
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d");
  ctx.fillStyle = "#0b1c3d";
  ctx.fillRect(0,0,size,size);
  // subtle radial glow
  const grd = ctx.createRadialGradient(size*0.55, size*0.45, size*0.05, size*0.5, size*0.5, size*0.55);
  grd.addColorStop(0, "rgba(120,200,255,0.18)");
  grd.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,size,size);
  // grid lines
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  for(let i=0;i<=18;i++){
    const y = i*size/18;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(size,y); ctx.stroke();
  }
  for(let i=0;i<=36;i++){
    const x = i*size/36;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,size); ctx.stroke();
  }
  // small "north" marker
  ctx.fillStyle = "rgba(88,182,255,0.9)";
  ctx.beginPath();
  ctx.arc(size*0.50, size*0.18, size*0.016, 0, Math.PI*2);
  ctx.fill();
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  return tex;
}

function makeCloudTexture(size=512){
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,size,size);
  // paint random soft blobs
  for(let i=0;i<900;i++){
    const x = Math.random()*size;
    const y = Math.random()*size;
    const r = 6 + Math.random()*30;
    const a = 0.02 + Math.random()*0.06;
    const grd = ctx.createRadialGradient(x,y,0,x,y,r);
    grd.addColorStop(0, `rgba(255,255,255,${a})`);
    grd.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }
  // latitude banding
  const img = ctx.getImageData(0,0,size,size);
  for(let y=0;y<size;y++){
    const t = Math.sin((y/size)*Math.PI);
    for(let x=0;x<size;x++){
      const idx = (y*size+x)*4;
      img.data[idx+3] = Math.min(255, img.data[idx+3] * (0.6 + 0.4*t));
    }
  }
  ctx.putImageData(img,0,0);
  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
  return tex;
}

/* ---------- Planet ---------- */
const PLANET_R = 50;
const planetTex = makeGridTexture(512);
const planet = new THREE.Mesh(
  new THREE.SphereGeometry(PLANET_R, 64, 64),
  new THREE.MeshStandardMaterial({
    map: planetTex,
    color: 0x4aa8ff,
    roughness: 0.95,
    metalness: 0.05,
    emissive: 0x061433,
    emissiveIntensity: 0.55
  })
);
scene.add(planet);

const cloudsTex = makeCloudTexture(512);
const clouds = new THREE.Mesh(
  new THREE.SphereGeometry(PLANET_R*1.012, 64, 64),
  new THREE.MeshStandardMaterial({
    map: cloudsTex,
    transparent:true,
    opacity: 0.52,
    depthWrite:false,
    roughness:1,
    metalness:0
  })
);
scene.add(clouds);

/* ---------- Player ship ---------- */
const ship = new THREE.Group();
scene.add(ship);

const shipBody = new THREE.Mesh(
  new THREE.ConeGeometry(1.2, 4.8, 10),
  new THREE.MeshStandardMaterial({color:0xdfe8ff, roughness:0.4, metalness:0.55, emissive:0x10224c, emissiveIntensity:0.35})
);
shipBody.rotation.x = Math.PI/2;
ship.add(shipBody);

const wing = new THREE.Mesh(
  new THREE.BoxGeometry(3.2, 0.25, 1.2),
  new THREE.MeshStandardMaterial({color:0x58b6ff, roughness:0.35, metalness:0.75, emissive:0x0a2a5a, emissiveIntensity:0.55})
);
wing.position.set(0, -0.2, 0.1);
ship.add(wing);

const engineGlow = new THREE.Mesh(
  new THREE.SphereGeometry(0.55, 12, 12),
  new THREE.MeshStandardMaterial({color:0x58b6ff, emissive:0x58b6ff, emissiveIntensity:2.2, roughness:0.2, metalness:0.0})
);
engineGlow.position.set(0, 0, 2.2);
ship.add(engineGlow);

/* ---------- Simple helpers ---------- */
const v3 = (...a)=>new THREE.Vector3(...a);
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp = (a,b,t)=>a+(b-a)*t;

function setBar(el, pct){
  el.style.width = `${clamp(pct,0,1)*100}%`;
  el.classList.remove("ok","warn","danger");
  if(pct >= 0.6) el.classList.add("ok");
  else if(pct >= 0.3) el.classList.add("warn");
  else el.classList.add("danger");
}

/* ---------- Game state ---------- */
const hud = {
  hpBar: document.getElementById("hpBar"),
  shieldBar: document.getElementById("shieldBar"),
  waveTxt: document.getElementById("waveTxt"),
  scoreTxt: document.getElementById("scoreTxt"),
  comboTxt: document.getElementById("comboTxt"),
  cdDodge: document.getElementById("cdDodge"),
  cdBoost: document.getElementById("cdBoost"),
  cdMine: document.getElementById("cdMine"),
  cdDodgeFill: document.getElementById("cdDodgeFill"),
  cdBoostFill: document.getElementById("cdBoostFill"),
  cdMineFill: document.getElementById("cdMineFill"),
};

const screens = {
  start: document.getElementById("startScreen"),
  upgrade: document.getElementById("upgradeScreen"),
  result: document.getElementById("resultScreen"),
  resultTitle: document.getElementById("resultTitle"),
  resultDesc: document.getElementById("resultDesc"),
};

const noise = document.getElementById("noise");

let state = "title"; // title | playing | upgrading | gameover | victory
let score = 0;

let player = {
  hp: 100,
  shield: 100,
  phi: 0,
  alt: 8,               // base altitude above surface
  altMin: 4,
  altMax: 16,
  aimYaw: 0,            // around radial axis
  aimPitch: 0,          // around local pitch axis
  fireHeld: false,
  chargeHeld: false,
  chargeT: 0,
  // cooldowns
  dodgeCd: 2.5,
  boostCd: 6.0,
  mineCd: 20.0,
  dodgeReady: 0,
  boostReady: 0,
  mineReady: 0,
  // effects
  invulnT: 0,
  boostT: 0,
  // upgrades
  fireRateMul: 1.0,
  dmgMul: 1.0,
  dodgeCdMul: 1.0,
};

let combo = { mult: 1.0, lastKillT: -999 };

const BULLET_SPEED = 180;
const BASE_FIRE_INTERVAL = 0.10; // 10 shots/s
let nextShotT = 0;

const objects = {
  enemies: [],
  bullets: [],
  ebullets: [],
  fx: [],
  mines: [],
  boss: null,
};

function resetGame(){
  // clear scene dynamic
  for(const e of objects.enemies){ scene.remove(e.mesh); }
  for(const b of objects.bullets){ scene.remove(b.mesh); }
  for(const b of objects.ebullets){ scene.remove(b.mesh); }
  for(const f of objects.fx){ scene.remove(f.mesh); }
  for(const m of objects.mines){ scene.remove(m.mesh); }
  if(objects.boss){ scene.remove(objects.boss.group); objects.boss=null; }

  objects.enemies.length = 0;
  objects.bullets.length = 0;
  objects.ebullets.length = 0;
  objects.fx.length = 0;
  objects.mines.length = 0;

  score = 0;
  player.hp = 100;
  player.shield = 100;
  player.phi = 0;
  player.alt = 8;
  player.aimYaw = 0;
  player.aimPitch = 0;
  player.fireHeld = false;
  player.chargeHeld = false;
  player.chargeT = 0;
  player.invulnT = 0;
  player.boostT = 0;

  player.fireRateMul = 1.0;
  player.dmgMul = 1.0;
  player.dodgeCdMul = 1.0;

  player.dodgeReady = 0;
  player.boostReady = 0;
  player.mineReady = 0;

  combo.mult = 1.0;
  combo.lastKillT = -999;
  nextShotT = 0;

  waveSys.reset();
}

/* ---------- Wave system ---------- */
const waveSys = (() => {
  const waves = [
    { name:"Wave 1/5", dur:30, spawns: [{t0:0, t1:30, every:2.2, type:"swarm"}], },
    { name:"Wave 2/5", dur:35, spawns: [{t0:0, t1:35, every:2.4, type:"swarm"}, {t0:8, t1:35, every:10, type:"meteor"}], },
    { name:"Wave 3/5", dur:40, spawns: [{t0:0, t1:40, every:2.6, type:"swarm"}, {t0:10, t1:40, every:12, type:"jammer"}], },
    { name:"Wave 4/5", dur:45, spawns: [{t0:0, t1:45, every:9.5, type:"meteor"}, {t0:6, t1:45, every:12, type:"sniper"}], },
    { name:"Wave 5/5", dur:45, spawns: [{t0:0, t1:45, every:2.9, type:"swarm"}, {t0:10, t1:45, every:12, type:"jammer"}, {t0:12, t1:45, every:13, type:"sniper"}], },
  ];
  let waveIdx = 0;
  let t = 0;
  let spawnTimers = [];
  let upgradesTaken = 0;
  let bossSpawned = false;

  function reset(){
    waveIdx = 0;
    t = 0;
    upgradesTaken = 0;
    bossSpawned = false;
    spawnTimers = waves.map(w => w.spawns.map(s => s.t0));
    hud.waveTxt.textContent = "Wave 1/5";
  }

  function current(){ return waves[waveIdx] || null; }

  function update(dt, now){
    const w = current();
    if(!w) return;

    t += dt;
    // spawn
    w.spawns.forEach((s, i) => {
      if(t < s.t0 || t > s.t1) return;
      if(now >= spawnTimers[waveIdx][i]){
        spawnEnemy(s.type);
        spawnTimers[waveIdx][i] = now + s.every;
      }
    });

    // wave end condition: time over AND enemies cleared -> upgrade or boss
    if(t >= w.dur){
      if(objects.enemies.length === 0 && objects.ebullets.length === 0){
        // proceed
        waveIdx++;
        if(waveIdx < waves.length){
          // upgrade between waves (3 times only)
          if(upgradesTaken < 3){
            upgradesTaken++;
            state = "upgrading";
            screens.upgrade.style.display = "flex";
          }else{
            // skip upgrade
            t = 0;
            hud.waveTxt.textContent = waves[waveIdx].name;
          }
        }else{
          // boss phase
          if(!bossSpawned){
            bossSpawned = true;
            spawnBoss();
            hud.waveTxt.textContent = "BOSS";
          }
        }
      }
    }else{
      hud.waveTxt.textContent = w.name;
    }
  }

  function onUpgradeChosen(){
    // next wave start
    screens.upgrade.style.display = "none";
    state = "playing";
    t = 0;
    const w = current();
    if(w) hud.waveTxt.textContent = w.name;
  }

  return { reset, update, onUpgradeChosen, get upgradesTaken(){return upgradesTaken;} };
})();

/* ---------- Enemy / Boss / Bullets ---------- */
function enemyMesh(type){
  if(type==="swarm"){
    const g = new THREE.IcosahedronGeometry(1.2, 0);
    const m = new THREE.MeshStandardMaterial({color:0xfff3c6, emissive:0x402400, emissiveIntensity:0.35, roughness:0.65, metalness:0.2});
    return new THREE.Mesh(g,m);
  }
  if(type==="meteor"){
    const g = new THREE.DodecahedronGeometry(2.2, 0);
    const m = new THREE.MeshStandardMaterial({color:0x9aa6c8, emissive:0x10142b, emissiveIntensity:0.25, roughness:0.95, metalness:0.15});
    return new THREE.Mesh(g,m);
  }
  if(type==="jammer"){
    const g = new THREE.OctahedronGeometry(1.8, 0);
    const m = new THREE.MeshStandardMaterial({color:0xff5c7a, emissive:0x4b0010, emissiveIntensity:0.55, roughness:0.55, metalness:0.2});
    return new THREE.Mesh(g,m);
  }
  // sniper
  const g = new THREE.CylinderGeometry(0.9, 0.9, 3.0, 10);
  const m = new THREE.MeshStandardMaterial({color:0xa9ffdc, emissive:0x063a2b, emissiveIntensity:0.55, roughness:0.55, metalness:0.25});
  const mesh = new THREE.Mesh(g,m);
  mesh.rotation.z = Math.PI/2;
  const tip = new THREE.Mesh(
    new THREE.ConeGeometry(0.75, 2.0, 10),
    new THREE.MeshStandardMaterial({color:0x58b6ff, emissive:0x0a2a5a, emissiveIntensity:0.75, roughness:0.35, metalness:0.65})
  );
  tip.rotation.y = Math.PI/2;
  tip.position.x = 2.2;
  const group = new THREE.Group();
  group.add(mesh, tip);
  return group;
}

function spawnEnemy(type){
  const lat = (Math.random()*2-1) * 0.35;           // -0.35..0.35 rad
  const phi = player.phi + (Math.random()*2-1) * 1.9; // around player
  const alt = (type==="sniper") ? 18 : (12 + Math.random()*6);
  const r = PLANET_R + alt;

  const pos = spherical(r, lat, phi);

  const hp = (type==="swarm") ? 20 :
             (type==="meteor") ? 60 :
             (type==="jammer") ? 40 : 50;

  const dmgPlanet = (type==="swarm") ? 2 :
                    (type==="meteor") ? 5 :
                    (type==="jammer") ? 3 : 4;

  const phiVel = (type==="swarm") ? (0.22 + Math.random()*0.18) :
                 (type==="meteor") ? (0.12 + Math.random()*0.10) :
                 (type==="jammer") ? (0.15 + Math.random()*0.12) :
                 (0.18 + Math.random()*0.12);

  const fall = (type==="swarm") ? (2.8 + Math.random()*1.3) :
               (type==="meteor") ? (1.4 + Math.random()*0.7) :
               (type==="jammer") ? (2.0 + Math.random()*0.9) :
               (1.6 + Math.random()*0.8);

  const mesh = enemyMesh(type);
  mesh.position.copy(pos);
  scene.add(mesh);

  objects.enemies.push({
    type, hp,
    dmgPlanet,
    phi, lat, r,
    phiVel: phiVel * (Math.random()<0.5 ? 1 : -1),
    fall,
    mesh,
    t:0,
    nextShot: 0,
    sniperCharge: 0,
  });
}

function spawnBoss(){
  // Ring Carrier: orbiting group
  const group = new THREE.Group();
  scene.add(group);

  const coreMat = new THREE.MeshStandardMaterial({color:0xffd166, emissive:0xff9a3c, emissiveIntensity:1.25, roughness:0.35, metalness:0.25});
  const hullMat = new THREE.MeshStandardMaterial({color:0x8aa3c6, emissive:0x091531, emissiveIntensity:0.25, roughness:0.8, metalness:0.35});

  const ring = new THREE.Mesh(new THREE.TorusGeometry(6.6, 1.2, 14, 48), hullMat);
  ring.rotation.x = Math.PI/2;
  group.add(ring);

  const body = new THREE.Mesh(new THREE.CylinderGeometry(2.0, 2.0, 6.8, 16), hullMat);
  body.rotation.z = Math.PI/2;
  group.add(body);

  const core = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16, 16), coreMat);
  core.position.set(-4.0, 0.0, 0.0); // "back" side in local space
  group.add(core);

  objects.boss = {
    group,
    core,
    hp: 800,
    maxHp: 800,
    phi: player.phi + 2.6,
    lat: 0,
    r: PLANET_R + 14,
    phiVel: 0.25,
    phase: 1,
    nextBurst: 0,
    nextDrop: 0,
  };
}

function bulletMesh(isEnemy=false, isCharge=false){
  const g = new THREE.SphereGeometry(isCharge ? 0.65 : 0.33, 10, 10);
  const m = new THREE.MeshStandardMaterial({
    color: isEnemy ? 0xff5c7a : 0x58b6ff,
    emissive: isEnemy ? 0x4b0010 : 0x0a2a5a,
    emissiveIntensity: isEnemy ? 0.9 : 1.1,
    roughness: 0.3, metalness: 0.0,
    transparent:true, opacity: 0.95
  });
  return new THREE.Mesh(g,m);
}

function spawnBullet(pos, dir, dmg, isEnemy=false, speed= BULLET_SPEED, life=1.8, isCharge=false){
  const mesh = bulletMesh(isEnemy, isCharge);
  mesh.position.copy(pos);
  scene.add(mesh);
  const b = { pos: pos.clone(), vel: dir.clone().multiplyScalar(speed), dmg, life, mesh, r: isCharge?0.9:0.5 };
  (isEnemy ? objects.ebullets : objects.bullets).push(b);
}

function spawnFXExplosion(pos, scale=1.0, color=0x58b6ff){
  const g = new THREE.SphereGeometry(1.0, 12, 12);
  const m = new THREE.MeshStandardMaterial({
    color,
    emissive: color,
    emissiveIntensity: 1.3,
    transparent:true,
    opacity:0.7,
    roughness:0.2, metalness:0.0,
    depthWrite:false
  });
  const mesh = new THREE.Mesh(g,m);
  mesh.position.copy(pos);
  mesh.scale.setScalar(scale);
  scene.add(mesh);
  objects.fx.push({mesh, t:0, dur:0.35, scale});
}

/* ---------- Ring mines ---------- */
function tryMine(now){
  if(now < player.mineReady) return;
  player.mineReady = now + player.mineCd;
  // spawn 16 mines around player's phi +/- spread
  const count = 16;
  const spread = 0.65; // rad around player
  const basePhi = player.phi;
  const r = PLANET_R + (player.alt + 1.0);
  for(let i=0;i<count;i++){
    const u = (i/(count-1))*2 - 1;
    const phi = basePhi + u*spread;
    const lat = (Math.random()*2-1) * 0.12;
    const pos = spherical(r, lat, phi);
    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.55, 12, 12),
      new THREE.MeshStandardMaterial({color:0xffd166, emissive:0xff9a3c, emissiveIntensity:1.25, roughness:0.35, metalness:0.0})
    );
    mesh.position.copy(pos);
    scene.add(mesh);
    objects.mines.push({mesh, pos, t:0, dur:3.0, r:2.8});
  }
}

/* ---------- Geometry math ---------- */
function spherical(r, lat, phi){
  // lat: -pi/2..pi/2, phi around Y axis
  const x = r * Math.cos(lat) * Math.cos(phi);
  const y = r * Math.sin(lat);
  const z = r * Math.cos(lat) * Math.sin(phi);
  return v3(x,y,z);
}

function localBasis(pos){
  // upRadial points away from planet
  const up = pos.clone().normalize();
  const worldUp = v3(0,1,0);
  let east = worldUp.clone().cross(up);
  // if near poles, fallback
  if(east.lengthSq() < 1e-6) east = v3(1,0,0).cross(up);
  east.normalize();
  const north = up.clone().cross(east).normalize(); // points roughly toward +Y
  return {up, east, north};
}

function computeAimDir(pos, travelDir){
  // Aim from travelDir, yaw around up, then pitch around pitchAxis (perpendicular to up & dir)
  const {up} = localBasis(pos);
  const yawQ = new THREE.Quaternion().setFromAxisAngle(up, player.aimYaw);
  const d1 = travelDir.clone().applyQuaternion(yawQ).normalize();
  const pitchAxis = up.clone().cross(d1).normalize(); // axis in tangent plane
  const pitchQ = new THREE.Quaternion().setFromAxisAngle(pitchAxis, player.aimPitch);
  return d1.applyQuaternion(pitchQ).normalize();
}

function orientObject(obj, forward, up){
  // build rotation from basis: right, up, forward
  const z = forward.clone().normalize();
  const x = up.clone().cross(z).normalize();
  const y = z.clone().cross(x).normalize();
  const m = new THREE.Matrix4().makeBasis(x, y, z);
  obj.quaternion.setFromRotationMatrix(m);
}

/* ---------- Input ---------- */
const keys = {};
window.addEventListener("keydown", (e)=>{ keys[e.code]=true; if(e.code==="Escape"){ document.exitPointerLock?.(); } });
window.addEventListener("keyup", (e)=>{ keys[e.code]=false; });

let pointerLocked = false;
document.addEventListener("pointerlockchange", ()=>{
  pointerLocked = (document.pointerLockElement === canvas);
});

let mouseDownL = false;
let mouseDownR = false;

canvas.addEventListener("mousedown", (e)=>{
  if(state!=="playing") return;
  if(e.button===0) mouseDownL = true;
  if(e.button===2) mouseDownR = true;
  // try pointer lock on first interaction (desktop)
  if(!("ontouchstart" in window)){
    if(!pointerLocked) canvas.requestPointerLock?.();
  }
});
window.addEventListener("mouseup", (e)=>{
  if(e.button===0) mouseDownL = false;
  if(e.button===2) mouseDownR = false;
});
window.addEventListener("contextmenu", (e)=>e.preventDefault());

let lastMouseX = 0, lastMouseY = 0;
window.addEventListener("mousemove", (e)=>{
  if(state!=="playing") return;
  let dx = 0, dy = 0;
  if(pointerLocked){
    dx = e.movementX || 0;
    dy = e.movementY || 0;
  }else{
    // fallback: relative to last
    dx = e.clientX - lastMouseX;
    dy = e.clientY - lastMouseY;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    // if not holding, damp
    if(!mouseDownL && !mouseDownR) { dx*=0.2; dy*=0.2; }
  }
  // aim sensitivity
  const sens = 0.0022;
  player.aimYaw = clamp(player.aimYaw - dx*sens, -1.6, 1.6);
  player.aimPitch = clamp(player.aimPitch - dy*sens, -1.1, 1.1);
});

function isTouchDevice(){
  return ("ontouchstart" in window) || (navigator.maxTouchPoints>0);
}
const touchUI = document.getElementById("touchUI");
if(isTouchDevice()) touchUI.style.display = "block";

/* Virtual joystick */
function setupJoystick(el, out){
  const knob = el.querySelector(".knob");
  let pid = null;
  let rect = null;

  function setKnob(x,y){
    const r = 65;
    knob.style.transform = `translate(calc(-50% + ${x*r}px), calc(-50% + ${y*r}px))`;
  }

  el.addEventListener("pointerdown", (e)=>{
    if(state!=="playing") return;
    pid = e.pointerId;
    el.setPointerCapture(pid);
    rect = el.getBoundingClientRect();
    onMove(e);
  });

  el.addEventListener("pointermove", (e)=>{
    if(pid!==e.pointerId) return;
    onMove(e);
  });

  el.addEventListener("pointerup", (e)=>{
    if(pid!==e.pointerId) return;
    pid = null;
    out.x = 0; out.y = 0;
    setKnob(0,0);
  });

  function onMove(e){
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    let x = (e.clientX - cx) / (rect.width/2);
    let y = (e.clientY - cy) / (rect.height/2);
    const len = Math.hypot(x,y);
    if(len>1){ x/=len; y/=len; }
    out.x = x;
    out.y = y;
    setKnob(x,y);
  }
}

const stickL = {x:0,y:0};
const stickR = {x:0,y:0};
setupJoystick(document.getElementById("joyL"), stickL);
setupJoystick(document.getElementById("joyR"), stickR);

/* Touch buttons */
const btnFire = document.getElementById("btnFire");
const btnBoost = document.getElementById("btnBoost");
const btnDodge = document.getElementById("btnDodge");
const btnMine = document.getElementById("btnMine");

function holdButton(el, onDown, onUp){
  let pid=null;
  el.addEventListener("pointerdown",(e)=>{
    if(state!=="playing") return;
    pid=e.pointerId; el.setPointerCapture(pid);
    onDown();
  });
  el.addEventListener("pointerup",(e)=>{
    if(pid!==e.pointerId) return;
    pid=null; onUp();
  });
  el.addEventListener("pointercancel",(e)=>{
    if(pid!==e.pointerId) return;
    pid=null; onUp();
  });
}

holdButton(btnFire, ()=>{ player.fireHeld=true; }, ()=>{ player.fireHeld=false; });
holdButton(btnBoost, ()=>{ tryBoost(perfNow()); }, ()=>{});
holdButton(btnDodge, ()=>{ tryDodge(perfNow()); }, ()=>{});
holdButton(btnMine, ()=>{ tryMine(perfNow()); }, ()=>{});

/* ---------- Actions ---------- */
function perfNow(){ return performance.now()/1000; }

function tryDodge(now){
  const cd = player.dodgeCd * player.dodgeCdMul;
  if(now < player.dodgeReady) return;
  player.dodgeReady = now + cd;
  player.invulnT = 0.35;
  // tiny fx
  spawnFXExplosion(ship.position.clone(), 0.8, 0x2ee59d);
}

function tryBoost(now){
  if(now < player.boostReady) return;
  player.boostReady = now + player.boostCd;
  player.boostT = 3.0;
  spawnFXExplosion(ship.position.clone(), 0.9, 0x58b6ff);
}

/* ---------- Upgrade choices ---------- */
document.getElementById("upA").addEventListener("click", ()=>{
  player.fireRateMul *= 1.15;
  waveSys.onUpgradeChosen();
});
document.getElementById("upB").addEventListener("click", ()=>{
  player.dmgMul *= 1.20;
  waveSys.onUpgradeChosen();
});
document.getElementById("upC").addEventListener("click", ()=>{
  player.dodgeCdMul *= 0.80;
  player.hp = clamp(player.hp + 25, 0, 100);
  waveSys.onUpgradeChosen();
});

/* ---------- Start / Result buttons ---------- */
document.getElementById("btnStart").addEventListener("click", ()=>{
  resetGame();
  screens.start.style.display = "none";
  state = "playing";
  if(isTouchDevice()) touchUI.style.display = "block";
});
document.getElementById("btnHow").addEventListener("click", ()=>{
  const t = document.getElementById("howText");
  t.style.display = (t.style.display==="none") ? "block" : "none";
});
document.getElementById("btnRetry").addEventListener("click", ()=>{
  resetGame();
  screens.result.style.display = "none";
  state = "playing";
});
document.getElementById("btnBack").addEventListener("click", ()=>{
  screens.result.style.display = "none";
  screens.start.style.display = "flex";
  state = "title";
});

/* ---------- Combat ---------- */
function dealPlayerDamage(d){
  if(player.invulnT > 0) return;
  player.hp = clamp(player.hp - d, 0, 100);
  spawnFXExplosion(ship.position.clone(), 0.9, 0xff5c7a);
  if(player.hp <= 0){
    endGame(false, "自機が撃墜されました。");
  }
}

function dealPlanetDamage(d){
  player.shield = clamp(player.shield - d, 0, 100);
  if(player.shield <= 0){
    endGame(false, "惑星シールドが崩壊しました。");
  }
}

function addScore(base){
  const now = perfNow();
  if(now - combo.lastKillT <= 1.5){
    combo.mult = clamp(combo.mult + 0.15, 1.0, 3.0);
  }else{
    combo.mult = 1.0;
  }
  combo.lastKillT = now;
  score += Math.floor(base * combo.mult);
}

function endGame(victory, msg){
  state = victory ? "victory" : "gameover";
  screens.result.style.display = "flex";
  screens.resultTitle.textContent = victory ? "CLEAR!" : "GAME OVER";
  screens.resultDesc.textContent = `${msg}  Score: ${score}`;
}

/* ---------- Main update ---------- */
function updateHUD(now){
  setBar(hud.hpBar, player.hp/100);
  setBar(hud.shieldBar, player.shield/100);
  hud.scoreTxt.textContent = String(score);
  hud.comboTxt.textContent = `x${combo.mult.toFixed(1)}`;

  // cooldown meters
  const dcd = player.dodgeCd * player.dodgeCdMul;
  const bcd = player.boostCd;
  const mcd = player.mineCd;

  const dLeft = Math.max(0, player.dodgeReady - now);
  const bLeft = Math.max(0, player.boostReady - now);
  const mLeft = Math.max(0, player.mineReady - now);

  hud.cdDodge.textContent = dLeft>0 ? dLeft.toFixed(1) : "OK";
  hud.cdBoost.textContent = bLeft>0 ? bLeft.toFixed(1) : "OK";
  hud.cdMine.textContent  = mLeft>0 ? mLeft.toFixed(1) : "OK";

  hud.cdDodgeFill.style.width = `${(1 - clamp(dLeft/dcd, 0,1))*100}%`;
  hud.cdBoostFill.style.width = `${(1 - clamp(bLeft/bcd, 0,1))*100}%`;
  hud.cdMineFill.style.width  = `${(1 - clamp(mLeft/mcd, 0,1))*100}%`;
}

function updatePlayer(dt, now){
  // input (touch or keyboard)
  let moveX = 0, moveY = 0;
  if(isTouchDevice()){
    moveX = stickL.x;
    moveY = -stickL.y;
    // aim from right stick
    const aimSens = 1.8; // rad/sec-ish
    player.aimYaw   = clamp(player.aimYaw + stickR.x * dt * aimSens, -1.6, 1.6);
    player.aimPitch = clamp(player.aimPitch + (-stickR.y) * dt * aimSens, -1.1, 1.1);
  }else{
    moveX = (keys["KeyD"]?1:0) - (keys["KeyA"]?1:0);
    moveY = (keys["KeyW"]?1:0) - (keys["KeyS"]?1:0);

    // actions
    if(keys["Space"]) tryDodge(now);
    if(keys["ShiftLeft"] || keys["ShiftRight"]) tryBoost(now);
    if(keys["KeyE"]) tryMine(now);

    player.fireHeld = mouseDownL;
    player.chargeHeld = mouseDownR;
  }

  // auto forward drift (keeps the orbit feeling alive)
  const drift = 0.18;
  const basePhiSpeed = 0.65;
  const inputPhi = clamp(moveX, -1, 1);
  const speedMul = (player.boostT>0) ? 1.6 : 1.0;

  const phiSpeed = (basePhiSpeed*(drift + inputPhi*0.9)) * speedMul;
  player.phi += phiSpeed * dt;

  // altitude
  const altSpeed = 8.0;
  player.alt = clamp(player.alt + moveY*altSpeed*dt, player.altMin, player.altMax);

  // position on equator
  const r = PLANET_R + player.alt;
  const pos = spherical(r, 0, player.phi);
  ship.position.copy(pos);

  // local basis
  const {up, east, north} = localBasis(pos);
  // travel direction follows phiSpeed sign
  const travelDir = east.clone().multiplyScalar(Math.sign(phiSpeed || 1)).normalize();

  // aim
  const aimDir = computeAimDir(pos, travelDir);

  // orient ship: forward = aimDir (for satisfying feedback), up = radial
  orientObject(ship, aimDir, up);

  // engine glow stronger with boost
  engineGlow.scale.setScalar( (player.boostT>0) ? 1.25 : 1.0 );
  engineGlow.material.emissiveIntensity = (player.boostT>0) ? 2.8 : 2.2;

  // camera
  const camBehind = 8 + ((player.boostT>0)?2:0);
  const camUp = 3.0;
  const camSide = 0.0;

  const desiredPos = pos.clone()
    .add(aimDir.clone().multiplyScalar(-camBehind))
    .add(up.clone().multiplyScalar(camUp))
    .add(north.clone().multiplyScalar(camSide));

  camera.position.lerp(desiredPos, 1 - Math.pow(0.0001, dt)); // smooth independent of fps
  const lookAt = pos.clone().add(aimDir.clone().multiplyScalar(30));
  const curLook = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(30).add(camera.position);
  const blendedLook = curLook.lerp(lookAt, 1 - Math.pow(0.001, dt));
  camera.lookAt(blendedLook);

  // shooting
  const fireInterval = BASE_FIRE_INTERVAL / player.fireRateMul;
  if(player.fireHeld && now >= nextShotT){
    const muzzle = pos.clone().add(aimDir.clone().multiplyScalar(3.2)).add(up.clone().multiplyScalar(0.3));
    const dmg = 8 * player.dmgMul;
    spawnBullet(muzzle, aimDir, dmg, false, BULLET_SPEED, 1.7, false);
    nextShotT = now + fireInterval;
  }

  // charge shot (right click / optional)
  if(player.chargeHeld){
    player.chargeT = clamp(player.chargeT + dt, 0, 1.25);
  }else{
    if(player.chargeT > 0.25){
      const pow = clamp(player.chargeT/1.25, 0, 1);
      const muzzle = pos.clone().add(aimDir.clone().multiplyScalar(3.0)).add(up.clone().multiplyScalar(0.3));
      const dmg = (20 + 60*pow) * player.dmgMul;
      spawnBullet(muzzle, aimDir, dmg, false, BULLET_SPEED*0.88, 2.0, true);
      spawnFXExplosion(muzzle, 0.65 + pow*0.55, 0x58b6ff);
    }
    player.chargeT = 0;
  }

  // timers
  if(player.invulnT>0) player.invulnT = Math.max(0, player.invulnT - dt);
  if(player.boostT>0) player.boostT = Math.max(0, player.boostT - dt);
}

function updateBullets(dt){
  function step(list, isEnemy){
    for(let i=list.length-1;i>=0;i--){
      const b = list[i];
      b.life -= dt;
      b.pos.addScaledVector(b.vel, dt);
      b.mesh.position.copy(b.pos);
      // fade a bit
      if(b.life < 0.35) b.mesh.material.opacity = Math.max(0, b.life/0.35);

      if(b.life <= 0){
        scene.remove(b.mesh);
        list.splice(i,1);
      }
    }
  }
  step(objects.bullets, false);
  step(objects.ebullets, true);
}

function updateMines(dt){
  for(let i=objects.mines.length-1;i>=0;i--){
    const m = objects.mines[i];
    m.t += dt;
    // shimmer
    m.mesh.scale.setScalar(1 + 0.15*Math.sin(m.t*10));
    // check enemy proximity
    for(let j=objects.enemies.length-1;j>=0;j--){
      const e = objects.enemies[j];
      const d = e.mesh.position.distanceTo(m.mesh.position);
      if(d < m.r){
        // explode
        spawnFXExplosion(m.mesh.position.clone(), 1.25, 0xffd166);
        // damage nearby enemies
        for(let k=objects.enemies.length-1;k>=0;k--){
          const ee = objects.enemies[k];
          const dd = ee.mesh.position.distanceTo(m.mesh.position);
          if(dd < 9.0){
            ee.hp -= 80;
            if(ee.hp <= 0){
              killEnemy(k);
            }
          }
        }
        scene.remove(m.mesh);
        objects.mines.splice(i,1);
        break;
      }
    }
    if(m.t >= m.dur){
      scene.remove(m.mesh);
      objects.mines.splice(i,1);
    }
  }
}

function killEnemy(idx){
  const e = objects.enemies[idx];
  addScore(50 + (e.type==="meteor"?35:0) + (e.type==="sniper"?40:0) + (e.type==="jammer"?30:0));
  spawnFXExplosion(e.mesh.position.clone(), e.type==="meteor"?1.5:1.0, 0x58b6ff);
  scene.remove(e.mesh);
  objects.enemies.splice(idx,1);
}

function updateEnemies(dt, now){
  let jammerNear = false;

  for(let i=objects.enemies.length-1;i>=0;i--){
    const e = objects.enemies[i];
    e.t += dt;

    // fall toward planet
    e.r -= e.fall * dt;
    // orbit
    e.phi += e.phiVel * dt;

    // update position
    const pos = spherical(e.r, e.lat, e.phi);
    e.mesh.position.copy(pos);

    // face roughly toward planet + some tangent
    const {up, east} = localBasis(pos);
    const tang = east.clone().multiplyScalar(Math.sign(e.phiVel||1)).normalize();
    orientObject(e.mesh, tang, up);

    // special behaviors
    if(e.type==="jammer"){
      if(pos.distanceTo(ship.position) < 38) jammerNear = true;
    }

    if(e.type==="sniper"){
      // shoot at player with telegraphed charge
      e.nextShot -= dt;
      if(e.nextShot <= 0){
        e.nextShot = 2.4 + Math.random()*0.6;
        // small warning fx
        spawnFXExplosion(pos.clone(), 0.6, 0xa9ffdc);
        const dirToPlayer = ship.position.clone().sub(pos).normalize();
        spawnBullet(pos.clone().add(dirToPlayer.clone().multiplyScalar(2.0)), dirToPlayer, 12, true, 140, 2.0, false);
      }
    }

    // collision with planet surface
    if(e.r <= PLANET_R + 0.7){
      dealPlanetDamage(e.dmgPlanet);
      spawnFXExplosion(pos.clone(), 1.6, 0xff5c7a);
      scene.remove(e.mesh);
      objects.enemies.splice(i,1);
      continue;
    }

    // simple body-collision with player
    const hitR = (e.type==="meteor") ? 2.5 : 1.8;
    if(pos.distanceTo(ship.position) < hitR + 1.2){
      dealPlayerDamage(e.type==="meteor" ? 18 : 10);
      spawnFXExplosion(pos.clone(), 1.2, 0xff5c7a);
      scene.remove(e.mesh);
      objects.enemies.splice(i,1);
      continue;
    }
  }

  noise.classList.toggle("on", jammerNear);
}

function updateBoss(dt, now){
  const b = objects.boss;
  if(!b) return;

  // phase thresholds
  const hpPct = b.hp / b.maxHp;
  b.phase = (hpPct > 0.62) ? 1 : (hpPct > 0.25) ? 2 : 3;

  // orbit
  b.phi += b.phiVel * dt;
  const pos = spherical(b.r, b.lat, b.phi);
  b.group.position.copy(pos);

  // orient along tangent
  const {up, east} = localBasis(pos);
  const forward = east.clone().multiplyScalar(1).normalize();
  orientObject(b.group, forward, up);

  // attacks
  b.nextBurst -= dt;
  if(b.nextBurst <= 0){
    b.nextBurst = (b.phase===1) ? 0.75 : (b.phase===2) ? 0.60 : 0.48;
    // burst toward player
    const dir0 = ship.position.clone().sub(pos).normalize();
    for(let i=0;i<3;i++){
      const spread = (i-1)*0.06;
      const axis = up.clone().cross(dir0).normalize();
      const q = new THREE.Quaternion().setFromAxisAngle(axis, spread);
      const d = dir0.clone().applyQuaternion(q).normalize();
      spawnBullet(pos.clone().add(d.clone().multiplyScalar(8)), d, (b.phase===3)?10:8, true, 145, 2.2, false);
    }
  }

  b.nextDrop -= dt;
  if(b.nextDrop <= 0){
    b.nextDrop = (b.phase===1) ? 6.0 : (b.phase===2) ? 4.6 : 3.6;
    // drop drones
    const n = (b.phase===3) ? 3 : 2;
    for(let i=0;i<n;i++){
      spawnEnemy("swarm");
    }
  }

  // win
  if(b.hp <= 0){
    spawnFXExplosion(pos.clone(), 2.8, 0xffd166);
    scene.remove(b.group);
    objects.boss = null;
    endGame(true, "リング母艦を撃破しました！");
  }
}

function bulletCollisions(){
  // player bullets vs enemies & boss
  for(let i=objects.bullets.length-1;i>=0;i--){
    const b = objects.bullets[i];
    let hit = false;

    // vs enemies
    for(let j=objects.enemies.length-1;j>=0;j--){
      const e = objects.enemies[j];
      const r = (e.type==="meteor") ? 2.4 : 1.6;
      if(b.pos.distanceTo(e.mesh.position) < (b.r + r)){
        e.hp -= b.dmg;
        spawnFXExplosion(b.pos.clone(), 0.55, 0x58b6ff);
        hit = true;
        if(e.hp <= 0) killEnemy(j);
        break;
      }
    }

    // vs boss
    const boss = objects.boss;
    if(!hit && boss){
      const corePos = boss.core.getWorldPosition(new THREE.Vector3());
      const dCore = b.pos.distanceTo(corePos);
      const dBody = b.pos.distanceTo(boss.group.position);
      if(dCore < (b.r + 1.35)){
        boss.hp -= b.dmg * 1.55; // weakpoint
        spawnFXExplosion(b.pos.clone(), 0.75, 0xffd166);
        hit = true;
      }else if(dBody < (b.r + 6.8)){
        boss.hp -= b.dmg * 0.55;
        spawnFXExplosion(b.pos.clone(), 0.60, 0x58b6ff);
        hit = true;
      }
    }

    if(hit){
      scene.remove(b.mesh);
      objects.bullets.splice(i,1);
    }
  }

  // enemy bullets vs player
  for(let i=objects.ebullets.length-1;i>=0;i--){
    const b = objects.ebullets[i];
    if(b.pos.distanceTo(ship.position) < (b.r + 1.2)){
      dealPlayerDamage(b.dmg);
      scene.remove(b.mesh);
      objects.ebullets.splice(i,1);
    }
  }
}

function updateFX(dt){
  for(let i=objects.fx.length-1;i>=0;i--){
    const f = objects.fx[i];
    f.t += dt;
    const p = clamp(f.t / f.dur, 0, 1);
    f.mesh.scale.setScalar(f.scale * (1 + 1.7*p));
    f.mesh.material.opacity = 0.7 * (1 - p);
    if(p>=1){
      scene.remove(f.mesh);
      objects.fx.splice(i,1);
    }
  }
}

/* ---------- Game loop ---------- */
function animate(){
  requestAnimationFrame(animate);

  // tiny planet motion
  planet.rotation.y += 0.02 * clock.getDelta(); // will be overwritten below if we call getDelta twice

  const dt = Math.min(0.033, clock.getDelta());
  const now = perfNow();

  // rotate clouds for nice motion
  clouds.rotation.y += 0.05 * dt;
  planet.rotation.y += 0.012 * dt;

  if(state === "playing"){
    updatePlayer(dt, now);
    waveSys.update(dt, now);
    updateEnemies(dt, now);
    updateBoss(dt, now);
    updateBullets(dt);
    updateMines(dt);
    bulletCollisions();
    updateFX(dt);
    updateHUD(now);
  }else if(state==="upgrading"){
    // keep subtle world motion
    updateHUD(now);
  }

  renderer.render(scene, camera);
}
animate();

/* ---------- Resize ---------- */
window.addEventListener("resize", ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight, false);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  updateRotateHint();
});

/* ---------- Extra keyboard shortcuts ---------- */
window.addEventListener("keydown", (e)=>{
  if(state!=="playing") return;
  if(e.code==="KeyE") tryMine(perfNow());
});

/* ---------- Safety: pause input when not playing ---------- */
function setUIForState(){
  if(state==="title"){
    screens.start.style.display = "flex";
    screens.upgrade.style.display = "none";
    screens.result.style.display = "none";
  }
}
setUIForState();
</script>
</body>
</html>
