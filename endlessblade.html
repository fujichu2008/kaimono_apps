<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="theme-color" content="#0a0f18" />
<title>Endless Blade: Clockwork Ascent (Vertical / iPhone Fullscreen)</title>
<style>
  :root{
    --bg:#0a0f18; --bg2:#0e1421;
    --hud:#e6ecff; --muted:#93a4c6; --accent:#6ea8fe; --danger:#ff5a7a; --ok:#2ae59b; --gold:#ffd36b;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--hud);
    font-family:system-ui,-apple-system,"Hiragino Sans","Noto Sans JP",sans-serif;overscroll-behavior:none}
  body{touch-action:none; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none}
  .wrap{height:100dvh;display:grid;place-items:center}
  canvas{image-rendering: pixelated; image-rendering: crisp-edges; background:transparent; display:block; touch-action:none}
  #hud{
    position:fixed; inset:0 0 auto 0; display:flex; justify-content:space-between; gap:8px;
    padding:10px 12px; font-weight:700; font-variant-numeric: tabular-nums;
    background:linear-gradient(180deg,rgba(0,0,0,.55),rgba(0,0,0,0));
    pointer-events:none
  }
  #hud .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.1);padding:6px 10px;border-radius:12px}
  #hpBar{width:min(40vw,220px);height:12px;border:1px solid rgba(255,255,255,.25);border-radius:12px;overflow:hidden}
  #hpBar > i{display:block;height:100%;background:linear-gradient(90deg,var(--ok),#7cffc8);width:100%}
  #buffs{display:flex;gap:6px;align-items:center}
  .buff{display:inline-grid;place-items:center;width:28px;height:28px;border-radius:50%;border:1px solid #2a3a66;background:#111a2a;font-size:12px}
  #bossBar{
    position:fixed; inset:auto 8px 8px 8px; display:none; gap:8px; align-items:center;
    padding:8px; background:linear-gradient(180deg,rgba(0,0,0,.35),rgba(0,0,0,.15)); border:1px solid #1e2a44; border-radius:10px
  }
  #bossHP{flex:1;height:10px;border:1px solid rgba(255,255,255,.25); border-radius:12px; overflow:hidden}
  #bossHP > i{display:block;height:100%;background:linear-gradient(90deg,#ff7a7a,#ff3d6e);width:100%}
  #startOverlay{
    position:fixed; inset:0; display:grid; place-items:center; background:radial-gradient(1200px 600px at 50% 40%, rgba(255,255,255,.06), rgba(0,0,0,.75));
    text-align:center; padding:20px; z-index:10;
  }
  #startOverlay .card{
    width:min(780px,92%); background:rgba(10,15,24,.85); border:1px solid #1e2a44; border-radius:16px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.4)
  }
  h1{margin:.1em 0 .4em; font-size:20px}
  .tap{margin-top:10px; font-weight:800; color:var(--accent); letter-spacing:.04em}
  .hint{color:var(--muted); font-size:13px; line-height:1.6}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a3a66; background:#111a2a; color:#cfe1ff; font-size:12px}
  #result{
    position:fixed; inset:0; display:none; place-items:center; background:radial-gradient(1000px 500px at 50% 40%, rgba(255,255,255,.08), rgba(0,0,0,.85));
    z-index:20; text-align:center; padding:20px;
  }
  #result .card{ width:min(720px,92%); background:rgba(10,15,24,.9); border:1px solid #2a3a66; border-radius:16px; padding:18px }
  .btn{display:inline-block; margin-top:12px; padding:10px 14px; border-radius:10px; border:1px solid #2a3a66; background:#172036; color:#e9f1ff}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" aria-label="Endless Blade: Clockwork Ascent"></canvas>
</div>

<!-- HUD -->
<div id="hud">
  <div class="pill">SCORE <span id="score">000000</span></div>
  <div class="pill">COMBO <span id="combo">0</span></div>
  <div class="pill" style="display:flex;align-items:center;gap:8px">HP
    <span id="hpNum">100</span>
    <span id="hpBar"><i id="hpFill"></i></span>
  </div>
  <div id="buffs">
    <div class="buff" id="buffI" title="Invincible">I</div>
    <div class="buff" id="buffR" title="Radius Up">R</div>
    <div class="buff" id="buffH" title="HP Power">H</div>
  </div>
</div>

<!-- Boss Bar -->
<div id="bossBar">
  <span>⚙️ BASTION</span>
  <div id="bossHP"><i id="bossFill"></i></div>
</div>

<!-- Start Overlay -->
<div id="startOverlay" role="button" aria-label="Tap to Start">
  <div class="card">
    <h1>⚔️ ENDLESS BLADE — CLOCKWORK ASCENT</h1>
    <div class="hint">
      <span class="badge">ドラッグ</span> 主人公を移動　
      <span class="badge">剣</span> 自動回転（360°）　
      <span class="badge">敵に近づく</span> 斬撃加点　
      <span class="badge">弾は回避</span> 被弾でライフ減／コンボ切れ
      <br>アイテム：<b>I</b>無敵  <b>R</b>剣半径UP  <b>H</b>体力強化（赤撃破可能）
      <br><b>60秒でBoss「クロック・バスティオン」</b>
      <br>画面をタップで開始（iPhoneのオーディオ解錠が必要）
    </div>
    <div class="tap">▶ TAP TO START</div>
  </div>
</div>

<!-- Result -->
<div id="result">
  <div class="card">
    <h2 id="resTitle">VICTORY!</h2>
    <div style="font-variant-numeric:tabular-nums; margin-top:8px">
      <div>Score: <b id="resScore">0</b></div>
      <div>Max Combo: <b id="resCombo">0</b></div>
      <div>Time: <b id="resTime">0.0s</b></div>
    </div>
    <button class="btn" id="retryBtn">↻ RETRY</button>
  </div>
</div>

<script>
/* ================================
   Canvas セットアップ（iPhoneフル）
==================================*/
const cvs=document.getElementById('game');
const ctx=cvs.getContext('2d');
let W=360, H=640, DPR=1;

function fit(){
  // フルスクリーン＋ピクセル感（少しドット）
  DPR = Math.max(1, Math.min(3, Math.floor(window.devicePixelRatio || 1)));
  W = Math.floor(window.innerWidth / DPR);
  H = Math.floor(window.innerHeight / DPR);
  cvs.width  = W;
  cvs.height = H;
  cvs.style.width  = window.innerWidth + 'px';
  cvs.style.height = window.innerHeight + 'px';
}
window.addEventListener('resize', fit, {passive:true});
fit();

/* ============ Util ============ */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
function rnd(a,b){ return Math.random()*(b-a)+a; }
function rndi(a,b){ return (Math.random()*(b-a+1)|0)+a; }
function chance(p){ return Math.random()<p; }
function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

/* ============ HUD refs ============ */
const scoreEl=document.getElementById('score');
const comboEl=document.getElementById('combo');
const hpNum=document.getElementById('hpNum');
const hpFill=document.getElementById('hpFill');
const buffI=document.getElementById('buffI');
const buffR=document.getElementById('buffR');
const buffH=document.getElementById('buffH');
const bossBar=document.getElementById('bossBar');
const bossFill=document.getElementById('bossFill');
const overlay=document.getElementById('startOverlay');
const resultEl=document.getElementById('result');
const resTitle=document.getElementById('resTitle');
const resScore=document.getElementById('resScore');
const resCombo=document.getElementById('resCombo');
const resTime=document.getElementById('resTime');
document.getElementById('retryBtn').onclick=()=>{ resultEl.style.display='none'; startAll(); };

/* ============ Game State ============ */
let running=false, paused=false, t=0, last=0, dt=0, startTime=0;
let score=0, combo=0, maxCombo=0, hp=100, timeToBoss=60, boss=null, gameWon=false;

function addScore(n){ score+=n; scoreEl.textContent=String(score).padStart(6,'0'); }
function addCombo(n=1){
  combo+=n; if(combo>maxCombo) maxCombo=combo;
  comboEl.textContent=combo;
}
function resetCombo(){ combo=0; comboEl.textContent=combo; }

/* ============ Player ============ */
const player={
  x:W*0.5, y:H*0.75, r:9, // 本体半径
  tx:W*0.5, ty:H*0.75, // タッチ追従
  spd: 900, // 追従スピード（px/s）
  swordR: 28, // 刃半径
  swordAng: 0, // 現在角
  swordVel: 17.5, // rad/s（2.8回転/s）
  inv:0, radiusUp:0, hpPower:0, // バフタイマー
};
let invul=0; // 被弾直後の軽い無敵

/* ============ Touch Move ============ */
let trackingId=null;
function pointFromEvent(e){
  const t=(e.changedTouches? e.changedTouches[0] : e);
  const rect=cvs.getBoundingClientRect();
  const x=(t.clientX-rect.left)/rect.width * W;
  const y=(t.clientY-rect.top)/rect.height* H;
  return {x,y,id:t.identifier ?? 0};
}
cvs.addEventListener('pointerdown',e=>{
  if(!running) return;
  const p=pointFromEvent(e);
  trackingId = p.id;
  player.tx=p.x; player.ty=p.y;
});
cvs.addEventListener('pointermove',e=>{
  if(!running) return;
  if(trackingId===null) return;
  const p=pointFromEvent(e);
  player.tx=p.x; player.ty=p.y;
});
cvs.addEventListener('pointerup',()=>{ trackingId=null; });

/* ============ Entities ============ */
const enemies=[]; // {type,x,y,r,hp,vx,vy,color,shootT}
const bullets=[]; // {x,y,vx,vy,r}
const items=[];   // {x,y,vx,vy,type,t}

const ENEMY_TYPES={
  drone:{ r:12, hp:1, score:100, color:'#9aa7b7', vy:[90,140], shoot:true, shootRate:[1.2,1.8], bulletV:150 },
  spinner:{ r:13, hp:1, score:150, color:'#6eb6ff', vy:[70,110], vx:[-40,40], shoot:false },
  lancer:{ r:14, hp:1, score:200, color:'#c9b38a', vy:[110,180], shoot:true, shootRate:[1.5,2.2], bulletV:190 },
  red:{ r:16, hp:6, score:1500, color:'#ff3d6e', vy:[80,130], shoot:true, shootRate:[1.0,1.5], bulletV:170 }
};
function spawnEnemy(kind){
  const t=ENEMY_TYPES[kind]; if(!t) return;
  const ex=rnd(20, W-20), ey=-20;
  const vy=rnd(t.vy[0],t.vy[1]); const vx = t.vx? rnd(t.vx[0],t.vx[1]) : 0;
  enemies.push({type:kind, x:ex, y:ey, r:t.r, hp:t.hp, vx, vy, shootT:rnd(0.3,1.2), color:t.color});
}
function shootFrom(e){
  bullets.push({x:e.x, y:e.y+e.r, vx:0, vy: (ENEMY_TYPES[e.type].bulletV||160), r:3, color:'#ffed6b'});
  sfxShoot();
}
function spawnItem(x,y){
  // ドロップ抽選（I 8% / R 10% / H 7%）
  const roll = Math.random();
  let type=null;
  if(roll<0.08) type='I';
  else if(roll<0.18) type='R';
  else if(roll<0.25) type='H';
  if(!type) return;
  items.push({x,y,vx:rnd(-30,30), vy:rnd(40,70), type, t:0});
}

/* ============ Difficulty & Spawns ============ */
let enemyTimer=0, bulletCap=6;
function updateSpawns(){
  // スケーリング：時間で徐々に
  if(t<20){ bulletCap=6; }
  else if(t<40){ bulletCap=10; }
  else if(t<60){ bulletCap=14; }
  else{ bulletCap=18; }

  enemyTimer-=dt;
  const baseRate = t<20 ? 0.8 : t<40 ? 0.6 : t<60 ? 0.48 : 0.45; // 小さいほど多い
  if(enemyTimer<=0){
    // 種類ミックス
    const pool = t<20 ? ['drone','spinner'] :
                 t<40 ? ['drone','spinner','lancer'] :
                        ['drone','spinner','lancer','red'];
    spawnEnemy(pool[rndi(0,pool.length-1)]);
    enemyTimer = rnd(baseRate*0.6, baseRate*1.4);
  }
}

/* ============ Boss A：Clockwork Bastion ============ */
function enterBoss(){
  boss = {
    phase:0, hp: 3000, hpMax:3000, x:W*0.5, y:80, t:0, rot:0,
    turrets: Array.from({length:6}, (_,i)=>({ang:(i/6)*Math.PI*2, alive:true})),
    laser:false, laserAng:0, laserT:0
  };
  bossBar.style.display='flex';
  // BGMアレンジ（ブラス/ハイハット強調、リバーブSend↑）
  bgmSetBossArrangement(true);
}
function updateBoss(){
  if(!boss) return;
  boss.t+=dt; boss.rot += 0.4*dt;

  // フェーズ：外殻→砲塔リング→コア
  // ここでは砲塔リングだけをシンプル実装（外殻は当たり判定の大円として扱う）
  // 砲塔：一定間隔で散弾、時折回転レーザー
  if(boss.hp <= 0){
    // 撃破
    bossBar.style.display='none';
    sfxFanfare();
    gameWon=true;
    showResult(true);
    running=false;
    bgmFadeOut(0.6); // 余韻後に止める（演出用）
    return;
  }

  // 砲塔射撃
  for(const t of boss.turrets){
    if(!t.alive) continue;
    if(Math.random()<0.02){
      const a = t.ang + boss.rot;
      const px = boss.x + Math.cos(a)*80;
      const py = boss.y + Math.sin(a)*80;
      // 放射3発
      for(let k=-1;k<=1;k++){
        const ang = a + k*0.15;
        bullets.push({x:px, y:py, vx:Math.cos(ang)*140, vy:Math.sin(ang)*140, r:3, color:'#ffce6b'});
      }
      sfxShoot();
    }
  }

  // レーザー（簡易）：たまに回転線ダメージ
  if(!boss.laser && Math.random()<0.004){
    boss.laser=true; boss.laserAng=rnd(0,Math.PI*2); boss.laserT=2.8; sfxLaser();
  }
  if(boss.laser){
    boss.laserAng += 0.8*dt;
    boss.laserT -= dt;
    if(boss.laserT<=0){ boss.laser=false; }
    // プレイヤーが線に触れたら被弾（線分近傍判定）
    if(lineHitPlayer(boss.x,boss.y,boss.laserAng,110, player.x,player.y, player.r+(player.inv>0? -999:0))){
      onPlayerHit(14);
    }
  }

  // プレイヤー剣が砲塔や本体にヒット
  const bladeR = player.swordR + (player.radiusUp>0?12:0);
  // 砲塔群
  for(const t of boss.turrets){
    if(!t.alive) continue;
    const a=t.ang + boss.rot;
    const ex=boss.x + Math.cos(a)*80, ey=boss.y + Math.sin(a)*80;
    if(circleArcHit(ex,ey,10, player.x,player.y, bladeR, player.swordAng, 0.9)){
      t.alive=false; boss.hp -= 150; addScore(400); addCombo(1); sfxBreak();
    }
  }
  // 本体中心（コア露出想定：タレット破壊数が一定以上で実ダメ）
  const deadTurrets = boss.turrets.filter(t=>!t.alive).length;
  const coreOpen = deadTurrets>=4;
  if(coreOpen && circleArcHit(boss.x,boss.y,26, player.x,player.y, bladeR, player.swordAng, 0.9)){
    boss.hp -= 12; addScore(10);
  }

  // 画面描画は draw() 側
}
function lineHitPlayer(cx,cy,ang,len, px,py, pr){
  // 線分：中心(cx,cy)から角度angで長さlen、プレイヤー円との最短距離
  const x2=cx+Math.cos(ang)*len, y2=cy+Math.sin(ang)*len;
  const dx=x2-cx, dy=y2-cy;
  const t = clamp(((px-cx)*dx + (py-cy)*dy)/(dx*dx+dy*dy), 0, 1);
  const nx=cx+dx*t, ny=cy+dy*t;
  return dist2(nx,ny,px,py) <= pr*pr;
}

/* ============ Items & Buffs ============ */
function applyItem(type){
  if(type==='I'){ player.inv = Math.max(player.inv, 4.0); }
  if(type==='R'){ player.radiusUp = Math.max(player.radiusUp, 8.0); }
  if(type==='H'){ player.hpPower = Math.max(player.hpPower, 10.0); hp = clamp(hp+25,0,100); hpNum.textContent=hp; hpFill.style.width=hp+'%'; }
  sfxPickup(type);
}

/* ============ Collisions Helpers ============ */
function circleArcHit(ex,ey,er, cx,cy, R, ang, arcWidth){ 
  // プレイヤーの回転剣：中心(cx,cy)、半径R、角ang（0..2π）付近の弧幅arcWidth[rad]
  // 近似：弧の中心点と±幅の3点でチェック
  const pts = [0, -arcWidth*0.5, +arcWidth*0.5].map(d=>{
    const a=ang+d; return {x:cx+Math.cos(a)*R, y:cy+Math.sin(a)*R};
  });
  for(const p of pts){
    if(dist2(p.x,p.y, ex,ey) <= (er+3)*(er+3)) return true;
  }
  return false;
}

/* ============ Damage / End / Result ============ */
function onPlayerHit(dmg){
  if(player.inv>0 || invul>0) return;
  hp = clamp(hp-dmg,0,100);
  hpNum.textContent=hp; hpFill.style.width=hp+'%';
  invul=0.35; resetCombo(); sfxHurt();
  // ほんの少しゲームスロウ演出
  slowTimer = 0.12;
  if(hp<=0){
    // Game Over
    running=false;
    bgmFadeOut(0.6);
    resTitle.textContent='DEFEATED...';
    showResult(false);
  }
}
function showResult(victory){
  resultEl.style.display='grid';
  resScore.textContent = score;
  resCombo.textContent = maxCombo;
  resTime.textContent  = t.toFixed(1)+'s';
}

/* ============ Main Update/Draw ============ */
let slowTimer=0;
function update(ts){
  if(!running || paused) return;
  if(!last) last=ts;
  dt = (ts-last)/1000;
  last=ts;
  // スロウ演出
  const slowFactor = slowTimer>0 ? 0.5 : 1.0;
  if(slowTimer>0) slowTimer-=dt;

  dt = Math.min(0.033, dt)*slowFactor; // clamp

  t += dt;
  if(!boss){
    timeToBoss = Math.max(0, 60 - t);
    if(timeToBoss<=0){ enterBoss(); }
  }

  // 移動（タッチ追従：スムーズ）
  const k = 1 - Math.pow(0.0001, dt); // イージング係数（dtに依存）
  player.x = lerp(player.x, clamp(player.tx, 16, W-16), k);
  player.y = lerp(player.y, clamp(player.ty, 40, H-40), k);

  // 剣回転：時間で少し加速、Rバフ中は+20%
  const speedBoost = player.radiusUp>0 ? 1.2 : 1.0;
  const timeGain = 1 + Math.min(0.3, t/180); // 3分で+30%まで
  player.swordAng = (player.swordAng + player.swordVel * speedBoost * timeGain * dt) % (Math.PI*2);

  // バフ減衰
  if(player.inv>0) player.inv-=dt;
  if(player.radiusUp>0) player.radiusUp-=dt;
  if(player.hpPower>0) player.hpPower-=dt;
  buffI.style.opacity = player.inv>0?1:0.25;
  buffR.style.opacity = player.radiusUp>0?1:0.25;
  buffH.style.opacity = player.hpPower>0?1:0.25;

  // スポーン
  if(!boss) updateSpawns();

  // 敵更新／撃破判定
  const bladeR = player.swordR + (player.radiusUp>0?12:0);
  for(const e of enemies){
    e.x += e.vx*dt;
    e.y += e.vy*dt;
    if(e.shootT!==undefined){
      e.shootT -= dt;
      if(e.shootT<=0 && bullets.length<bulletCap){
        // 弾を撃つ
        if(ENEMY_TYPES[e.type].shoot){
          const aim = Math.atan2(player.y-e.y, player.x-e.x);
          const spd = ENEMY_TYPES[e.type].bulletV || 160;
          bullets.push({x:e.x, y:e.y, vx:Math.cos(aim)*spd, vy:Math.sin(aim)*spd, r:3, color:'#ffed6b'});
          sfxShoot();
        }
        const r=ENEMY_TYPES[e.type].shootRate||[1.5,2.5];
        e.shootT = rnd(r[0],r[1]);
      }
    }
    // プレイヤー剣に触れたら撃破（赤はHPパワー中のみ）
    const canDamageRed = (e.type!=='red') || (player.hpPower>0);
    if(canDamageRed && circleArcHit(e.x,e.y,e.r, player.x,player.y, bladeR, player.swordAng, 1.0)){
      e.hp -= 1;
      if(e.hp<=0){
        addScore(ENEMY_TYPES[e.type].score);
        addCombo(1);
        spawnItem(e.x,e.y);
        e.dead=true; sfxHit();
      }
    }
    // 画面外下に落ちたら消す
    if(e.y > H+40) e.dead=true;
  }

  // 弾
  for(const b of bullets){ b.x+=b.vx*dt; b.y+=b.vy*dt; }
  // 弾→プレイヤー
  for(const b of bullets){
    if(dist2(b.x,b.y, player.x,player.y) <= (player.r + (player.inv>0?-999:0))**2){
      onPlayerHit( rndi(10,16) ); b.dead=true;
    }
  }

  // アイテム
  for(const it of items){ it.x+=it.vx*dt; it.y+=it.vy*dt; it.vy += 10*dt; it.t+=dt;
    if(dist2(it.x,it.y, player.x,player.y) <= (player.r+10)**2){
      applyItem(it.type); it.dead=true;
    }
    if(it.y>H+30) it.dead=true;
  }

  // Boss
  if(boss) updateBoss();

  // 掃除
  prune(enemies, e=>e.dead||e.y>H+50);
  prune(bullets, b=>b.dead|| b.y<-40 || b.y>H+60 || b.x<-40 || b.x>W+40);
  prune(items, i=>i.dead);

  // 描画
  draw();

  requestAnimationFrame(update);
}
function prune(arr, pred){ for(let i=arr.length-1;i>=0;i--) if(pred(arr[i])) arr.splice(i,1); }

/* ============ Draw ============ */
function draw(){
  ctx.clearRect(0,0,W,H);

  // 背景：遠景ギアの縦流れ（少しドット風にスナップ）
  const rows=12, cols=8, tScroll = t*40;
  for(let i=0;i<rows;i++){
    for(let j=0;j<cols;j++){
      const gx = Math.floor((j+0.5)*W/cols);
      const gy = Math.floor(((i*H/rows + (tScroll % (H/rows))) % H));
      const r  = ((i+j)%3)+3;
      ctx.beginPath();
      ctx.arc(gx, gy, r, 0, Math.PI*2);
      ctx.fillStyle='rgba(180,200,255,.06)';
      ctx.fill();
    }
  }

  // アイテム
  for(const it of items){
    const c = it.type==='I'? '#7cffc8' : it.type==='R'? '#cfe1ff' : '#ffd36b';
    ctx.fillStyle=c; ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.arc(Math.round(it.x), Math.round(it.y), 7, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#0a0f18'; ctx.font='bold 10px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(it.type, Math.round(it.x), Math.round(it.y)+1);
  }

  // 敵（ややドット風シルエット）
  for(const e of enemies){
    ctx.fillStyle=e.color;
    ctx.strokeStyle='rgba(255,255,255,.12)';
    const x=Math.round(e.x), y=Math.round(e.y);
    // 本体
    ctx.fillRect(x- (e.r-4), y-(e.r-6), (e.r-4)*2, (e.r-6)*2);
    // 目
    ctx.fillStyle = (e.type==='red') ? '#ff6b7a' : '#6ec1ff';
    ctx.fillRect(x-3, y-3, 6, 3);
  }

  // Boss
  if(boss){
    // 外殻リング
    ctx.save();
    ctx.translate(boss.x, boss.y);
    ctx.rotate(boss.rot);
    // ギア外輪
    ctx.strokeStyle='rgba(200,220,255,.2)'; ctx.lineWidth=8;
    ctx.beginPath(); ctx.arc(0,0, 100, 0, Math.PI*2); ctx.stroke();
    // スプロケット風ドット
    for(let k=0;k<24;k++){
      const a=k/24*Math.PI*2;
      ctx.fillStyle='rgba(200,220,255,.12)';
      ctx.fillRect(Math.cos(a)*100-2, Math.sin(a)*100-2, 4,4);
    }
    // タレット
    for(const t of boss.turrets){
      if(!t.alive) continue;
      const a=t.ang;
      const x=Math.cos(a)*80, y=Math.sin(a)*80;
      ctx.fillStyle='#c9b38a'; ctx.fillRect(x-7,y-7,14,14);
      ctx.fillStyle='#ffce6b'; ctx.fillRect(x-2,y-2,4,4);
    }
    // コア（破壊可能時に輝く）
    const deadT=boss.turrets.filter(t=>!t.alive).length;
    const open = deadT>=4;
    ctx.fillStyle = open? 'rgba(255,80,100,.85)' : 'rgba(100,120,160,.6)';
    ctx.beginPath(); ctx.arc(0,0, 26, 0, Math.PI*2); ctx.fill();
    // レーザー表示
    if(boss.laser){
      ctx.strokeStyle='rgba(255,120,160,.85)'; ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(boss.laserAng)*110, Math.sin(boss.laserAng)*110);
      ctx.stroke();
    }
    ctx.restore();

    // Boss HP
    bossFill.style.width = clamp(boss.hp/boss.hpMax*100,0,100)+'%';
  }

  // 弾
  ctx.fillStyle='#ffed6b';
  for(const b of bullets){
    ctx.fillRect(Math.round(b.x)-2, Math.round(b.y)-2, 4,4);
  }

  // プレイヤー影
  ctx.fillStyle='rgba(0,0,0,.35)';
  ctx.beginPath(); ctx.ellipse(Math.round(player.x), Math.round(player.y+player.r+6), 14, 6, 0, 0, Math.PI*2); ctx.fill();

  // プレイヤー（シルエット＋リムライト＋ケープ）
  drawHero();

  // 回転剣：トレイル
  drawBladeTrail();
}

function drawHero(){
  const px=Math.round(player.x), py=Math.round(player.y);
  // ケープ（テール）
  const capeLen = 24;
  const ang = -1.1 + Math.sin(t*4)*0.1;
  const rootX=px-6, rootY=py-18;
  const tipX = rootX + Math.cos(ang)*capeLen;
  const tipY = rootY + Math.sin(ang)*capeLen;
  const g=ctx.createLinearGradient(rootX,rootY, tipX,tipY);
  g.addColorStop(0,'rgba(40,70,120,0.8)');
  g.addColorStop(1,'rgba(10,20,40,0)');
  ctx.fillStyle=g;
  ctx.beginPath();
  ctx.moveTo(rootX,rootY);
  ctx.quadraticCurveTo(rootX-10,rootY+6, tipX,tipY);
  ctx.lineTo(tipX,tipY+4);
  ctx.quadraticCurveTo(rootX-8,rootY+10, rootX,rootY+5);
  ctx.closePath(); ctx.fill();

  // 本体
  ctx.fillStyle = invul>0? 'rgba(255,90,122,.9)' : '#9fc6ff';
  roundCapsule(px-8, py-18, 16, 20, 8, ctx); ctx.fill();
  // 胸装甲
  ctx.fillStyle = invul>0? 'rgba(200,50,80,.9)' : '#7aa8e0';
  roundCapsule(px-8, py-14, 16, 8, 6, ctx); ctx.fill();
  // 頭
  ctx.fillStyle='#cfe7ff'; roundCapsule(px-7, py-26, 14, 9, 5, ctx); ctx.fill();
  // バイザー
  ctx.fillStyle='rgba(110,168,254,.8)'; ctx.fillRect(px-6, py-23, 12, 3);

  // リムライト
  ctx.strokeStyle='rgba(255,255,255,.65)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(px+8,py-16); ctx.lineTo(px+8,py-2); ctx.stroke();
}
function drawBladeTrail(){
  const R = player.swordR + (player.radiusUp>0?12:0);
  const a = player.swordAng;
  const bx = player.x + Math.cos(a)*R;
  const by = player.y + Math.sin(a)*R;

  // トレイル（2層）
  ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.lineWidth=4;
  ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(bx, by); ctx.stroke();
  ctx.strokeStyle='#ffffff'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(bx, by); ctx.stroke();
}
function roundCapsule(x,y,w,h,r,ctx){
  const rr=Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}

/* ============ Start/Over ============ */
function startGame(){
  running=true; paused=false; t=0; last=0; startTime=performance.now(); gameWon=false;
  score=0; combo=0; maxCombo=0; hp=100; hpNum.textContent=hp; hpFill.style.width='100%';
  enemies.length=0; bullets.length=0; items.length=0; boss=null;
  player.x=W*0.5; player.y=H*0.75; player.tx=player.x; player.ty=player.y;
  player.inv=player.radiusUp=player.hpPower=0; invul=0; slowTimer=0;
  scoreEl.textContent='000000'; comboEl.textContent='0';
  bossBar.style.display='none';
  requestAnimationFrame(update);
}

/* ============ Visibility Pause ============ */
document.addEventListener('visibilitychange', ()=>{ paused=document.hidden; });

/* ===========================
   === WebAudio: BGM & SFX ===
=========================== */
let ctxAudio, master, revBus, limiter;
let runningBgm=false, startTimeBgm=0;
const BPM=148, SPB=60/BPM, BEAT=SPB, BAR=SPB*4;
const LOOP_BARS=16, LOOP_END=BAR*LOOP_BARS;
let bossArr=false;

function mtof(n){ return 440 * Math.pow(2,(n-69)/12); }
async function ensureAudio(){
  if(!ctxAudio){
    ctxAudio = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
    master = ctxAudio.createGain(); master.gain.value=0.9;
    const d=ctxAudio.createDelay(3.0); d.delayTime.value=0.19;
    const fb=ctxAudio.createGain(); fb.gain.value=0.28; d.connect(fb).connect(d);
    revBus=d;
    limiter=ctxAudio.createDynamicsCompressor();
    limiter.threshold.value=-10; limiter.ratio.value=12; limiter.attack.value=0.002; limiter.release.value=0.12;
    master.connect(limiter); revBus.connect(limiter); limiter.connect(ctxAudio.destination);
  }
  if(ctxAudio.state==='suspended') await ctxAudio.resume();
  return ctxAudio;
}
function env(node,t0,a=0.01,d=0.1,s=0.6,r=0.08,peak=1.0){
  const g=node.gain; g.cancelScheduledValues(t0);
  g.setValueAtTime(0.0001,t0);
  g.linearRampToValueAtTime(peak,t0+a);
  g.linearRampToValueAtTime(s*peak,t0+a+d);
  return (rel)=>{ g.cancelScheduledValues(rel); g.setValueAtTime(g.value,rel); g.linearRampToValueAtTime(0.0001, rel+r); };
}
/* --- Timbres --- */
function kick(t,vel=0.9){ const o=ctxAudio.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(95,t); o.frequency.exponentialRampToValueAtTime(42,t+0.08);
  const g=ctxAudio.createGain(); o.connect(g).connect(master); const release=env(g,t,0.001,0.05,0,0.12,vel); o.start(t); release(t+0.12); o.stop(t+0.2);}
function snare(t,vel=0.8){ const nbuf=ctxAudio.createBuffer(1, ctxAudio.sampleRate*0.12, ctxAudio.sampleRate);
  const ch=nbuf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*Math.exp(-i/ch.length*7);
  const ns=ctxAudio.createBufferSource(); ns.buffer=nbuf; const bp=ctxAudio.createBiquadFilter(); bp.type='highpass'; bp.frequency.value=1800;
  const g=ctxAudio.createGain(); ns.connect(bp).connect(g).connect(master); const release=env(g,t,0.001,0.04,0,0.05,vel); ns.start(t); release(t+0.12); ns.stop(t+0.16);}
function hat(t,vel=0.6){ const nbuf=ctxAudio.createBuffer(1, ctxAudio.sampleRate*0.06, ctxAudio.sampleRate);
  const ch=nbuf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*Math.exp(-i/ch.length*10);
  const ns=ctxAudio.createBufferSource(); ns.buffer=nbuf; const hp=ctxAudio.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
  const g=ctxAudio.createGain(); ns.connect(hp).connect(g).connect(master); const release=env(g,t,0.001,0.01,0,0.02,vel); ns.start(t); release(t+0.05); ns.stop(t+0.08);}
function bassNote(t, midi, dur, vel=0.7){ const o=ctxAudio.createOscillator(); o.type='square'; o.frequency.value=mtof(midi);
  const g=ctxAudio.createGain(); o.connect(g).connect(master); const release=env(g,t,0.003,0.05,0.7,0.06,vel); o.start(t); const stopAt=t+dur; release(stopAt); o.stop(stopAt+0.1);}
function staccatoStrings(t, midi, dur, vel=0.5){ const o=ctxAudio.createOscillator(); o.type='sawtooth'; o.frequency.value=mtof(midi);
  const f=ctxAudio.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800;
  const g=ctxAudio.createGain(); o.connect(g).connect(f).connect(master);
  const release=env(g,t,0.002,0.05,0.0,0.04,vel); o.start(t); const stopAt=t+dur; release(stopAt); o.stop(stopAt+0.08);}
function brassHit(t, midi, vel=0.7){ const o=ctxAudio.createOscillator(); o.type='sawtooth'; o.frequency.value=mtof(midi);
  const f=ctxAudio.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400;
  const g=ctxAudio.createGain(); o.connect(g).connect(f).connect(master);
  const release=env(g,t,0.004,0.09,0.0,0.06,vel); o.start(t); const stopAt=t+0.18; release(stopAt); o.stop(stopAt+0.12);}
function lead(t, midi, dur, vel=0.75){ const o=ctxAudio.createOscillator(); o.type='triangle'; o.frequency.value=mtof(midi);
  const g=ctxAudio.createGain(); const d=ctxAudio.createDelay(1.0); d.delayTime.value=0.12; const dg=ctxAudio.createGain(); dg.gain.value= bossArr? 0.35 : 0.25;
  o.connect(g).connect(master); g.connect(d).connect(dg).connect(revBus);
  const release=env(g,t,0.002,0.08,0.5,0.06,vel*(bossArr?1.1:1.0));
  o.start(t); const stopAt=t+dur; release(stopAt); o.stop(stopAt+0.1);}
function tickPerc(t,vel=0.4){ // ボス時の緊迫パーカス
  if(!bossArr) return;
  const o=ctxAudio.createOscillator(); o.type='square'; o.frequency.value=1200;
  const g=ctxAudio.createGain(); o.connect(g).connect(master);
  const release=env(g,t,0.001,0.03,0.0,0.02,vel); o.start(t); release(t+0.05); o.stop(t+0.08);
}
/* Patterns */
const BASS_SEQ=[40,40,38,40,36,38,40,47];
const STR_CHORDS=[[52,55,59],[50,54,57],[48,52,55],[50,54,57]];
const LEAD_PHRASE=[
  {o:0.00,n:71,d:BEAT*0.5},{o:0.50,n:69,d:BEAT*0.5},{o:1.00,n:71,d:BEAT*0.5},{o:1.50,n:74,d:BEAT*0.75},
  {o:2.50,n:72,d:BEAT*0.5},{o:3.00,n:71,d:BEAT*0.5},{o:3.50,n:69,d:BEAT*1.0},
  {o:4.00,n:71,d:BEAT*0.5},{o:4.50,n:74,d:BEAT*0.5},{o:5.00,n:76,d:BEAT*0.75},
  {o:6.00,n:74,d:BEAT*0.5},{o:6.50,n:72,d:BEAT*0.5},{o:7.00,n:71,d:BEAT*0.5},{o:7.50,n:69,d:BEAT*1.0},
];
function scheduleDrums(t0){
  for(let bar=0; bar<LOOP_BARS; bar++){
    const bt=t0+bar*BAR;
    for(let i=0;i<8;i++){ hat(bt+i*BEAT/2, bossArr?0.7:0.55); if(bossArr) tickPerc(bt+i*BEAT/4,0.22); }
    kick(bt+0*BEAT,0.95); kick(bt+2*BEAT,0.9);
    snare(bt+1*BEAT, bossArr?0.92:0.85); snare(bt+3*BEAT, bossArr?0.95:0.88);
    if(bar%8===7){ snare(bt+3.0*BEAT,0.98); snare(bt+3.5*BEAT,0.95); }
  }
}
function scheduleBass(t0){
  for(let bar=0; bar<LOOP_BARS; bar++){
    const note=BASS_SEQ[bar%8], bt=t0+bar*BAR;
    bassNote(bt+0*BEAT, note, BEAT*0.95, bossArr?0.9:0.8);
    bassNote(bt+1*BEAT, note, BEAT*0.48, 0.6);
    bassNote(bt+2*BEAT, note, BEAT*0.48, 0.6);
    bassNote(bt+3*BEAT, note, BEAT*0.48, 0.6);
  }
}
function scheduleStrings(t0){
  for(let bar=0; bar<LOOP_BARS; bar++){
    const tri=STR_CHORDS[bar%4], bt=t0+bar*BAR;
    for(let s=0;s<8;s++){ const n=tri[s%3]+12; staccatoStrings(bt+s*BEAT/2, n, BEAT/2*0.9, bossArr?0.55:0.45); }
  }
}
function scheduleBrass(t0){
  for(let bar=0; bar<LOOP_BARS; bar++){
    const bt=t0+bar*BAR;
    brassHit(bt+0.00,64, bossArr?0.9:0.8); brassHit(bt+0.12,67, bossArr?0.8:0.7); brassHit(bt+0.24,71, bossArr?0.8:0.7);
  }
}
function scheduleLead(t0){
  const loop=8;
  for(let bar=0; bar<LOOP_BARS; bar++){
    const bt=t0+bar*BAR;
    LEAD_PHRASE.forEach(e=>{
      const when=bt+e.o*SPB;
      if(Math.floor(e.o/4)===0 && (bar%loop)<4) lead(when,e.n,e.d,0.8);
      else if(Math.floor(e.o/4)===1 && (bar%loop)>=4) lead(when,e.n,e.d,0.8);
    });
  }
}
function scheduleAll(t0){ scheduleDrums(t0); scheduleBass(t0); scheduleStrings(t0); scheduleBrass(t0); scheduleLead(t0); }

async function startBgm(){
  await ensureAudio();
  if(runningBgm) return;
  runningBgm=true;
  startTimeBgm = ctxAudio.currentTime + 0.05;
  scheduleAll(startTimeBgm);
  function tick(){
    if(!runningBgm) return;
    const now=ctxAudio.currentTime;
    if(now > startTimeBgm + LOOP_END*0.85){
      startTimeBgm += LOOP_END; scheduleAll(startTimeBgm);
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}
function bgmFadeOut(sec){ if(master){ master.gain.cancelScheduledValues(ctxAudio.currentTime); master.gain.linearRampToValueAtTime(0, ctxAudio.currentTime+sec); } }
function bgmSetBossArrangement(on){
  bossArr=on;
  // リバーブSend微増
  try{ revBus.delayTime.value=0.19; }catch(_){}
}
/* --- SFX: 合成（短音） --- */
function sfxHit(){ // 斬撃ヒット
  const o=ctxAudio.createOscillator(); o.type='square'; o.frequency.value=480;
  const g=ctxAudio.createGain(); o.connect(g).connect(master);
  const r=env(g, ctxAudio.currentTime, 0.001,0.05,0.0,0.08,0.7);
  o.start(); r(ctxAudio.currentTime+0.08); o.stop(ctxAudio.currentTime+0.12);
}
function sfxBreak(){ // 部位破壊
  const o=ctxAudio.createOscillator(); o.type='sawtooth'; o.frequency.setValueAtTime(300,ctxAudio.currentTime);
  o.frequency.exponentialRampToValueAtTime(120, ctxAudio.currentTime+0.2);
  const g=ctxAudio.createGain(); o.connect(g).connect(master);
  const r=env(g, ctxAudio.currentTime, 0.001,0.08,0.0,0.2,0.8);
  o.start(); r(ctxAudio.currentTime+0.22); o.stop(ctxAudio.currentTime+0.3);
}
function sfxHurt(){
  const nbuf=ctxAudio.createBuffer(1, ctxAudio.sampleRate*0.12, ctxAudio.sampleRate);
  const ch=nbuf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*Math.exp(-i/ch.length*7);
  const ns=ctxAudio.createBufferSource(); ns.buffer=nbuf;
  const g=ctxAudio.createGain(); ns.connect(g).connect(master); g.gain.value=0.7;
  ns.start(); ns.stop(ctxAudio.currentTime+0.12);
}
function sfxPickup(type='I'){
  const o=ctxAudio.createOscillator(); o.type='triangle';
  const g=ctxAudio.createGain(); o.connect(g).connect(master);
  const base = (type==='I')? 880 : (type==='R')? 660 : 520;
  o.frequency.setValueAtTime(base, ctxAudio.currentTime);
  o.frequency.linearRampToValueAtTime(base*1.5, ctxAudio.currentTime+0.15);
  const r=env(g, ctxAudio.currentTime, 0.002,0.12,0,0.12,0.6);
  o.start(); r(ctxAudio.currentTime+0.2); o.stop(ctxAudio.currentTime+0.24);
}
function sfxShoot(){
  const o=ctxAudio.createOscillator(); o.type='square'; o.frequency.value=1200;
  const g=ctxAudio.createGain(); o.connect(g).connect(master); g.gain.value=0.25;
  const r=env(g, ctxAudio.currentTime, 0.001,0.03,0,0.04,0.5);
  o.start(); r(ctxAudio.currentTime+0.05); o.stop(ctxAudio.currentTime+0.08);
}
function sfxLaser(){
  const o=ctxAudio.createOscillator(); o.type='sawtooth'; o.frequency.value=400;
  const g=ctxAudio.createGain(); o.connect(g).connect(master);
  const r=env(g, ctxAudio.currentTime, 0.01,0.2,0.2,0.3,0.5);
  o.start(); r(ctxAudio.currentTime+0.6); o.stop(ctxAudio.currentTime+0.9);
}
function sfxFanfare(){
  // 勝利：Em中心の短いファンファーレ
  const notes=[64,67,71, 76,71,74, 71,69,71, 76];
  notes.forEach((n,i)=>{
    const t0=ctxAudio.currentTime + i*0.12;
    const o=ctxAudio.createOscillator(); o.type=(i%3===0)?'square':'triangle'; o.frequency.value=mtof(n);
    const g=ctxAudio.createGain(); o.connect(g).connect(master);
    const r=env(g,t0,0.005,0.08,0.0,0.12,0.6);
    o.start(t0); r(t0+0.2); o.stop(t0+0.25);
  });
}

/* ============ Boot (Audio unlock + Start) ============ */
function startAll(){
  overlay.style.display='none';
  startBgm().catch(console.warn);
  startGame();
}
// iOS解錠
['pointerdown','touchend','keydown'].forEach(ev=>{
  overlay.addEventListener(ev, (e)=>{ e.preventDefault(); startAll(); }, {once:true});
});

</script>
</body>
</html>

