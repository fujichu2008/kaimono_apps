<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="theme-color" content="#0a0f18" />
<title>Endless Blade: Clockwork Run (iPhone版・Hero Silhouette)</title>
<style>
  :root{
    --bg:#0a0f18; --bg2:#0e1421;
    --hud:#e6ecff; --muted:#93a4c6; --accent:#6ea8fe; --danger:#ff5a7a; --ok:#2ae59b;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--hud);
    font-family:system-ui,-apple-system,"Hiragino Sans","Noto Sans JP",sans-serif;overscroll-behavior:none}
  body{touch-action:none; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none}
  .wrap{height:100%;display:grid;place-items:center}
  canvas{image-rendering: pixelated; image-rendering: crisp-edges; touch-action:none; background:transparent; display:block}
  #hud{
    position:fixed; inset:auto 0 0 0; display:flex; justify-content:space-between; gap:8px;
    padding:8px 10px; font-weight:700; font-variant-numeric: tabular-nums;
    background:linear-gradient(180deg,transparent,rgba(0,0,0,.35));
    pointer-events:none;
  }
  #hud .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.1);padding:6px 10px;border-radius:12px}
  #hpBar{width:120px;height:10px;border:1px solid rgba(255,255,255,.25);border-radius:12px;overflow:hidden}
  #hpBar > i{display:block;height:100%;background:linear-gradient(90deg,var(--ok),#7cffc8);width:100%}
  #startOverlay{
    position:fixed; inset:0; display:grid; place-items:center; background:radial-gradient(1200px 600px at 50% 40%, rgba(255,255,255,.06), rgba(0,0,0,.65));
    text-align:center; padding:20px;
  }
  #startOverlay .card{
    width:min(720px,92%); background:rgba(10,15,24,.85); border:1px solid #1e2a44; border-radius:16px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.4)
  }
  h1{margin:.1em 0 .4em; font-size:20px}
  .tap{margin-top:10px; font-weight:800; color:var(--accent); letter-spacing:.04em}
  .hint{color:var(--muted); font-size:13px; line-height:1.6}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a3a66; background:#111a2a; color:#cfe1ff; font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="320" height="180" aria-label="Endless Blade Game"></canvas>
</div>

<!-- HUD -->
<div id="hud">
  <div class="pill">SCORE <span id="score">000000</span></div>
  <div class="pill">COMBO <span id="combo">0</span></div>
  <div class="pill" style="display:flex;align-items:center;gap:8px">HP
    <span id="hpNum">100</span>
    <span id="hpBar"><i id="hpFill"></i></span>
  </div>
</div>

<!-- Start Overlay（オーディオ解錠兼スタート） -->
<div id="startOverlay" role="button" aria-label="Tap to Start">
  <div class="card">
    <h1>⚔️ ENDLESS BLADE — CLOCKWORK RUN</h1>
    <div class="hint">
      <span class="badge">タップ</span> 斬撃　
      <span class="badge">上スワイプ</span> 対空斬　
      <span class="badge">下スワイプ</span> スライディング　
      <span class="badge">右スワイプ</span> ダッシュ　
      <span class="badge">左スワイプ</span> 回り込み
      <br>画面をタップで開始（iPhoneのオーディオ解錠が必要）
    </div>
    <div class="tap">▶ TAP TO START</div>
  </div>
</div>

<script>
/* ================================
   Canvas 基本セットアップ（iPhone）
==================================*/
const W=320, H=180; // 仮想解像度（Retina拡大）
const cvs=document.getElementById('game');
const ctx=cvs.getContext('2d');
let DPR=1;
function fit(){
  DPR = Math.max(1, Math.min(3, Math.floor(window.devicePixelRatio || 1)));
  cvs.style.width = (W*DPR)+'px';
  cvs.style.height= (H*DPR)+'px';
}
window.addEventListener('resize', fit, {passive:true});
fit();

/* ============ Util ============ */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function rnd(a,b){ return Math.random()*(b-a)+a; }
function chance(p){ return Math.random()<p; }

/* ============ Game State ============ */
let running=false, paused=false, t0=0, t=0, dt=0, last=0, scrollX=0;
let score=0, combo=0, hp=100;
const scoreEl=document.getElementById('score');
const comboEl=document.getElementById('combo');
const hpNum=document.getElementById('hpNum');
const hpFill=document.getElementById('hpFill');

function addScore(n){ score+=n; scoreEl.textContent=String(score).padStart(6,'0'); }
function addCombo(n=1){ combo+=n; comboEl.textContent=combo; }
function resetCombo(){ combo=0; comboEl.textContent=combo; }
function hitDamage(n){
  if(invul>0) return;
  hp = clamp(hp-n,0,100); hpNum.textContent=hp; hpFill.style.width=hp+'%';
  invul = 0.3;
  if(hp<=0){ gameOver(); }
}

/* ============ Input（Tap/Swipe） ============ */
let down=false, startX=0, startY=0, endX=0, endY=0, gesture='';
const SWIPE_TH=18; // px in logical space
cvs.addEventListener('pointerdown',e=>{
  if(!running) return;
  down=true;
  const r=cvs.getBoundingClientRect();
  startX=(e.clientX-r.left)/(r.width)*W;
  startY=(e.clientY-r.top)/(r.height)*H;
  endX=startX; endY=startY;
});
cvs.addEventListener('pointermove',e=>{
  if(!running||!down) return;
  const r=cvs.getBoundingClientRect();
  endX=(e.clientX-r.left)/(r.width)*W;
  endY=(e.clientY-r.top)/(r.height)*H;
});
cvs.addEventListener('pointerup',()=>{
  if(!running) return;
  down=false;
  const dx=endX-startX, dy=endY-startY;
  gesture='';
  if(Math.abs(dx)<SWIPE_TH && Math.abs(dy)<SWIPE_TH){
    gesture='tap';
  }else if(Math.abs(dx)>Math.abs(dy)){
    gesture = dx>0 ? 'right' : 'left';
  }else{
    gesture = dy<0 ? 'up' : 'down';
  }
  handleInput(gesture);
});

/* ============ Player ============ */
const player = {
  x: 40, y: H-28, w:12, h:18, vy:0, onGround:true,
  runSpd: 40, face:1, slide:0, dash:0, atk:0, parry:0, animT:0
};
let invul=0;

function handleInput(g){
  if(g==='tap'){ doAttack(); }
  else if(g==='up'){ if(player.onGround){ player.vy=-140; player.onGround=false; doAirCut(); } }
  else if(g==='down'){ if(player.onGround){ player.slide=0.25; } }
  else if(g==='right'){ player.dash=0.20; }
  else if(g==='left'){ doRollBehind(); }
}
function doAttack(){ player.atk=0.14; addCombo(1); spawnSlash('front'); }
function doAirCut(){ player.atk=0.12; addCombo(1); spawnSlash('air'); }
function doRollBehind(){ player.atk=0.10; addCombo(1); spawnSlash('behind'); }

/* ============ Slashes（判定兼エフェクト） ============ */
const slashes=[];
function spawnSlash(kind){
  const s={t:0, life:0.12, kind, x:player.x, y:player.y, w:16, h:12};
  if(kind==='front'){ s.x+=12; s.y-=6; s.w=18; s.h=14; }
  if(kind==='air'){   s.x+=10; s.y-=16; s.w=16; s.h=16; }
  if(kind==='behind'){s.x-=8; s.y-=4;  s.w=14; s.h=12; }
  slashes.push(s);
}

/* ============ Enemies ============ */
const enemies=[];
function spawnWalker(){
  enemies.push({type:'walker', x: W+20, y:H-26, w:14, h:16, vx:-rnd(26,34), hp:1, t:0});
}
function spawnDrone(){
  enemies.push({type:'drone', x: W+20, y:rnd(40,110), w:12, h:10, vx:-rnd(32,44), hp:1, t:0, shoot:rnd(0.6,1.5)});
}
let spawnTimer=0;
function spawnLogic(dt){
  spawnTimer-=dt;
  if(spawnTimer<=0){
    if(chance(0.6)) spawnWalker(); else spawnDrone();
    spawnTimer = rnd(0.8, 1.4) * Math.max(0.5, 1 - t/90);
  }
}

/* ============ Shots（ドローン） ============ */
const shots=[];
function spawnShot(x,y){
  shots.push({x,y,w:8,h:2,vx:-90,t:0});
}

/* ============ Background ============ */
const gears = Array.from({length:12}, ()=>({x:rnd(0,W), y:rnd(20,H-20), r:rnd(3,10), s:rnd(0.1,0.5)}));
const pipes = Array.from({length:5},  ()=>({x:rnd(0,W), y:rnd(40,H-10), w:rnd(60,120)}));

/* ============ Collisions ============ */
function aabb(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

/* ============ Main Loop ============ */
function update(ts){
  if(!running || paused) return;
  if(!last) last=ts;
  dt = Math.min(0.033, (ts-last)/1000);
  last=ts; t += dt; scrollX += player.runSpd*dt;

  // Player physics
  if(!player.onGround){
    player.vy += 400*dt;
    player.y  += player.vy*dt;
    if(player.y >= H-28){ player.y=H-28; player.vy=0; player.onGround=true; }
  }
  if(player.slide>0){ player.slide-=dt; }
  if(player.dash>0){ player.dash-=dt; }
  if(player.atk>0){  player.atk-=dt; }
  if(invul>0){ invul-=dt; }

  // Spawns
  spawnLogic(dt);

  // Enemies
  for(const e of enemies){
    e.t+=dt; e.x += e.vx*dt;
    if(e.type==='drone' && e.t>e.shoot){
      e.shoot+=rnd(1.2,1.8);
      spawnShot(e.x-6, e.y+2);
    }
  }
  // Shots
  for(const s of shots){ s.t+=dt; s.x += s.vx*dt; }

  // Slash hits
  for(const sl of slashes){
    sl.t+=dt;
    for(const e of enemies){
      if(e.hp>0 && aabb(sl,e)){
        e.hp=0; addScore(100);
      }
    }
  }

  // Damage to player
  const hurtBox = {
    x: player.x-6,
    y: player.y-16 + (player.slide>0?6:0),
    w: 12,
    h: (player.slide>0?10:16)
  };
  for(const e of enemies){
    if(e.hp>0 && aabb(hurtBox,e)){ hitDamage(10); e.hp=0; resetCombo(); }
  }
  for(const s of shots){
    if(aabb(hurtBox,s)){ hitDamage(8); s.x=-999; resetCombo(); }
  }

  // Cleanup
  prune(enemies, e=> e.x<-30 || e.hp<=0);
  prune(slashes, s=> s.t>=s.life);
  prune(shots, s=> s.x<-20);

  // Draw
  draw();

  requestAnimationFrame(update);
}
function prune(arr, pred){
  for(let i=arr.length-1;i>=0;i--) if(pred(arr[i])) arr.splice(i,1);
}

/* ============ Drawing ============ */
function draw(){
  ctx.clearRect(0,0,W,H);

  // Far gradient
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#0a0f18'); g.addColorStop(1,'#10182c'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // Pipes
  ctx.strokeStyle='rgba(90,120,160,.35)'; ctx.lineWidth=2;
  for(const p of pipes){
    const x=((p.x - (scrollX*0.2)% (W+p.w)) + (W+p.w))%(W+p.w) - p.w;
    ctx.beginPath(); ctx.moveTo(x, p.y); ctx.lineTo(x+p.w, p.y); ctx.stroke();
  }

  // Gears
  for(const ge of gears){
    const x=((ge.x - (scrollX*ge.s)% (W+30)) + (W+30))%(W+30) - 15;
    ctx.beginPath(); ctx.arc(x, ge.y, ge.r, 0, Math.PI*2);
    ctx.fillStyle='rgba(180,200,255,.07)'; ctx.fill();
    ctx.strokeStyle='rgba(200,220,255,.10)'; ctx.stroke();
  }

  // Ground
  ctx.fillStyle='#1a243a'; ctx.fillRect(0,H-18,W,18);
  for(let x=0;x<W;x+=8){ ctx.fillStyle=(x/8%2)?'#162036':'#111a2a'; ctx.fillRect(x,H-18,8,18); }

  // Player (hero)
  drawHero(ctx);

  // Enemies
  for(const e of enemies){
    if(e.hp<=0) continue;
    if(e.type==='walker'){
      ctx.fillStyle='#c9b38a';
      ctx.fillRect(Math.round(e.x)-7, Math.round(e.y)-12, 14, 12);
      ctx.fillStyle='#946b2d'; ctx.fillRect(Math.round(e.x)-7, Math.round(e.y), 14, 2);
      ctx.fillStyle='#ff6b6b'; ctx.fillRect(Math.round(e.x)+2, Math.round(e.y)-8, 3,2);
    }else{
      ctx.fillStyle='#9aa7b7';
      ctx.fillRect(Math.round(e.x)-6, Math.round(e.y)-6, 12, 10);
      ctx.fillStyle='#6ec1ff'; ctx.fillRect(Math.round(e.x)-2, Math.round(e.y)-3, 4,3);
    }
  }

  // Shots
  ctx.fillStyle='#ffed6b';
  for(const s of shots){ ctx.fillRect(Math.round(s.x), Math.round(s.y), s.w, s.h); }

  // Slashes
  for(const sl of slashes){
    const alpha = 1 - sl.t/sl.life;
    ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(2)})`;
    ctx.fillRect(Math.round(sl.x), Math.round(sl.y), sl.w, sl.h);
  }
}

/* ----- Hero Rendering (Silhouette + Rimlight + Cape + Blade Trail) ----- */
function drawHero(ctx) {
  player.animT += 0.12;

  const px = Math.round(player.x), py = Math.round(player.y);
  const running = player.onGround && player.slide<=0 && player.atk<=0;
  const swing = running ? Math.sin(player.animT)*3 : 0;
  const bob   = running ? Math.sin(player.animT*2)*1.2 : 0;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(px, H-6, 10, 3, 0, 0, Math.PI*2); ctx.fill();

  // Cape
  const capeLen = 16;
  const capeAng = (player.dash>0 ? -0.7 : player.onGround ? -0.35 : -0.15) + Math.sin(player.animT*1.2)*0.1;
  const capeRootX = px-4, capeRootY = py-14 + bob;
  const capeTipX  = capeRootX + Math.cos(capeAng)*capeLen;
  const capeTipY  = capeRootY + Math.sin(capeAng)*capeLen;
  const grdCape = ctx.createLinearGradient(capeRootX, capeRootY, capeTipX, capeTipY);
  grdCape.addColorStop(0,'rgba(40,70,120,0.85)');
  grdCape.addColorStop(1,'rgba(10,20,40,0.0)');
  ctx.fillStyle = grdCape;
  ctx.beginPath();
  ctx.moveTo(capeRootX, capeRootY);
  ctx.quadraticCurveTo(capeRootX-8, capeRootY+6, capeTipX, capeTipY);
  ctx.lineTo(capeTipX, capeTipY+3);
  ctx.quadraticCurveTo(capeRootX-6, capeRootY+8, capeRootX, capeRootY+4);
  ctx.closePath(); ctx.fill();

  // Body (capsule)
  ctx.fillStyle = (invul>0) ? 'rgba(255,90,122,0.9)' : '#9fc6ff';
  ctx.beginPath(); roundCapsule(ctx, px-6, py-16+bob, 12, 16, 6); ctx.fill();

  // Chest armor
  ctx.fillStyle = (invul>0) ? 'rgba(200,50,80,0.9)' : '#7aa8e0';
  ctx.beginPath(); roundCapsule(ctx, px-6, py-14+bob, 12, 7, 5); ctx.fill();

  // Rim light
  ctx.strokeStyle = 'rgba(255,255,255,0.65)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(px+6, py-14+bob); ctx.lineTo(px+6, py-2+bob); ctx.stroke();

  // Head + visor
  ctx.fillStyle = '#cfe7ff';
  ctx.beginPath(); roundCapsule(ctx, px-5, py-22+bob, 10, 8, 4); ctx.fill();
  ctx.fillStyle = 'rgba(110,168,254,0.8)'; ctx.fillRect(px-4, py-19+bob, 8, 3);

  // Limbs
  ctx.fillStyle = '#9fc6ff';
  ctx.save(); ctx.translate(px-3, py-4+bob); ctx.rotate((swing)*Math.PI/180);
  roundCapsule(ctx, -2, 0, 4, 8, 2); ctx.fill(); ctx.restore();

  ctx.save(); ctx.translate(px+3, py-4+bob); ctx.rotate((-swing)*Math.PI/180);
  roundCapsule(ctx, -2, 0, 4, 8, 2); ctx.fill(); ctx.restore();

  ctx.save(); ctx.translate(px-5, py-12+bob); ctx.rotate((-swing-6)*Math.PI/180);
  roundCapsule(ctx, -2, 0, 4, 8, 2); ctx.fill(); ctx.restore();

  ctx.save(); ctx.translate(px+5, py-12+bob); ctx.rotate((swing+10)*Math.PI/180);
  roundCapsule(ctx, -2, 0, 4, 8, 2); ctx.fill(); ctx.restore();

  // Blade + trail
  const atkPhase = Math.max(0, player.atk/0.14); // 0→1
  const bladeLen = 14;
  const baseAng = player.atk>0 ? -0.7 + (1-atkPhase)*1.2 : -0.4;
  const bx = px+8, by = py-12+bob;
  const tipX = bx + Math.cos(baseAng)*bladeLen;
  const tipY = by + Math.sin(baseAng)*bladeLen;

  ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(tipX, tipY); ctx.stroke();

  ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(tipX, tipY); ctx.stroke();

  // Slide dust
  if(player.slide>0 && player.onGround){
    const dust = Math.min(1, player.slide/0.25);
    ctx.fillStyle = `rgba(200,220,255,${0.25*dust})`;
    ctx.fillRect(px-10, py-2, 8, 2);
  }
}
function roundCapsule(ctx, x,y,w,h,r){
  const rr=Math.min(r, w/2, h/2);
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}

/* ============ Game Start/Over ============ */
function startGame(){
  running=true; paused=false; t0=performance.now(); t=0; last=0;
  score=0; combo=0; hp=100; invul=0;
  enemies.length=0; slashes.length=0; shots.length=0;
  scoreEl.textContent='000000'; comboEl.textContent='0'; hpNum.textContent='100'; hpFill.style.width='100%';
  requestAnimationFrame(update);
}
function gameOver(){
  running=false;
  try{ if(master) master.gain.linearRampToValueAtTime(0, ctxAudio.currentTime+0.6); }catch(_){}
  const ov=document.getElementById('startOverlay');
  ov.querySelector('h1').textContent='GAME OVER';
  ov.querySelector('.tap').textContent='▶ TAP TO RESTART';
  ov.style.display='grid';
}

/* ============ Pause on visibility ============ */
document.addEventListener('visibilitychange', ()=>{ paused=document.hidden; });

/* ===========================
   BGM（合成・UIなし）
=========================== */
let ctxAudio, master, revBus, limiter;
let runningBgm=false, loopStart=0.00, loopEnd=25.92, startTimeBgm=0;

function mtof(n){ return 440 * Math.pow(2, (n - 69)/12); }

async function ensureAudio(){
  if(!ctxAudio){
    ctxAudio = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
    master = ctxAudio.createGain(); master.gain.value=0.9;

    const d = ctxAudio.createDelay(3.0); d.delayTime.value = 0.19;
    const fb= ctxAudio.createGain(); fb.gain.value = 0.28; d.connect(fb).connect(d);
    revBus = d;

    limiter = ctxAudio.createDynamicsCompressor();
    limiter.threshold.value=-10; limiter.ratio.value=12; limiter.attack.value=0.002; limiter.release.value=0.12;
    master.connect(limiter); revBus.connect(limiter); limiter.connect(ctxAudio.destination);
  }
  if(ctxAudio.state==='suspended') await ctxAudio.resume();
  return ctxAudio;
}
function env(node, t0, a=0.01, d=0.1, s=0.6, r=0.08, peak=1.0){
  const g = node.gain; g.cancelScheduledValues(t0);
  g.setValueAtTime(0.0001, t0);
  g.linearRampToValueAtTime(peak, t0 + a);
  g.linearRampToValueAtTime(s*peak, t0 + a + d);
  return (releaseAt)=>{
    g.cancelScheduledValues(releaseAt);
    g.setValueAtTime(g.value, releaseAt);
    g.linearRampToValueAtTime(0.0001, releaseAt + r);
  };
}

/* --- Timbres & Patterns --- */
function kick(t, vel=0.9){
  const o=ctxAudio.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(95,t); o.frequency.exponentialRampToValueAtTime(42,t+0.08);
  const g=ctxAudio.createGain(); o.connect(g).connect(master);
  const release=env(g,t,0.001,0.05,0,0.12,vel); o.start(t); release(t+0.12); o.stop(t+0.2);
}
function snare(t, vel=0.8){
  const nbuf=ctxAudio.createBuffer(1, ctxAudio.sampleRate*0.12, ctxAudio.sampleRate);
  const ch=nbuf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*Math.exp(-i/ch.length*7);
  const ns=ctxAudio.createBufferSource(); ns.buffer=nbuf; const bp=ctxAudio.createBiquadFilter(); bp.type='highpass'; bp.frequency.value=1800;
  const g=ctxAudio.createGain(); ns.connect(bp).connect(g).connect(master);
  const release=env(g,t,0.001,0.04,0,0.05,vel); ns.start(t); release(t+0.12); ns.stop(t+0.16);
}
function hat(t, vel=0.6){
  const nbuf=ctxAudio.createBuffer(1, ctxAudio.sampleRate*0.06, ctxAudio.sampleRate);
  const ch=nbuf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*Math.exp(-i/ch.length*10);
  const ns=ctxAudio.createBufferSource(); ns.buffer=nbuf; const hp=ctxAudio.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
  const g=ctxAudio.createGain(); ns.connect(hp).connect(g).connect(master);
  const release=env(g,t,0.001,0.01,0,0.02,vel); ns.start(t); release(t+0.05); ns.stop(t+0.08);
}
function bassNote(t, midi, dur, vel=0.7){
  const o=ctxAudio.createOscillator(); o.type='square'; o.frequency.value=mtof(midi);
  const g=ctxAudio.createGain(); o.connect(g).connect(master);
  const release=env(g,t,0.003,0.05,0.7,0.06,vel); o.start(t); const stopAt=t+dur; release(stopAt); o.stop(stopAt+0.1);
}
function staccatoStrings(t, midi, dur, vel=0.5){
  const o=ctxAudio.createOscillator(); o.type='sawtooth'; o.frequency.value=mtof(midi);
  const f=ctxAudio.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1800;
  const g=ctxAudio.createGain(); o.connect(g).connect(f).connect(master);
  const release=env(g,t,0.002,0.05,0.0,0.04,vel); o.start(t); const stopAt=t+dur; release(stopAt); o.stop(stopAt+0.08);
}
function brassHit(t, midi, vel=0.7){
  const o=ctxAudio.createOscillator(); o.type='sawtooth'; o.frequency.value=mtof(midi);
  const f=ctxAudio.createBiquadFilter(); f.type='lowpass'; f.frequency.value=2400;
  const g=ctxAudio.createGain(); o.connect(g).connect(f).connect(master);
  const release=env(g,t,0.004,0.09,0.0,0.06,vel); o.start(t); const stopAt=t+0.18; release(stopAt); o.stop(stopAt+0.12);
}
function lead(t, midi, dur, vel=0.75){
  const o=ctxAudio.createOscillator(); o.type='triangle'; o.frequency.value=mtof(midi);
  const g=ctxAudio.createGain(); const d=ctxAudio.createDelay(1.0); d.delayTime.value=0.12; const dg=ctxAudio.createGain(); dg.gain.value=0.25;
  o.connect(g).connect(master); g.connect(d).connect(dg).connect(revBus);
  const release=env(g,t,0.002,0.08,0.5,0.06,vel); o.start(t); const stopAt=t+dur; release(stopAt); o.stop(stopAt+0.1);
}
/* Patterns */
const BPM=148, SPB=60/BPM, BEAT=SPB, BAR=SPB*4, LOOP_BARS=16;
const BASS_SEQ=[40,40,38,40,36,38,40,47];
const STR_CHORDS=[[52,55,59],[50,54,57],[48,52,55],[50,54,57]];
const LEAD_PHRASE=[
  {o:0.00,n:71,d:BEAT*0.5},{o:0.50,n:69,d:BEAT*0.5},{o:1.00,n:71,d:BEAT*0.5},{o:1.50,n:74,d:BEAT*0.75},
  {o:2.50,n:72,d:BEAT*0.5},{o:3.00,n:71,d:BEAT*0.5},{o:3.50,n:69,d:BEAT*1.0},
  {o:4.00,n:71,d:BEAT*0.5},{o:4.50,n:74,d:BEAT*0.5},{o:5.00,n:76,d:BEAT*0.75},
  {o:6.00,n:74,d:BEAT*0.5},{o:6.50,n:72,d:BEAT*0.5},{o:7.00,n:71,d:BEAT*0.5},{o:7.50,n:69,d:BEAT*1.0},
];
function scheduleDrums(t0){
  for(let bar=0; bar<LOOP_BARS; bar++){
    const bt=t0+bar*BAR;
    for(let i=0;i<8;i++) hat(bt+i*BEAT/2,0.55);
    kick(bt+0*BEAT,0.95); kick(bt+2*BEAT,0.9);
    snare(bt+1*BEAT,0.85); snare(bt+3*BEAT,0.88);
    if(bar%8===7){ snare(bt+3.0*BEAT,0.95); snare(bt+3.5*BEAT,0.9); }
  }
}
function scheduleBass(t0){
  for(let bar=0; bar<LOOP_BARS; bar++){
    const note=BASS_SEQ[bar%8], bt=t0+bar*BAR;
    bassNote(bt+0*BEAT, note, BEAT*0.95, 0.8);
    bassNote(bt+1*BEAT, note, BEAT*0.48, 0.6);
    bassNote(bt+2*BEAT, note, BEAT*0.48, 0.6);
    bassNote(bt+3*BEAT, note, BEAT*0.48, 0.6);
  }
}
function scheduleStrings(t0){
  for(let bar=0; bar<LOOP_BARS; bar++){
    const tri=STR_CHORDS[bar%4], bt=t0+bar*BAR;
    for(let s=0;s<8;s++){ const n=tri[s%3]+12; staccatoStrings(bt+s*BEAT/2, n, BEAT/2*0.9, 0.45); }
  }
}
function scheduleBrass(t0){
  for(let bar=0; bar<LOOP_BARS; bar++){
    const bt=t0+bar*BAR;
    brassHit(bt+0.00,64,0.8); brassHit(bt+0.12,67,0.7); brassHit(bt+0.24,71,0.7);
  }
}
function scheduleLead(t0){
  const loop=8;
  for(let bar=0; bar<LOOP_BARS; bar++){
    const bt=t0+bar*BAR;
    LEAD_PHRASE.forEach(e=>{
      const when=bt+e.o*SPB;
      if(Math.floor(e.o/4)===0 && (bar%loop)<4) lead(when,e.n,e.d,0.8);
      else if(Math.floor(e.o/4)===1 && (bar%loop)>=4) lead(when,e.n,e.d,0.8);
    });
  }
}
function scheduleAll(t0){ scheduleDrums(t0); scheduleBass(t0); scheduleStrings(t0); scheduleBrass(t0); scheduleLead(t0); }

async function startBgm(){
  await ensureAudio();
  if(runningBgm) return;
  runningBgm=true;
  startTimeBgm = ctxAudio.currentTime + 0.05;
  scheduleAll(startTimeBgm);
  const loopDur = loopEnd - loopStart;
  function tick(){
    if(!runningBgm) return;
    const now=ctxAudio.currentTime;
    if(now > startTimeBgm + loopDur*0.85){
      startTimeBgm += loopDur; scheduleAll(startTimeBgm);
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}

/* ============ Boot (Audio unlock + Start) ============ */
const overlay=document.getElementById('startOverlay');
function startAll(){
  overlay.style.display='none';
  startBgm().catch(console.warn);
  startGame();
}
['pointerdown','touchend','keydown'].forEach(ev=>{
  overlay.addEventListener(ev, (e)=>{ e.preventDefault(); startAll(); }, {once:true});
});
</script>
</body>
</html>
