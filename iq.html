<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, viewport-fit=cover, user-scalable=no" />
<title>Web IQ Cube（簡易版・タップ操作）</title>
<style>
:root{
  --bg:#050711;
  --bg2:#050a18;
  --board-bg:#050a18;
  --cell:#0e1627;
  --cell-edge:#1c2940;
  --cell-mark:#304574;
  --cube-normal:#5bc0ff;
  --cube-adv:#49d37e;
  --cube-forbid:#ff4d6a;
  --player:#ffd166;
  --ink:#e7edf9;
  --muted:#9aa6c5;
  --accent:#4da3ff;
  --danger:#ff4d6a;
  --ok:#17c964;
}

*{box-sizing:border-box;margin:0;padding:0}
html,body{
  height:100%;
  background:radial-gradient(circle at top,#111b30 0,#050711 40%,#020308 100%);
  color:var(--ink);
  font-family:system-ui,-apple-system,"Hiragino Sans","Noto Sans JP",sans-serif;
}

body{
  display:flex;
  flex-direction:column;
}

/* ヘッダー */
header{
  padding:0.4rem 0.8rem 0.2rem;
  background:linear-gradient(to right,rgba(12,18,38,.95),rgba(6,12,28,.95));
  border-bottom:1px solid rgba(255,255,255,.04);
  box-shadow:0 6px 20px rgba(0,0,0,.5);
}
header h1{
  font-size:1.05rem;
  letter-spacing:0.05em;
  text-transform:uppercase;
  display:flex;
  align-items:center;
  gap:0.4rem;
}
header h1 span.logo-dot{
  display:inline-block;
  width:0.8rem;
  height:0.8rem;
  border-radius:999px;
  background:radial-gradient(circle at 30% 30%,#fff 0,#4da3ff 30%,#223c6b 70%,#050711 100%);
  box-shadow:0 0 8px rgba(77,163,255,.9);
}

header .sub{
  font-size:0.7rem;
  color:var(--muted);
  margin-top:0.1rem;
}

/* メインレイアウト */
main{
  flex:1;
  display:flex;
  flex-direction:column;
  padding:0.4rem 0.6rem 0.6rem;
  gap:0.4rem;
}

/* ステータスバー */
#status-bar{
  display:flex;
  flex-wrap:wrap;
  gap:0.25rem;
  font-size:0.7rem;
}
.status-chip{
  padding:0.12rem 0.4rem;
  border-radius:999px;
  background:rgba(11,19,40,.9);
  border:1px solid rgba(255,255,255,.08);
  display:flex;
  align-items:center;
  gap:0.25rem;
}
.status-label{
  color:var(--muted);
}
.status-value{
  font-variant-numeric:tabular-nums;
}

/* ボード周り */
#board-wrapper{
  flex:1;
  min-height:260px;
  max-height:460px;
  background:radial-gradient(circle at top,#1b2740 0,#050a18 45%,#020308 100%);
  border-radius:18px;
  padding:0.5rem 0.5rem 0.9rem;
  margin-top:0.1rem;
  box-shadow:
    0 14px 50px rgba(0,0,0,.8),
    0 0 0 1px rgba(255,255,255,.02);
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  position:relative;
  overflow:hidden;
}

/* 疑似3D台座 */
#platform{
  position:absolute;
  bottom:0.3rem;
  left:50%;
  transform:translateX(-50%);
  width:88%;
  height:14px;
  background:linear-gradient(to right,#13182a,#050712,#13182a);
  border-radius:999px;
  box-shadow:0 0 20px rgba(0,0,0,.9);
  opacity:0.85;
}

/* ボード本体（より真上からの俯瞰） */
#board{
  position:relative;
  width:100%;
  max-width:520px;
  aspect-ratio: 5 / 4;
  display:grid;
  grid-template-columns:repeat(7,1fr);
  grid-auto-rows:1fr;
  transform-origin:50% 100%;
  /* 3D感は維持しつつ、より真上から見下ろす角度に */
  transform:perspective(1100px) rotateX(72deg);
  background:radial-gradient(circle at top,#11182a,#050914);
  border-radius:12px;
  overflow:hidden;
  box-shadow:
    0 24px 50px rgba(0,0,0,.9),
    0 0 0 1px rgba(255,255,255,.04);
}

/* グリッドサイズはJSで上書き */
#board[data-cols]{
  grid-template-columns:repeat(var(--cols,7),1fr);
}
#board[data-rows]{
  /* 行数はautoだが、aspect-ratioで縦横比をキープ */
}

/* マス */
.cell{
  position:relative;
  border:1px solid rgba(9,15,32,0.9);
  background:
    linear-gradient(135deg,rgba(48,72,120,.55),rgba(8,12,28,.95));
  box-shadow:
    inset 0 2px 4px rgba(255,255,255,.02),
    inset 0 -3px 5px rgba(0,0,0,.7);
  cursor:pointer;
}

/* マスの床ディテール */
.cell::before{
  content:"";
  position:absolute;
  inset:12% 12% 8% 12%;
  border-radius:4px;
  background:radial-gradient(circle at 30% 20%,rgba(255,255,255,.16) 0,rgba(255,255,255,0) 55%),
             radial-gradient(circle at 80% 80%,rgba(0,0,0,.7) 0,rgba(0,0,0,0) 60%);
  opacity:0.75;
  pointer-events:none;
}

/* マーク */
.cell.marked::after{
  content:"";
  position:absolute;
  inset:20% 20% 15% 20%;
  border-radius:6px;
  border:2px solid rgba(86,141,255,.95);
  box-shadow:0 0 8px rgba(77,163,255,.9);
  pointer-events:none;
}

/* キューブ */
.cube{
  position:absolute;
  left:8%;
  right:8%;
  bottom:6%;
  top:6%;
  border-radius:6px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:0.7rem;
  font-weight:600;
  color:#f8fbff;
  text-shadow:0 0 4px rgba(0,0,0,.7);
  box-shadow:
    0 10px 10px rgba(0,0,0,.75),
    0 0 0 1px rgba(255,255,255,.18),
    inset 0 2px 3px rgba(255,255,255,.28),
    inset 0 -3px 6px rgba(0,0,0,.65);
}
.cube-normal{
  background:linear-gradient(135deg,#56b7ff,#2a89ff);
}
.cube-adv{
  background:linear-gradient(135deg,#3fdc7a,#1eaa5a);
}
.cube-forbid{
  background:linear-gradient(135deg,#ff5a6b,#c0182f);
}

/* プレイヤー（カーソル的な役割） */
.player{
  position:absolute;
  left:18%;
  right:18%;
  bottom:4%;
  top:26%;
  border-radius:999px;
  background:radial-gradient(circle at 30% 20%,#fff7d6 0,#ffd166 40%,#d29b27 70%,#815b12 100%);
  box-shadow:
    0 0 10px rgba(255,209,102,.95),
    0 10px 12px rgba(0,0,0,.85),
    0 0 0 1px rgba(255,255,255,.32);
}
.player::after{
  content:"";
  position:absolute;
  inset:18% 16% 40% 16%;
  border-radius:999px;
  background:radial-gradient(circle at 30% 20%,rgba(255,255,255,.85) 0,rgba(255,255,255,0) 60%);
}

/* プレイヤーの下の影 */
.player-shadow{
  position:absolute;
  inset:58% 16% 16% 16%;
  border-radius:999px;
  background:radial-gradient(circle at 50% 50%,rgba(0,0,0,.7) 0,rgba(0,0,0,0) 70%);
  pointer-events:none;
}

/* 操作ボタン（スタート等） */
#controls{
  margin-top:0.4rem;
  display:flex;
  justify-content:center;
}
#action-buttons{
  flex:1;
  max-width:420px;
  display:flex;
  flex-direction:column;
  gap:0.25rem;
}
.action-row{
  display:flex;
  gap:0.3rem;
}
.btn{
  flex:1;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.18);
  padding:0.4rem 0.5rem;
  font-size:0.78rem;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:0.28rem;
  background:linear-gradient(to bottom,#151d35,#050914);
  color:var(--ink);
  box-shadow:0 5px 15px rgba(0,0,0,.8);
}
.btn-primary{
  background:linear-gradient(to bottom,#2c7eff,#1651c8);
}
.btn-ghost{
  background:linear-gradient(to bottom,#141c30,#080d1b);
}
.btn span.key-hint{
  font-size:0.6rem;
  padding:0.05rem 0.35rem;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.25);
  color:var(--muted);
}

/* ヒント行 */
#hint-bar{
  margin-top:0.2rem;
  font-size:0.68rem;
  color:var(--muted);
}

/* 浮動FIREボタン（画面の外側に配置） */
#btn-fire{
  position:fixed;
  right:0.9rem;
  bottom:3.7rem; /* フッターの少し上 */
  z-index:30;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.2);
  padding:0.6rem 1rem;
  font-size:0.8rem;
  font-weight:600;
  letter-spacing:0.06em;
  text-transform:uppercase;
  background:radial-gradient(circle at 30% 20%,rgba(255,255,255,.2) 0,rgba(255,255,255,0) 55%),
             linear-gradient(to bottom,#ff5a6b,#c0182f);
  color:#fff5f7;
  box-shadow:
    0 10px 18px rgba(0,0,0,.85),
    0 0 12px rgba(255,90,107,.85);
}
#btn-fire:active{
  transform:translateY(1px);
  box-shadow:
    0 6px 12px rgba(0,0,0,.9),
    0 0 8px rgba(255,90,107,.75);
}

/* オーバーレイ（ステージ結果など） */
#overlay{
  position:fixed;
  inset:0;
  background:radial-gradient(circle at top,rgba(24,32,64,.96),rgba(4,6,18,.98));
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:50;
}
#overlay.hidden{display:none;}
.overlay-card{
  max-width:360px;
  margin:0 1rem;
  background:linear-gradient(to bottom,#10182b,#050712);
  border-radius:18px;
  border:1px solid rgba(255,255,255,.16);
  box-shadow:0 18px 40px rgba(0,0,0,.95);
  padding:1rem 1.1rem 0.8rem;
}
.overlay-title{
  font-size:1rem;
  margin-bottom:0.3rem;
}
.overlay-sub{
  font-size:0.8rem;
  color:var(--muted);
  margin-bottom:0.5rem;
}
.result-grid{
  font-size:0.8rem;
  margin-bottom:0.7rem;
}
.result-row{
  display:flex;
  justify-content:space-between;
  margin-bottom:0.15rem;
}
.result-label{
  color:var(--muted);
}
.result-value{
  font-variant-numeric:tabular-nums;
}
.overlay-buttons{
  margin-top:0.2rem;
  display:flex;
  gap:0.4rem;
}
.overlay-buttons .btn{
  font-size:0.78rem;
}

/* フッター（キー操作ヘルプ） */
footer{
  padding:0.25rem 0.7rem 0.4rem;
  font-size:0.68rem;
  color:var(--muted);
  border-top:1px solid rgba(255,255,255,.04);
  background:linear-gradient(to right,rgba(5,7,18,.95),rgba(4,8,20,.95));
}

/* 小さめ画面対応 */
@media (min-width:600px){
  main{
    max-width:700px;
    margin:0 auto;
  }
}
</style>
</head>
<body>
<header>
  <h1><span class="logo-dot"></span>Web IQ Cube <span style="font-size:0.72rem;color:var(--muted);">/ Tap Prototype</span></h1>
  <div class="sub">落ちてくるキューブを「タップで選択・ダブルタップでマーク・FIREで爆破」する空間パズル（簡易IQ風）</div>
</header>

<main>
  <div id="status-bar">
    <div class="status-chip">
      <span class="status-label">STAGE</span>
      <span class="status-value" id="status-stage">1 / 3</span>
    </div>
    <div class="status-chip">
      <span class="status-label">SCORE</span>
      <span class="status-value" id="status-score">0</span>
    </div>
    <div class="status-chip">
      <span class="status-label">IQ風スコア</span>
      <span class="status-value" id="status-iq">---</span>
    </div>
    <div class="status-chip">
      <span class="status-label">MISSED</span>
      <span class="status-value" id="status-missed">0 / 5</span>
    </div>
    <div class="status-chip">
      <span class="status-label">FORBID HIT</span>
      <span class="status-value" id="status-forbid">0 / 3</span>
    </div>
  </div>

  <div id="board-wrapper">
    <div id="board" data-cols="7" data-rows="8"></div>
    <div id="platform"></div>
  </div>

  <div id="controls">
    <div id="action-buttons">
      <div class="action-row">
        <button class="btn btn-primary" id="btn-start">
          ▶ START / PAUSE <span class="key-hint">Space</span>
        </button>
        <button class="btn btn-ghost" id="btn-restart">
          ↻ RESTART <span class="key-hint">R</span>
        </button>
      </div>
    </div>
  </div>

  <div id="hint-bar">
    盤面をタップでそのマスを選択／プレイヤー移動。同じマスを素早く2回タップでマークON/OFF。右下の FIRE ボタン（または Xキー）で起爆。Spaceで開始／一時停止。
  </div>
</main>

<footer>
  通常キューブ（青）はできるだけ全部消すのが目標。緑キューブは3×3範囲をまとめて爆破するアドバンテージ。赤（禁止キューブ）を爆破するとペナルティ。落としすぎ・禁止キューブ破壊しすぎ・押しつぶされるとゲームオーバー。
</footer>

<!-- 浮動 FIRE ボタン -->
<button id="btn-fire" aria-label="Fire cubes">FIRE</button>

<!-- 結果オーバーレイ -->
<div id="overlay" class="hidden" aria-modal="true" role="dialog">
  <div class="overlay-card">
    <div class="overlay-title" id="overlay-title">Stage Clear!</div>
    <div class="overlay-sub" id="overlay-sub">結果</div>
    <div class="result-grid">
      <div class="result-row">
        <span class="result-label">STAGE</span>
        <span class="result-value" id="overlay-stage">1 / 3</span>
      </div>
      <div class="result-row">
        <span class="result-label">SCORE</span>
        <span class="result-value" id="overlay-score">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">IQ風スコア</span>
        <span class="result-value" id="overlay-iq">120</span>
      </div>
      <div class="result-row">
        <span class="result-label">処理した通常キューブ</span>
        <span class="result-value" id="overlay-hit-normal">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">処理したアドバンテージ</span>
        <span class="result-value" id="overlay-hit-adv">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">落としたキューブ</span>
        <span class="result-value" id="overlay-missed">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">禁止キューブ破壊</span>
        <span class="result-value" id="overlay-forbid">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">パーフェクト</span>
        <span class="result-value" id="overlay-perfect">NO</span>
      </div>
    </div>
    <div class="overlay-buttons">
      <button class="btn btn-primary" id="overlay-next">▶ 次のステージ</button>
      <button class="btn btn-ghost" id="overlay-retry">↻ このステージをやり直す</button>
    </div>
  </div>
</div>

<script>
// =============================
//  簡易 IQ 風パズル ロジック
//  （タップ＋ダブルタップ操作版）
// =============================

// キューブ種別
const CUBE_NONE = 0;
const CUBE_NORMAL = 1;
const CUBE_ADV = 2;
const CUBE_FORBID = 3;

// 設定値
const MAX_MISSED = 5;
const MAX_FORBID_HIT = 3;

// ステージ定義（簡易版・速度を全体的に遅く）
const STAGES = [
  {
    name: "Tutorial",
    rows: 7,
    cols: 5,
    tickMs: 1500,
    waves: [
      [0,1,0,1,0],
      [0,1,0,1,0],
      [1,0,0,0,1],
      [1,0,2,0,1],
      [1,1,1,1,1]
    ]
  },
  {
    name: "Basic IQ",
    rows: 8,
    cols: 6,
    tickMs: 1300,
    waves: [
      [1,0,1,0,1,0],
      [0,1,0,1,0,1],
      [0,1,2,1,0,0],
      [1,0,0,0,3,1],
      [1,1,1,1,1,1],
      [0,2,0,2,0,2],
      [1,0,3,0,1,0]
    ]
  },
  {
    name: "Advanced",
    rows: 8,
    cols: 7,
    tickMs: 1100,
    waves: [
      [1,0,1,0,1,0,1],
      [0,1,0,2,0,1,0],
      [1,1,0,0,0,1,1],
      [0,3,0,1,0,3,0],
      [1,0,1,1,1,0,1],
      [0,2,0,2,0,2,0],
      [1,1,1,0,1,1,1],
      [0,1,0,3,0,1,0],
      [1,0,1,0,1,0,1]
    ]
  }
];

let currentStageIndex = 0;
let stage = null;
let rows = 0;
let cols = 0;

let player = {row:0,col:0};

// マーク状態[row][col] = true/false
let marks = [];

// 現在のキューブ配列
// {row,col,type}
let cubes = [];

// ゲーム進行
let tickTimer = null;
let isRunning = false;
let spawnIndex = 0;

// スコア等
let score = 0;
let iqScore = null;
let hitNormal = 0;
let hitAdv = 0;
let hitForbid = 0;
let missed = 0;
let destroyedTotal = 0;

// タップ＆ダブルタップ検出用
let lastTapTime = 0;
let lastTapCell = null;
let tapTimeoutId = null;

// DOM取得
const boardEl = document.getElementById("board");
const statusStageEl = document.getElementById("status-stage");
const statusScoreEl = document.getElementById("status-score");
const statusIqEl = document.getElementById("status-iq");
const statusMissedEl = document.getElementById("status-missed");
const statusForbidEl = document.getElementById("status-forbid");

const overlayEl = document.getElementById("overlay");
const overlayTitleEl = document.getElementById("overlay-title");
const overlaySubEl = document.getElementById("overlay-sub");
const overlayStageEl = document.getElementById("overlay-stage");
const overlayScoreEl = document.getElementById("overlay-score");
const overlayIqEl = document.getElementById("overlay-iq");
const overlayHitNormalEl = document.getElementById("overlay-hit-normal");
const overlayHitAdvEl = document.getElementById("overlay-hit-adv");
const overlayMissedEl = document.getElementById("overlay-missed");
const overlayForbidEl = document.getElementById("overlay-forbid");
const overlayPerfectEl = document.getElementById("overlay-perfect");
const overlayNextBtn = document.getElementById("overlay-next");
const overlayRetryBtn = document.getElementById("overlay-retry");

const btnFire = document.getElementById("btn-fire");
const btnStart = document.getElementById("btn-start");
const btnRestart = document.getElementById("btn-restart");

// ======================
//  ステージ初期化
// ======================
function initStage(index){
  currentStageIndex = index;
  stage = STAGES[index];
  rows = stage.rows;
  cols = stage.cols;

  // ボードサイズ反映
  boardEl.style.setProperty("--cols", cols);
  boardEl.dataset.cols = String(cols);
  boardEl.dataset.rows = String(rows);

  // プレイヤー初期位置（手前中央）
  player.row = 0;
  player.col = Math.floor(cols/2);

  // マーククリア
  marks = Array.from({length:rows}, ()=>Array(cols).fill(false));

  // キューブクリア
  cubes = [];
  spawnIndex = 0;

  // スコアリセット
  score = 0;
  iqScore = null;
  hitNormal = 0;
  hitAdv = 0;
  hitForbid = 0;
  missed = 0;
  destroyedTotal = 0;

  stopTick();

  isRunning = false;
  updateStatus();
  renderBoard();
}

// ======================
//  ステータス更新
// ======================
function updateStatus(){
  statusStageEl.textContent = `${currentStageIndex+1} / ${STAGES.length}`;
  statusScoreEl.textContent = score.toString();
  statusIqEl.textContent = iqScore == null ? "---" : iqScore.toString();
  statusMissedEl.textContent = `${missed} / ${MAX_MISSED}`;
  statusForbidEl.textContent = `${hitForbid} / ${MAX_FORBID_HIT}`;
}

// ======================
//  プレイヤー移動系
// ======================
function movePlayerTo(r,c){
  if(!stage) return;
  if(r < 0 || r >= rows || c < 0 || c >= cols) return;
  player.row = r;
  player.col = c;
  renderBoard();
}

function movePlayer(dr,dc){
  // キーボード用（相対移動）
  const nr = player.row + dr;
  const nc = player.col + dc;
  movePlayerTo(nr,nc);
}

// ======================
//  マーク制御
// ======================
function toggleMarkAt(r,c){
  if(!stage) return;
  if(r < 0 || r >= rows || c < 0 || c >= cols) return;
  marks[r][c] = !marks[r][c];
  renderBoard();
}
function toggleMark(){
  // キーボード用（プレイヤー位置）
  toggleMarkAt(player.row, player.col);
}

// ======================
//  タップ & ダブルタップ
// ======================
function handleCellTap(r,c){
  const now = performance.now();

  if(
    lastTapCell &&
    lastTapCell.r === r &&
    lastTapCell.c === c &&
    (now - lastTapTime) < 280
  ){
    // ダブルタップ確定
    clearTimeout(tapTimeoutId);
    tapTimeoutId = null;
    lastTapCell = null;
    lastTapTime = 0;

    // そのマスへプレイヤーを移動させてからマークON/OFF
    movePlayerTo(r,c);
    toggleMarkAt(r,c);
  }else{
    // シングルタップ候補
    lastTapCell = {r,c};
    lastTapTime = now;
    clearTimeout(tapTimeoutId);
    tapTimeoutId = setTimeout(()=>{
      // 一定時間内に2回目が来なければシングルタップ
      movePlayerTo(r,c);
      lastTapCell = null;
      tapTimeoutId = null;
    },260);
  }
}

// ======================
//  ボード描画
// ======================
function renderBoard(){
  // 下から上へ（row 0 が手前）
  boardEl.innerHTML = "";
  for(let r = rows-1; r >= 0; r--){
    for(let c = 0; c < cols; c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.r = String(r);
      cell.dataset.c = String(c);
      if(marks[r][c]) cell.classList.add("marked");

      // 該当キューブを探す
      const cube = cubes.find(k => k.row === r && k.col === c);
      if(cube){
        const cubeEl = document.createElement("div");
        cubeEl.classList.add("cube");
        if(cube.type === CUBE_NORMAL){
          cubeEl.classList.add("cube-normal");
          cubeEl.textContent = "";
        }else if(cube.type === CUBE_ADV){
          cubeEl.classList.add("cube-adv");
          cubeEl.textContent = "";
        }else if(cube.type === CUBE_FORBID){
          cubeEl.classList.add("cube-forbid");
          cubeEl.textContent = "X";
        }
        cell.appendChild(cubeEl);
      }

      // プレイヤー
      if(player.row === r && player.col === c){
        const shadow = document.createElement("div");
        shadow.className = "player-shadow";
        const pEl = document.createElement("div");
        pEl.className = "player";
        cell.appendChild(shadow);
        cell.appendChild(pEl);
      }

      // タップ／ダブルタップ
      cell.addEventListener("click", ()=>{
        handleCellTap(r,c);
      });

      boardEl.appendChild(cell);
    }
  }
}

// ======================
//  爆破
// ======================
function fireMarks(){
  if(!stage) return;
  let destroyedThisFire = 0;

  // まずマークの位置一覧を取得
  const markedCells = [];
  for(let r = 0; r < rows; r++){
    for(let c = 0; c < cols; c++){
      if(marks[r][c]) markedCells.push({r,c});
    }
  }
  if(markedCells.length === 0) return;

  // 爆破対象を集める
  const toDestroyIndices = new Set();

  function addDestroyAtCell(rr,cc){
    const idx = cubes.findIndex(k => k.row === rr && k.col === cc);
    if(idx >= 0) toDestroyIndices.add(idx);
  }

  for(const {r,c} of markedCells){
    const idx = cubes.findIndex(k => k.row === r && k.col === c);
    if(idx >= 0){
      const cube = cubes[idx];
      if(cube.type === CUBE_ADV){
        // アドバンテージ: 3x3範囲爆破
        for(let rr = r-1; rr <= r+1; rr++){
          for(let cc = c-1; cc <= c+1; cc++){
            if(rr >= 0 && rr < rows && cc >= 0 && cc < cols){
              addDestroyAtCell(rr,cc);
            }
          }
        }
      }else{
        // 通常: そのマスのみ
        addDestroyAtCell(r,c);
      }
    }
  }

  if(toDestroyIndices.size === 0){
    // 何も破壊できなかった → ペナルティは付けずマークだけ外す
    marks.forEach(row=>row.fill(false));
    renderBoard();
    return;
  }

  // 実際に破壊
  const sorted = Array.from(toDestroyIndices).sort((a,b)=>b-a); // 後ろから消す
  for(const idx of sorted){
    const cube = cubes[idx];
    if(!cube) continue;
    destroyedThisFire++;
    destroyedTotal++;
    if(cube.type === CUBE_NORMAL){
      hitNormal++;
      score += 10;
    }else if(cube.type === CUBE_ADV){
      hitAdv++;
      score += 25;
    }else if(cube.type === CUBE_FORBID){
      hitForbid++;
      score -= 20;
    }
    cubes.splice(idx,1);
  }

  // マーク解除
  marks.forEach(row=>row.fill(false));

  // 禁止キューブ上限チェック
  if(hitForbid >= MAX_FORBID_HIT){
    onGameOver("禁止キューブを破壊しすぎました…", false);
  }else{
    updateStatus();
    renderBoard();
  }
}

// ======================
//  キューブ更新
// ======================

// 新しい波を奥側に出す
function spawnNextWave(){
  if(spawnIndex >= stage.waves.length) return;
  const wave = stage.waves[spawnIndex];
  const backRow = rows - 1;
  for(let c = 0; c < Math.min(cols,wave.length); c++){
    const t = wave[c];
    if(t !== CUBE_NONE){
      cubes.push({row:backRow,col:c,type:t});
    }
  }
  spawnIndex++;
}

// 1ティック進める
function tick(){
  if(!isRunning || !stage) return;

  // まず全て前進（手前へ）
  for(const cube of cubes){
    cube.row--;
  }

  // プレイヤーと同じマスに来ていないかチェック
  if(cubes.some(k => k.row === player.row && k.col === player.col)){
    onGameOver("キューブに押しつぶされました…", false);
    return;
  }

  // 手前から落ちたキューブ処理
  const remain = [];
  for(const cube of cubes){
    if(cube.row < 0){
      // 盤面から落下
      if(cube.type === CUBE_NORMAL || cube.type === CUBE_ADV){
        missed++;
        score -= 5;
      }
      // forbidden は落とすのが正解なのでノーペナ
    }else{
      remain.push(cube);
    }
  }
  cubes = remain;

  if(missed >= MAX_MISSED){
    onGameOver("キューブを落としすぎました…", false);
    return;
  }

  // 新しい波を出す（残りがあれば）
  if(spawnIndex < stage.waves.length){
    spawnNextWave();
  }else{
    // もう波は出ない → 全て消せばステージクリア
    if(cubes.length === 0){
      onStageClear();
      return;
    }
  }

  updateStatus();
  renderBoard();
}

// ======================
//  ゲーム開始・停止
// ======================
function startTick(){
  if(tickTimer) return;
  tickTimer = setInterval(tick, stage.tickMs);
}
function stopTick(){
  if(tickTimer){
    clearInterval(tickTimer);
    tickTimer = null;
  }
}

function toggleStartPause(){
  if(!stage) return;
  if(!isRunning){
    isRunning = true;
    startTick();
  }else{
    isRunning = false;
    stopTick();
  }
}

// ======================
//  結果処理
// ======================
function calcIqScore(){
  // かなり簡略化した「雰囲気」スコア
  const base = 80 + (currentStageIndex * 10);
  const bonusHit = hitNormal * 2 + hitAdv * 5;
  const penalty = missed * 4 + hitForbid * 8;
  let s = base + bonusHit - penalty;
  if(destroyedTotal > 0 && missed === 0 && hitForbid === 0){
    s += 20; // パーフェクトボーナス
  }
  if(s < 60) s = 60;
  if(s > 180) s = 180;
  return Math.round(s);
}

function onStageClear(){
  stopTick();
  isRunning = false;
  iqScore = calcIqScore();
  updateStatus();

  const perfect = (missed === 0 && hitForbid === 0);

  overlayTitleEl.textContent = "Stage Clear!";
  overlaySubEl.textContent = `ステージ「${stage.name}」クリア！`;
  overlayStageEl.textContent = `${currentStageIndex+1} / ${STAGES.length}`;
  overlayScoreEl.textContent = score.toString();
  overlayIqEl.textContent = iqScore.toString();
  overlayHitNormalEl.textContent = hitNormal.toString();
  overlayHitAdvEl.textContent = hitAdv.toString();
  overlayMissedEl.textContent = missed.toString();
  overlayForbidEl.textContent = hitForbid.toString();
  overlayPerfectEl.textContent = perfect ? "YES" : "NO";

  overlayNextBtn.textContent = currentStageIndex < STAGES.length-1
    ? "▶ 次のステージへ"
    : "▶ もう一周（Stage 1へ）";

  overlayEl.classList.remove("hidden");
}

function onGameOver(message, isClear){
  stopTick();
  isRunning = false;
  iqScore = calcIqScore();
  updateStatus();

  overlayTitleEl.textContent = "Game Over";
  overlaySubEl.textContent = message;
  overlayStageEl.textContent = `${currentStageIndex+1} / ${STAGES.length}`;
  overlayScoreEl.textContent = score.toString();
  overlayIqEl.textContent = iqScore.toString();
  overlayHitNormalEl.textContent = hitNormal.toString();
  overlayHitAdvEl.textContent = hitAdv.toString();
  overlayMissedEl.textContent = missed.toString();
  overlayForbidEl.textContent = hitForbid.toString();
  overlayPerfectEl.textContent = (missed === 0 && hitForbid === 0) ? "YES" : "NO";

  overlayNextBtn.textContent = "▶ 同じステージでもう一度";
  overlayEl.classList.remove("hidden");
}

// ======================
//  イベント設定
// ======================
function setupControls(){
  btnFire.addEventListener("click", ()=>fireMarks());
  btnStart.addEventListener("click", ()=>toggleStartPause());
  btnRestart.addEventListener("click", ()=>initStage(currentStageIndex));

  overlayNextBtn.addEventListener("click", ()=>{
    overlayEl.classList.add("hidden");
    if(overlayTitleEl.textContent === "Game Over"){
      // Game Over のときは同じステージをやり直し
      initStage(currentStageIndex);
    }else{
      // Clear のときは次へ
      const nextIndex = currentStageIndex < STAGES.length-1 ? currentStageIndex+1 : 0;
      initStage(nextIndex);
    }
  });

  overlayRetryBtn.addEventListener("click", ()=>{
    overlayEl.classList.add("hidden");
    initStage(currentStageIndex);
  });

  // キーボード操作（D-Padはないが、矢印キーは残す）
  window.addEventListener("keydown", (ev)=>{
    const key = ev.key;
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," ","z","Z","x","X","r","R"].includes(key)){
      ev.preventDefault();
    }

    if(key === "ArrowUp") movePlayer(1,0);        // 奥方向
    else if(key === "ArrowDown") movePlayer(-1,0);// 手前方向
    else if(key === "ArrowLeft") movePlayer(0,-1);
    else if(key === "ArrowRight") movePlayer(0,1);
    else if(key === "z" || key === "Z") toggleMark();
    else if(key === "x" || key === "X") fireMarks();
    else if(key === " "){
      toggleStartPause();
    }else if(key === "r" || key === "R"){
      initStage(currentStageIndex);
    }
  });
}

// ======================
//  起動
// ======================
(function(){
  setupControls();
  initStage(0);
})();
</script>
</body>
</html>
