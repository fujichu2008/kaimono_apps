<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, viewport-fit=cover, user-scalable=no" />
<title>Sunâ€“Earthâ€“Moon 3D & Sky Simulator</title>
<style>
  :root{
    --bg0:#070A12; --bg1:#0b1430;
    --card: rgba(255,255,255,.06);
    --card2: rgba(255,255,255,.09);
    --line: rgba(255,255,255,.12);
    --text:#EAF1FF; --muted:#A8B4D6;
    --pri:#58B6FF; --ok:#2EE59D; --warn:#FFC857; --danger:#FF5C7A;
    --shadow: 0 18px 50px rgba(0,0,0,.45);
    --r:18px;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; color:var(--text); background: radial-gradient(1200px 900px at 20% 10%, #122a66 0%, transparent 60%),
                                            radial-gradient(1100px 800px at 90% 30%, #2a145a 0%, transparent 65%),
                                            linear-gradient(180deg, var(--bg0), var(--bg1)); font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Display", "Segoe UI", Arial;}
  a{color:var(--pri)}
  .wrap{height:100%; display:flex; flex-direction:column}
  header{
    padding:14px 14px 10px;
    position:sticky; top:0; z-index:5;
    backdrop-filter: blur(12px);
    background: linear-gradient(180deg, rgba(7,10,18,.84), rgba(7,10,18,.45));
    border-bottom: 1px solid var(--line);
  }
  .topRow{display:flex; align-items:flex-end; justify-content:space-between; gap:10px; flex-wrap:wrap}
  .brand{display:flex; align-items:center; gap:10px}
  .logo{
    width:38px; height:38px; border-radius:12px;
    background: radial-gradient(circle at 30% 30%, #9AE6FF 0%, #2B7BFF 35%, #6B2BFF 75%, #1A0E2E 100%);
    box-shadow: 0 10px 30px rgba(88,182,255,.25);
    position:relative; overflow:hidden;
  }
  .logo::after{
    content:""; position:absolute; inset:-30%;
    background: conic-gradient(from 220deg, transparent 0 55%, rgba(255,255,255,.35) 65%, transparent 85%);
    transform: rotate(0deg);
    animation: spin 6s linear infinite;
  }
  @keyframes spin{to{transform:rotate(360deg)}}
  h1{margin:0; font-size:15px; letter-spacing:.2px}
  .sub{margin:2px 0 0; font-size:12px; color:var(--muted)}
  .pillRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .pill{
    background: rgba(255,255,255,.06);
    border:1px solid var(--line);
    border-radius:999px;
    padding:7px 10px;
    font-size:12px;
    display:flex; gap:8px; align-items:center;
    box-shadow: 0 10px 24px rgba(0,0,0,.18);
  }
  .pill b{font-weight:650}
  .grid{
    flex:1;
    display:grid;
    grid-template-columns: 1.35fr 1fr;
    gap:12px;
    padding:12px;
    min-height:0;
  }
  @media (max-width: 980px){
    .grid{grid-template-columns: 1fr; }
  }
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
    border:1px solid var(--line);
    border-radius: var(--r);
    box-shadow: var(--shadow);
    overflow:hidden;
    min-height:0;
    position:relative;
    display:flex;
    flex-direction:column;
  }
  .cardHeader{
    padding:10px 12px;
    display:flex; align-items:center; justify-content:space-between; gap:8px;
    border-bottom:1px solid rgba(255,255,255,.08);
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
  }
  .cardHeader .title{font-size:13px; font-weight:700; letter-spacing:.2px}
  .cardHeader .hint{font-size:12px; color:var(--muted)}
  .canvasWrap{
    position:relative;
    flex:1 1 auto;
    min-height:260px;
  }
  canvas{display:block; width:100%; height:100%;}
  .panel{
    display:flex; flex-direction:column; gap:12px;
    padding:12px;
    min-height:0;
  }
  .controls{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }
  @media (max-width: 980px){
    .controls{grid-template-columns:1fr}
  }
  .ctrl{
    background: rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.10);
    border-radius: 14px;
    padding:10px;
  }
  .ctrl .lbl{font-size:12px; color:var(--muted); margin-bottom:6px}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  input, select, button{
    font: inherit;
    color: var(--text);
    background: rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px;
    padding:10px 10px;
    outline:none;
  }
  input[type="number"]{width: 120px}
  input[type="datetime-local"]{width: 100%}
  input[type="range"]{width: 100%}
  button{
    cursor:pointer;
    transition: transform .06s ease, filter .2s ease, background .2s ease;
  }
  button:active{transform: translateY(1px)}
  .btnPri{background: linear-gradient(180deg, rgba(88,182,255,.30), rgba(88,182,255,.14)); border-color: rgba(88,182,255,.40)}
  .btnOk{background: linear-gradient(180deg, rgba(46,229,157,.25), rgba(46,229,157,.12)); border-color: rgba(46,229,157,.40)}
  .btnGhost{background: rgba(255,255,255,.04)}
  .btnWarn{background: linear-gradient(180deg, rgba(255,200,87,.22), rgba(255,200,87,.10)); border-color: rgba(255,200,87,.35)}
  .mini{padding:8px 10px; border-radius: 12px; font-size:12px}
  .kpiGrid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
  }
  .kpi{
    padding:10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
  }
  .kpi .k{font-size:12px; color:var(--muted)}
  .kpi .v{font-size:14px; font-weight:750; margin-top:4px}
  .sep{height:1px; background: rgba(255,255,255,.10); margin:2px 0 0}
  .note{font-size:12px; color:var(--muted); line-height:1.4}
  .bar{
    height:12px; border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.25);
  }
  .bar > div{height:100%; width:50%; background: linear-gradient(90deg, rgba(88,182,255,.20), rgba(46,229,157,.35));}
  .legend{display:flex; gap:10px; flex-wrap:wrap; font-size:12px; color:var(--muted); margin-top:6px}
  .dot{display:inline-block; width:10px; height:10px; border-radius:999px; margin-right:6px; vertical-align:-1px}
  .sunDot{background:#FFD66B; box-shadow:0 0 12px rgba(255,214,107,.45)}
  .moonDot{background:#CFE2FF; box-shadow:0 0 12px rgba(207,226,255,.35)}
  .nightDot{background:#7C8BFF; box-shadow:0 0 12px rgba(124,139,255,.35)}
  .toast{
    position: fixed; left: 50%; bottom: 14px; transform: translateX(-50%);
    background: rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.18);
    padding:10px 12px;
    border-radius: 14px;
    box-shadow: 0 18px 50px rgba(0,0,0,.45);
    color: var(--text);
    font-size: 12px;
    opacity:0; pointer-events:none;
    transition: opacity .25s ease, transform .25s ease;
    z-index: 50;
  }
  .toast.show{opacity:1; transform: translateX(-50%) translateY(-4px)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="topRow">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Sunâ€“Earthâ€“Moon 3D & Sky Simulator</h1>
          <div class="sub">æ—¥æ™‚ãƒ»åœ°ç‚¹ã‚’æŒ‡å®šã—ã¦ã€3Då…¬è»¢/è‡ªè»¢ï¼‹åœ°å¹³ç·šã‹ã‚‰è¦‹ãŸå¤ªé™½/æœˆã®å‹•ãï¼ˆæ˜¼å¤œãƒ»æ—¥ã®å‡º/æ—¥æ²¡ï¼‰ã‚’å¯è¦–åŒ–</div>
        </div>
      </div>
      <div class="pillRow">
        <div class="pill"><span class="dot sunDot"></span><b>Sun</b><span>ä½ç½®/è»Œè·¡</span></div>
        <div class="pill"><span class="dot moonDot"></span><b>Moon</b><span>ä½ç½®/è»Œè·¡</span></div>
        <div class="pill"><span class="dot nightDot"></span><b>Day/Night</b><span>åœ°çƒã®ç…§æ˜</span></div>
      </div>
    </div>
  </header>

  <div class="grid">
    <section class="card" id="sysCard">
      <div class="cardHeader">
        <div>
          <div class="title">3D Systemï¼ˆå¤ªé™½â€“åœ°çƒâ€“æœˆï¼‰</div>
          <div class="hint">ãƒ‰ãƒ©ãƒƒã‚°:å›è»¢ / ãƒ›ã‚¤ãƒ¼ãƒ«:ã‚ºãƒ¼ãƒ  / å³ãƒ‰ãƒ©ãƒƒã‚°:å¹³è¡Œç§»å‹•ï¼ˆã‚¹ãƒãƒ›: 2æœ¬æŒ‡ã§ã‚ºãƒ¼ãƒ /ãƒ‘ãƒ³ï¼‰</div>
        </div>
        <div class="row">
          <button class="mini btnGhost" id="btnSysReset">ã‚«ãƒ¡ãƒ©Reset</button>
          <button class="mini btnGhost" id="btnScale">ã‚¹ã‚±ãƒ¼ãƒ«åˆ‡æ›¿</button>
        </div>
      </div>
      <div class="canvasWrap"><canvas id="sys"></canvas></div>
    </section>

    <section class="card">
      <div class="cardHeader">
        <div>
          <div class="title">Local Skyï¼ˆé¸æŠåœ°ç‚¹ã‹ã‚‰ã®è¦‹ãˆæ–¹ï¼‰</div>
          <div class="hint">å¤ªé™½/æœˆã®æ–¹ä½ãƒ»é«˜åº¦ã¨è»Œè·¡ã€æ—¥ã®å‡º/æ—¥æ²¡ã€æœˆã®å‡º/å…¥ã‚Šæ¨å®š</div>
        </div>
        <div class="row">
          <button class="mini btnGhost" id="btnSkyReset">è¦–ç‚¹Reset</button>
          <button class="mini btnGhost" id="btnTogglePaths">è»Œè·¡ ON/OFF</button>
        </div>
      </div>
      <div class="canvasWrap"><canvas id="sky"></canvas></div>
      <div class="panel">

        <div class="controls">
          <div class="ctrl">
            <div class="lbl">æ—¥æ™‚ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰ / å†ç”Ÿ</div>
            <div class="row">
              <input type="datetime-local" id="dt" />
              <button class="btnPri" id="btnPlay">â–¶</button>
              <button class="btnGhost" id="btnNow">Now</button>
            </div>
            <div class="row" style="margin-top:8px">
              <input type="range" id="timeSlider" min="0" max="86400" step="10" value="43200" />
            </div>
            <div class="row" style="justify-content:space-between; margin-top:6px">
              <div style="font-size:12px; color:var(--muted)">00:00</div>
              <div style="font-size:12px; color:var(--muted)">12:00</div>
              <div style="font-size:12px; color:var(--muted)">24:00</div>
            </div>
            <div class="row" style="margin-top:8px">
              <span style="font-size:12px; color:var(--muted)">é€Ÿåº¦</span>
              <button class="mini btnGhost speed" data-mult="1">Ã—1</button>
              <button class="mini btnGhost speed" data-mult="60">Ã—60</button>
              <button class="mini btnGhost speed" data-mult="600">Ã—600</button>
              <button class="mini btnGhost speed" data-mult="3600">Ã—3600</button>
              <span style="font-size:12px; color:var(--muted); margin-left:auto">TZ</span>
              <select id="tz">
                <option value="540">UTC+09:00 (Tokyo)</option>
                <option value="0">UTCÂ±00:00</option>
                <option value="-300">UTC-05:00</option>
                <option value="60">UTC+01:00</option>
                <option value="600">UTC+10:00</option>
              </select>
            </div>
          </div>

          <div class="ctrl">
            <div class="lbl">åœ°ç‚¹ï¼ˆãƒ—ãƒªã‚»ãƒƒãƒˆ or ç·¯åº¦çµŒåº¦ï¼‰</div>
            <div class="row">
              <select id="place">
                <option value="35.681236,139.767125">Tokyoï¼ˆæ±äº¬é§…ï¼‰</option>
                <option value="34.6937,135.5023">Osakaï¼ˆå¤§é˜ªï¼‰</option>
                <option value="43.0621,141.3544">Sapporoï¼ˆæœ­å¹Œï¼‰</option>
                <option value="26.2124,127.6809">Nahaï¼ˆé‚£è¦‡ï¼‰</option>
                <option value="40.7128,-74.0060">New York</option>
                <option value="51.5074,-0.1278">London</option>
                <option value="-33.8688,151.2093">Sydney</option>
              </select>
              <button class="btnGhost" id="btnCopyLink">URLå…±æœ‰</button>
            </div>
            <div class="row" style="margin-top:8px">
              <input type="number" id="lat" step="0.0001" placeholder="lat" />
              <input type="number" id="lon" step="0.0001" placeholder="lon" />
              <button class="btnOk" id="btnApplyLL">é©ç”¨</button>
              <button class="btnWarn" id="btnTokyo">æ±äº¬</button>
            </div>
            <div class="row" style="margin-top:8px">
              <button class="mini btnGhost" id="btnMoon">æœˆã‚’è¡¨ç¤º: ON</button>
              <button class="mini btnGhost" id="btnLabels">ãƒ©ãƒ™ãƒ«: ON</button>
              <button class="mini btnGhost" id="btnPin">åœ°çƒãƒ”ãƒ³: ON</button>
            </div>
            <div class="note" style="margin-top:8px">
              â€»æœˆã®ä½ç½®/å‡ºå…¥ã‚Šã¯ä½ã€œä¸­ç²¾åº¦ã®è¿‘ä¼¼è¨ˆç®—ã§ã™ï¼ˆå­¦ç¿’ãƒ»æ¦‚è¦³å‘ã‘ï¼‰ã€‚å¤©ä½“è¦³æ¸¬ã®å³å¯†ç”¨é€”ã«ã¯å›½ç«‹å¤©æ–‡å°ç­‰ã®æš¦è¨ˆç®—ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚
            </div>
          </div>
        </div>

        <div class="kpiGrid">
          <div class="kpi">
            <div class="k">ç¾åœ¨æ™‚åˆ»ï¼ˆåœ°ç‚¹TZï¼‰</div>
            <div class="v" id="kNow">â€”</div>
            <div class="sep"></div>
            <div class="legend">
              <span><span class="dot sunDot"></span>å¤ªé™½ é«˜åº¦/æ–¹ä½</span>
              <span><span class="dot moonDot"></span>æœˆ é«˜åº¦/æ–¹ä½</span>
            </div>
          </div>
          <div class="kpi">
            <div class="k">æ—¥ã®å‡º / æ—¥æ²¡ï¼ˆæ¨å®šï¼‰</div>
            <div class="v" id="kSunTimes">â€”</div>
            <div class="sep"></div>
            <div class="k" style="margin-top:8px">æœˆã®å‡º / æœˆã®å…¥ã‚Šï¼ˆæ¨å®šï¼‰</div>
            <div class="v" id="kMoonTimes">â€”</div>
          </div>
        </div>

        <div class="ctrl" style="padding:10px">
          <div class="lbl">æ˜¼å¤œãƒãƒ¼ï¼ˆç¾åœ¨ï¼‰</div>
          <div class="bar"><div id="dayBar"></div></div>
          <div class="row" style="justify-content:space-between; margin-top:6px; font-size:12px; color:var(--muted)">
            <span id="barLeft">Night</span><span id="barMid">â€”</span><span id="barRight">Day</span>
          </div>
        </div>
      </div>
    </section>
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
(() => {
  // -----------------------------
  // Tiny UI helpers
  // -----------------------------
  const $ = (sel) => document.querySelector(sel);
  const toastEl = $("#toast");
  let toastTimer = null;
  function toast(msg){
    clearTimeout(toastTimer);
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    toastTimer = setTimeout(()=>toastEl.classList.remove("show"), 1800);
  }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function fmtTimeHM(date){ return `${pad2(date.getHours())}:${pad2(date.getMinutes())}`; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  // -----------------------------
  // OrbitControlsä»£æ›¿ï¼ˆè»½é‡ï¼‰
  //  - 1æœ¬æŒ‡/å·¦ãƒ‰ãƒ©ãƒƒã‚°: å›è»¢
  //  - ãƒ›ã‚¤ãƒ¼ãƒ«/ãƒ”ãƒ³ãƒ: ã‚ºãƒ¼ãƒ 
  //  - å³ãƒ‰ãƒ©ãƒƒã‚°/2æœ¬æŒ‡ç§»å‹•: ãƒ‘ãƒ³
  // -----------------------------
  class OrbitLite{
    constructor(camera, dom, opts={}){
      this.camera = camera;
      this.dom = dom;
      this.enabled = true;

      this.target = opts.target || new THREE.Vector3();
      this.enablePan = (opts.enablePan ?? true);
      this.enableDamping = (opts.enableDamping ?? true);
      this.dampingFactor = (opts.dampingFactor ?? 0.10);

      this.rotateSpeed = (opts.rotateSpeed ?? 1.0);
      this.zoomSpeed   = (opts.zoomSpeed   ?? 1.0);
      this.panSpeed    = (opts.panSpeed    ?? 1.0);

      this.minDistance = (opts.minDistance ?? 0.2);
      this.maxDistance = (opts.maxDistance ?? 200);
      this.minPolarAngle = (opts.minPolarAngle ?? 0.0001);
      this.maxPolarAngle = (opts.maxPolarAngle ?? Math.PI - 0.0001);

      this._pointers = new Map(); // id -> {x,y,px,py}
      this._mode = "none"; // rotate/pan
      this._spherical = new THREE.Spherical();
      this._sphericalT = new THREE.Spherical();

      this._tmpV = new THREE.Vector3();
      this._tmpDir = new THREE.Vector3();
      this._tmpRight = new THREE.Vector3();
      this._tmpUp = new THREE.Vector3();

      this._updateSphericalFromCamera();
      this._sphericalT.copy(this._spherical);

      dom.style.touchAction = "none";
      dom.addEventListener("contextmenu", (e)=>e.preventDefault());
      dom.addEventListener("pointerdown", this._onDown, {passive:false});
      window.addEventListener("pointermove", this._onMove, {passive:false});
      window.addEventListener("pointerup", this._onUp, {passive:false});
      dom.addEventListener("wheel", this._onWheel, {passive:false});
    }

    _updateSphericalFromCamera(){
      const off = this._tmpV.copy(this.camera.position).sub(this.target);
      this._spherical.setFromVector3(off);
      this._spherical.radius = clamp(this._spherical.radius, this.minDistance, this.maxDistance);
      this._spherical.phi = clamp(this._spherical.phi, this.minPolarAngle, this.maxPolarAngle);
    }

    _applySpherical(sph){
      const off = this._tmpV.setFromSpherical(sph);
      this.camera.position.copy(this.target).add(off);
      this.camera.lookAt(this.target);
    }

    _panPixels(dx, dy){
      if(!this.enablePan) return;
      const rect = this.dom.getBoundingClientRect();
      const h = Math.max(1, rect.height);

      const offset = this._tmpV.copy(this.camera.position).sub(this.target);
      const distance = offset.length();

      const fov = (this.camera.fov ?? 50) * Math.PI/180;
      const targetDist = distance * Math.tan(fov/2);

      const panX = (2 * dx * targetDist / h) * this.panSpeed;
      const panY = (2 * dy * targetDist / h) * this.panSpeed;

      this.camera.getWorldDirection(this._tmpDir).normalize(); // forward (camera->scene)
      this._tmpRight.crossVectors(this._tmpDir, this.camera.up).normalize(); // right
      this._tmpUp.copy(this.camera.up).normalize();

      // ãƒ‰ãƒ©ãƒƒã‚°æ–¹å‘ã«è‡ªç„¶ã«è¦‹ãˆã‚‹ã‚ˆã†ç¬¦å·èª¿æ•´
      const move = new THREE.Vector3()
        .addScaledVector(this._tmpRight, -panX)
        .addScaledVector(this._tmpUp, panY);

      this.target.add(move);
      this.camera.position.add(move);
    }

    _dolly(scale){
      this._sphericalT.radius = clamp(this._sphericalT.radius * scale, this.minDistance, this.maxDistance);
    }

    _onDown = (e) => {
      if(!this.enabled) return;
      e.preventDefault();

      this.dom.setPointerCapture?.(e.pointerId);
      this._pointers.set(e.pointerId, {x:e.clientX, y:e.clientY, px:e.clientX, py:e.clientY});

      if(this._pointers.size === 1){
        // 0:å·¦=å›è»¢ / 2:å³=ãƒ‘ãƒ³ï¼ˆå³ã‚¯ãƒªãƒƒã‚¯æƒ³å®šï¼‰
        this._mode = (e.button === 2) ? "pan" : "rotate";
      }else if(this._pointers.size === 2){
        this._mode = "touch2"; // pinch/pan
      }
    };

    _onMove = (e) => {
      if(!this.enabled) return;
      const p = this._pointers.get(e.pointerId);
      if(!p) return;

      e.preventDefault();
      p.px = p.x; p.py = p.y;
      p.x = e.clientX; p.y = e.clientY;

      if(this._pointers.size === 1){
        const dx = p.x - p.px;
        const dy = p.y - p.py;
        if(this._mode === "rotate"){
          const rot = 0.005 * this.rotateSpeed;
          this._sphericalT.theta -= dx * rot;
          this._sphericalT.phi   -= dy * rot;
          this._sphericalT.phi = clamp(this._sphericalT.phi, this.minPolarAngle, this.maxPolarAngle);
        }else if(this._mode === "pan"){
          this._panPixels(dx, dy);
        }
      }else if(this._pointers.size === 2){
        const arr = Array.from(this._pointers.values());
        const a = arr[0], b = arr[1];

        const prevCx = (a.px + b.px)/2;
        const prevCy = (a.py + b.py)/2;
        const currCx = (a.x + b.x)/2;
        const currCy = (a.y + b.y)/2;

        const prevDist = Math.hypot(a.px - b.px, a.py - b.py);
        const currDist = Math.hypot(a.x  - b.x,  a.y  - b.y);

        // 2æœ¬æŒ‡ç§»å‹• = ãƒ‘ãƒ³
        this._panPixels(currCx - prevCx, currCy - prevCy);

        // ãƒ”ãƒ³ãƒ = ã‚ºãƒ¼ãƒ ï¼ˆé–‹ã=ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ï¼‰
        if(prevDist > 0 && currDist > 0){
          const zoomFactor = currDist / prevDist;
          const scale = 1 / Math.pow(zoomFactor, this.zoomSpeed);
          this._dolly(scale);
        }
      }
    };

    _onUp = (e) => {
      if(this._pointers.has(e.pointerId)){
        this._pointers.delete(e.pointerId);
      }
      if(this._pointers.size === 0){
        this._mode = "none";
      }else if(this._pointers.size === 1){
        this._mode = "rotate";
      }
    };

    _onWheel = (e) => {
      if(!this.enabled) return;
      e.preventDefault();

      const delta = Math.sign(e.deltaY);
      // deltaY>0: zoom out, deltaY<0: zoom in
      const scale = Math.pow(1.07, delta * this.zoomSpeed);
      this._dolly(scale);
    };

    update(){
      // ç›®æ¨™å€¤ã¸è¿½å¾“
      this._updateSphericalFromCamera(); // currentã®æ•´åˆæ€§ã‚’æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å–ã‚‹ï¼ˆtargetå¤‰æ›´ã«å¼·ã„ï¼‰

      if(this.enableDamping){
        this._spherical.theta += (this._sphericalT.theta - this._spherical.theta) * this.dampingFactor;
        this._spherical.phi   += (this._sphericalT.phi   - this._spherical.phi)   * this.dampingFactor;
        this._spherical.radius+= (this._sphericalT.radius- this._spherical.radius)* this.dampingFactor;
      }else{
        this._spherical.copy(this._sphericalT);
      }

      this._spherical.radius = clamp(this._spherical.radius, this.minDistance, this.maxDistance);
      this._spherical.phi = clamp(this._spherical.phi, this.minPolarAngle, this.maxPolarAngle);

      this._applySpherical(this._spherical);
    }
  }

  // -----------------------------
  // Astronomy (approx)
  // -----------------------------
  const rad = Math.PI/180, deg = 180/Math.PI;
  const dayMs = 86400000;
  const J1970 = 2440588;
  const J2000 = 2451545;

  function toJulian(dateUTC){ return dateUTC.valueOf()/dayMs - 0.5 + J1970; }
  function fromJulian(j){ return new Date((j + 0.5 - J1970)*dayMs); }
  function toDays(dateUTC){ return toJulian(dateUTC) - J2000; }

  function rightAscension(l, b){
    const e = 23.4397*rad;
    return Math.atan2(Math.sin(l)*Math.cos(e) - Math.tan(b)*Math.sin(e), Math.cos(l));
  }
  function declination(l, b){
    const e = 23.4397*rad;
    return Math.asin(Math.sin(b)*Math.cos(e) + Math.cos(b)*Math.sin(e)*Math.sin(l));
  }
  function azimuth(H, phi, dec){
    return Math.atan2(Math.sin(H), Math.cos(H)*Math.sin(phi) - Math.tan(dec)*Math.cos(phi));
  }
  function altitude(H, phi, dec){
    return Math.asin(Math.sin(phi)*Math.sin(dec) + Math.cos(phi)*Math.cos(dec)*Math.cos(H));
  }
  function siderealTime(d, lw){
    return (280.16*rad + 360.9856235*rad*d) - lw;
  }
  function astroRefraction(h){
    if (h < 0) h = 0;
    return 0.0002967 / Math.tan(h + 0.00312536/(h + 0.08901179));
  }

  function solarMeanAnomaly(d){ return (357.5291 + 0.98560028*d)*rad; }
  function eclipticLongitude(M){
    const C = (1.9148*Math.sin(M) + 0.02*Math.sin(2*M) + 0.0003*Math.sin(3*M))*rad;
    const P = 102.9372*rad;
    return M + C + P + Math.PI;
  }
  function sunCoords(d){
    const M = solarMeanAnomaly(d);
    const L = eclipticLongitude(M);
    return { dec: declination(L, 0), ra: rightAscension(L, 0), M, L };
  }
  function getSunPosition(dateUTC, lat, lon){
    const lw = -lon*rad;
    const phi = lat*rad;
    const d = toDays(dateUTC);
    const c = sunCoords(d);
    const H = siderealTime(d, lw) - c.ra;
    const h = altitude(H, phi, c.dec);
    const a = azimuth(H, phi, c.dec);
    return { az: (a*deg + 180 + 360) % 360, alt: (h*deg) };
  }

  function julianCycle(d, lw){ return Math.round(d - 0.0009 - lw/(2*Math.PI)); }
  function approxTransit(Ht, lw, n){ return 0.0009 + (Ht + lw)/(2*Math.PI) + n; }
  function solarTransitJ(ds, M, L){ return J2000 + ds + 0.0053*Math.sin(M) - 0.0069*Math.sin(2*L); }
  function hourAngle(h, phi, dec){
    return Math.acos((Math.sin(h) - Math.sin(phi)*Math.sin(dec)) / (Math.cos(phi)*Math.cos(dec)));
  }
  function getSunTimes(dateLocalMidnight, lat, lon, tzMin){
    const utcMid = new Date(dateLocalMidnight.getTime() - tzDeltaMs(dateLocalMidnight, tzMin));
    const lw = -lon*rad;
    const phi = lat*rad;
    const d = toDays(utcMid);
    const n = julianCycle(d, lw);
    const ds = approxTransit(0, lw, n);
    const M = solarMeanAnomaly(ds);
    const L = eclipticLongitude(M);
    const dec = declination(L, 0);
    const Jnoon = solarTransitJ(ds, M, L);

    const h0 = (-0.833)*rad;
    const w0 = hourAngle(h0, phi, dec);
    const a = approxTransit(w0, lw, n);
    const b = approxTransit(-w0, lw, n);
    const Jrise = solarTransitJ(a, M, L);
    const Jset  = solarTransitJ(b, M, L);

    return { solarNoonUTC: fromJulian(Jnoon), sunriseUTC: fromJulian(Jrise), sunsetUTC: fromJulian(Jset) };
  }

  function moonCoords(d){
    const L = (218.316 + 13.176396*d)*rad;
    const M = (134.963 + 13.064993*d)*rad;
    const F = (93.272  + 13.229350*d)*rad;

    const l  = L + 6.289*rad*Math.sin(M);
    const b  = 5.128*rad*Math.sin(F);
    const dt = 385001 - 20905*Math.cos(M);

    const ra  = rightAscension(l, b);
    const dec = declination(l, b);
    return { ra, dec, dist: dt };
  }
  function getMoonPosition(dateUTC, lat, lon){
    const lw = -lon*rad;
    const phi = lat*rad;
    const d = toDays(dateUTC);
    const c = moonCoords(d);
    const H = siderealTime(d, lw) - c.ra;
    let h = altitude(H, phi, c.dec);
    h = h + astroRefraction(h);
    const a = azimuth(H, phi, c.dec);
    return { az: (a*deg + 180 + 360) % 360, alt: h*deg, distKm: c.dist };
  }
  function refineCross(t0, t1, lat, lon, targetAltDeg, rising){
    let a = t0.getTime(), b = t1.getTime();
    for(let i=0;i<14;i++){
      const m = (a+b)/2;
      const alt = getMoonPosition(new Date(m), lat, lon).alt;
      if(rising){
        if(alt >= targetAltDeg) b = m; else a = m;
      }else{
        if(alt < targetAltDeg) b = m; else a = m;
      }
    }
    return new Date(b);
  }
  function getMoonTimes(dateLocalMidnight, lat, lon, tzMin){
    const startUTC = new Date(dateLocalMidnight.getTime() - tzDeltaMs(dateLocalMidnight, tzMin));
    const endUTC = new Date(startUTC.getTime() + dayMs);
    const stepMin = 5;
    let prevAlt = null, prevT = null;
    let rise = null, set = null;

    for(let t = startUTC.getTime(); t <= endUTC.getTime(); t += stepMin*60000){
      const dt = new Date(t);
      const alt = getMoonPosition(dt, lat, lon).alt;
      if(prevAlt !== null){
        if(!rise && prevAlt < 0 && alt >= 0) rise = refineCross(prevT, dt, lat, lon, 0, true);
        if(!set  && prevAlt >=0 && alt < 0) set  = refineCross(prevT, dt, lat, lon, 0, false);
        if(rise && set) break;
      }
      prevAlt = alt; prevT = dt;
    }
    return { moonriseUTC: rise, moonsetUTC: set };
  }

  function azAltToENU(azDeg, altDeg){
    const az = azDeg*rad;
    const alt = altDeg*rad;
    const up = Math.sin(alt);
    const proj = Math.cos(alt);
    const east = proj * Math.sin(az);
    const north = proj * Math.cos(az);
    return new THREE.Vector3(east, up, north);
  }

  // -----------------------------
  // State
  // -----------------------------
  const state = {
    lat: 35.681236,
    lon: 139.767125,
    tzMin: 540,
    playing: false,
    speed: 60,
    showMoon: true,
    showLabels: true,
    showPin: true,
    showPaths: true,
    scaleMode: 0,
    baseLocalDate: new Date(),
    localSeconds: 12*3600,
  };

  // -----------------------------
  // Time handling
  // -----------------------------

function tzDeltaMs(d, tzMin){
  // JSã®getTimezoneOffsetã¯ã€ŒUTC - local(åˆ†)ã€ãªã®ã§ç¬¦å·ã‚’åè»¢ã—ã¦ã€Œlocalã®UTCã‚ªãƒ•ã‚»ãƒƒãƒˆ(åˆ†)ã€ã¸
  const sysMin = -d.getTimezoneOffset();   // ä¾‹: JSTãªã‚‰ +540
  return (tzMin - sysMin) * 60000;         // ç«¯æœ«TZã¨ã®å·®åˆ†ã ã‘
}


  function getLocalDateTime(){
    const d = new Date(state.baseLocalDate);
    d.setHours(0,0,0,0);
    return new Date(d.getTime() + state.localSeconds*1000);
  }
 function getDateUTCFromLocalBasis(localDateTime){
   return new Date(localDateTime.getTime() - tzDeltaMs(localDateTime, state.tzMin));
 }
  function setFromDateTimeLocalInput(dtLocal){
    const y = dtLocal.getFullYear(), m=dtLocal.getMonth(), d=dtLocal.getDate();
    state.baseLocalDate = new Date(y,m,d,0,0,0,0);
    state.localSeconds = dtLocal.getHours()*3600 + dtLocal.getMinutes()*60 + dtLocal.getSeconds();
    $("#timeSlider").value = String(Math.round(state.localSeconds));
  }
  function updateDateTimeInput(){
    const dt = getLocalDateTime();
    const v = `${dt.getFullYear()}-${pad2(dt.getMonth()+1)}-${pad2(dt.getDate())}T${pad2(dt.getHours())}:${pad2(dt.getMinutes())}`;
    $("#dt").value = v;
  }

  // -----------------------------
  // 3D: System scene
  // -----------------------------
  const sysCanvas = $("#sys");
  const sysRenderer = new THREE.WebGLRenderer({ canvas: sysCanvas, antialias: true, alpha: true });
  sysRenderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  sysRenderer.outputColorSpace = THREE.SRGBColorSpace;

  const sysScene = new THREE.Scene();
  sysScene.fog = new THREE.Fog(0x060812, 8, 50);

  const sysCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 200);
  sysCamera.position.set(9.5, 5.2, 10.5);

  const sysControls = new OrbitLite(sysCamera, sysCanvas, {
    enablePan:true,
    enableDamping:true,
    dampingFactor:0.07,
    minDistance: 2.5,
    maxDistance: 60,
    maxPolarAngle: Math.PI*0.98
  });
  sysControls.target.set(0,0,0);

  // starfield
  const starGeo = new THREE.BufferGeometry();
  const starCount = 2000;
  const starPos = new Float32Array(starCount*3);
  for(let i=0;i<starCount;i++){
    const r = 70*Math.cbrt(Math.random());
    const th = Math.random()*2*Math.PI;
    const u = Math.random()*2-1;
    const s = Math.sqrt(1-u*u);
    starPos[i*3+0] = r*s*Math.cos(th);
    starPos[i*3+1] = r*u;
    starPos[i*3+2] = r*s*Math.sin(th);
  }
  starGeo.setAttribute("position", new THREE.BufferAttribute(starPos,3));
  const starMat = new THREE.PointsMaterial({ color: 0x9db6ff, size: 0.03, transparent:true, opacity:0.75 });
  const stars = new THREE.Points(starGeo, starMat);
  sysScene.add(stars);

  // Sun
  const sunGroup = new THREE.Group();
  sysScene.add(sunGroup);

  const sunGeom = new THREE.SphereGeometry(1.15, 48, 48);
  const sunMat = new THREE.MeshBasicMaterial({ color: 0xffd66b });
  const sun = new THREE.Mesh(sunGeom, sunMat);
  sunGroup.add(sun);

  const sunGlowGeom = new THREE.SphereGeometry(1.8, 48, 48);
  const sunGlowMat = new THREE.MeshBasicMaterial({ color: 0xffb84d, transparent:true, opacity:0.16 });
  const sunGlow = new THREE.Mesh(sunGlowGeom, sunGlowMat);
  sunGroup.add(sunGlow);

  const sunLight = new THREE.PointLight(0xffffff, 3.2, 120, 2);
  sunLight.position.set(0,0,0);
  sysScene.add(sunLight);

  const amb = new THREE.AmbientLight(0x3550aa, 0.18);
  sysScene.add(amb);

  function makeOrbit(radius, color=0x6f7fff, opacity=0.22){
    const seg = 256;
    const pts = [];
    for(let i=0;i<=seg;i++){
      const t = i/seg * Math.PI*2;
      pts.push(new THREE.Vector3(Math.cos(t)*radius, 0, Math.sin(t)*radius));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity });
    return new THREE.Line(geo, mat);
  }

  const earthOrbitR = 7.2;
  const moonOrbitR  = 1.6;

  const earthOrbit = makeOrbit(earthOrbitR, 0x66a6ff, 0.18);
  sysScene.add(earthOrbit);

  const earthGroup = new THREE.Group();
  sysScene.add(earthGroup);

  function makeEarthTexture(){
    const c = document.createElement("canvas");
    c.width = 512; c.height = 256;
    const ctx = c.getContext("2d");
    const grad = ctx.createLinearGradient(0,0,0,c.height);
    grad.addColorStop(0, "#0a1b3e");
    grad.addColorStop(0.55, "#0d3f88");
    grad.addColorStop(1, "#06305e");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,c.width,c.height);

    for(let i=0;i<9000;i++){
      const x = Math.random()*c.width;
      const y = Math.random()*c.height;
      const n = Math.random();
      if(n < 0.22){
        ctx.fillStyle = `rgba(${40+Math.random()*40|0}, ${140+Math.random()*60|0}, ${60+Math.random()*30|0}, ${0.35+Math.random()*0.35})`;
        ctx.beginPath();
        ctx.arc(x,y, 0.8+Math.random()*2.4, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.fillStyle = "rgba(245,250,255,0.55)";
    ctx.fillRect(0,0,c.width,18);
    ctx.fillRect(0,c.height-18,c.width,18);

    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    return tex;
  }

  const earthGeom = new THREE.SphereGeometry(0.55, 48, 48);
  const earthMat = new THREE.MeshStandardMaterial({
    map: makeEarthTexture(),
    metalness: 0.05,
    roughness: 0.85,
    emissive: new THREE.Color(0x000b1a),
    emissiveIntensity: 0.25
  });
  const earth = new THREE.Mesh(earthGeom, earthMat);
  earthGroup.add(earth);

  const nightMat = new THREE.MeshBasicMaterial({ color: 0x7aa0ff, transparent:true, opacity:0.10 });
  const nightSphere = new THREE.Mesh(new THREE.SphereGeometry(0.555, 48, 48), nightMat);
  earthGroup.add(nightSphere);

  const atmoMat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent:true, opacity:0.08 });
  const atmo = new THREE.Mesh(new THREE.SphereGeometry(0.595, 48, 48), atmoMat);
  earthGroup.add(atmo);

  const earthTilt = new THREE.Group();
  earthTilt.rotation.z = 23.44*rad;
  earthTilt.add(earthGroup);

  const earthOrbitPivot = new THREE.Group();
  earthOrbitPivot.add(earthTilt);
  sysScene.add(earthOrbitPivot);

  const moonGeom = new THREE.SphereGeometry(0.16, 32, 32);
  const moonMat = new THREE.MeshStandardMaterial({ color: 0xdbe6ff, roughness: 0.95, metalness: 0.0 });
  const moon = new THREE.Mesh(moonGeom, moonMat);

  const moonPivot = new THREE.Group();
  moonPivot.add(moon);
  earthGroup.add(moonPivot);

  const moonOrbit = makeOrbit(moonOrbitR, 0x9fb8ff, 0.24);
  earthGroup.add(moonOrbit);

  const pin = new THREE.Mesh(
    new THREE.ConeGeometry(0.06, 0.22, 12),
    new THREE.MeshStandardMaterial({ color: 0x2ee59d, metalness:0.15, roughness:0.35 })
  );
  pin.position.set(0,0.7,0);
  earthGroup.add(pin);

  function roundRect(ctx,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function makeLabel(text, color="#EAF1FF"){
    const c = document.createElement("canvas");
    c.width = 256; c.height = 80;
    const ctx = c.getContext("2d");
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    roundRect(ctx, 8, 10, 240, 60, 14); ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 2;
    roundRect(ctx, 8, 10, 240, 60, 14); ctx.stroke();
    ctx.fillStyle = color;
    ctx.font = "700 26px system-ui, -apple-system, Segoe UI, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, 128, 40);
    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, opacity:0.95 });
    const spr = new THREE.Sprite(mat);
    spr.scale.set(2.2, 0.7, 1);
    return spr;
  }

  const lblSun = makeLabel("SUN", "#FFD66B");
  const lblEarth = makeLabel("EARTH", "#9AE6FF");
  const lblMoon = makeLabel("MOON", "#CFE2FF");
  sysScene.add(lblSun, lblEarth, lblMoon);

  // -----------------------------
  // 3D: Sky scene
  // -----------------------------
  const skyCanvas = $("#sky");
  const skyRenderer = new THREE.WebGLRenderer({ canvas: skyCanvas, antialias:true, alpha:true });
  skyRenderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  skyRenderer.outputColorSpace = THREE.SRGBColorSpace;

  const skyScene = new THREE.Scene();
  const skyCamera = new THREE.PerspectiveCamera(55, 1, 0.01, 200);
  skyCamera.position.set(0, 0.45, 1.65);

  const skyControls = new OrbitLite(skyCamera, skyCanvas, {
    enablePan:false,
    enableDamping:true,
    dampingFactor:0.08,
    minDistance:0.9,
    maxDistance:3.2,
    maxPolarAngle: Math.PI*0.52
  });
  skyControls.target.set(0, 0.25, 0);

  const domeGeom = new THREE.SphereGeometry(50, 48, 48);
  const domeMat = new THREE.MeshBasicMaterial({ side: THREE.BackSide, transparent:true, opacity: 1.0, color: 0x0b1535 });
  const dome = new THREE.Mesh(domeGeom, domeMat);
  skyScene.add(dome);

  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(3.0, 64),
    new THREE.MeshBasicMaterial({ color: 0x050712, transparent:true, opacity:0.65 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.001;
  skyScene.add(ground);

  const horizon = new THREE.Mesh(
    new THREE.RingGeometry(2.92, 3.0, 128),
    new THREE.MeshBasicMaterial({ color: 0x3a4a88, transparent:true, opacity:0.28, side: THREE.DoubleSide })
  );
  horizon.rotation.x = -Math.PI/2;
  skyScene.add(horizon);

  function makeCardinal(text){
    const s = makeLabel(text, "#EAF1FF");
    s.scale.set(1.6,0.55,1);
    return s;
  }
  const N = makeCardinal("N"), E = makeCardinal("E"), S = makeCardinal("S"), W = makeCardinal("W");
  skyScene.add(N,E,S,W);
  function placeCardinals(){
    const r = 2.45;
    N.position.set(0, 0.07, r);
    S.position.set(0, 0.07, -r);
    E.position.set(r, 0.07, 0);
    W.position.set(-r,0.07, 0);
  }
  placeCardinals();

  const sunSky = new THREE.Mesh(
    new THREE.SphereGeometry(0.045, 18, 18),
    new THREE.MeshBasicMaterial({ color: 0xffd66b, transparent:true, opacity:1 })
  );
  const moonSky = new THREE.Mesh(
    new THREE.SphereGeometry(0.035, 18, 18),
    new THREE.MeshBasicMaterial({ color: 0xdbe6ff, transparent:true, opacity:1 })
  );
  skyScene.add(sunSky, moonSky);
  sunSky.material.depthTest = false;
  moonSky.material.depthTest = false;
  sunSky.renderOrder = 10;
  moonSky.renderOrder = 10;

  const skyLight = new THREE.DirectionalLight(0xffffff, 0.9);
  skyLight.position.set(0.6, 1.0, 0.4);
  skyScene.add(skyLight);

  let sunPathLine = null, moonPathLine = null;
  function buildPathLine(points, color, opacity){
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity });
    return new THREE.Line(geo, mat);
  }

  // -----------------------------
  // Layout resize
  // -----------------------------
  function resize(){
    const wrap1 = sysCanvas.parentElement;
    const wrap2 = skyCanvas.parentElement;

    const r1 = wrap1.getBoundingClientRect();
    const w1 = Math.max(1, Math.floor(r1.width));
    const h1 = Math.max(260, Math.floor(r1.height) || 260);
    sysRenderer.setSize(w1, h1, false);
    sysCamera.aspect = w1 / h1;
    sysCamera.updateProjectionMatrix();

    const r2 = wrap2.getBoundingClientRect();
    const w2 = Math.max(1, Math.floor(r2.width));
    const h2 = Math.max(260, Math.floor(r2.height) || 260);
    skyRenderer.setSize(w2, h2, false);
    skyCamera.aspect = w2 / h2;
    skyCamera.updateProjectionMatrix();
  }
  window.addEventListener("resize", resize);

  // -----------------------------
  // Core update
  // -----------------------------
  function lerp(a,b,t){ return a + (b-a)*t; }
  function earthRotationAngle(dateUTC){
    const ms = dateUTC.getTime();
    const day = (ms / dayMs);
    const frac = day - Math.floor(day);
    return frac * Math.PI*2;
  }
  function latLonToSphere(latDeg, lonDeg, radius, earthRot){
    const lat = latDeg*rad, lon = lonDeg*rad;
    const x = radius * Math.cos(lat) * Math.cos(lon);
    const z = radius * Math.cos(lat) * Math.sin(lon);
    const y = radius * Math.sin(lat);
    const v = new THREE.Vector3(x,y,z);
    const rot = new THREE.Matrix4().makeRotationY(earthRot);
    v.applyMatrix4(rot);
    return v;
  }

  function updateAll(){
    const localDT = getLocalDateTime();
    const utcDT = getDateUTCFromLocalBasis(localDT);

    const sunPos = getSunPosition(utcDT, state.lat, state.lon);
    const moonPos = getMoonPosition(utcDT, state.lat, state.lon);

    const showLocal = new Date(localDT.getTime());
    $("#kNow").textContent =
      `${showLocal.getFullYear()}/${pad2(showLocal.getMonth()+1)}/${pad2(showLocal.getDate())} ${pad2(showLocal.getHours())}:${pad2(showLocal.getMinutes())}:${pad2(showLocal.getSeconds())}`;

    const sunTxt = `Sun: alt ${sunPos.alt.toFixed(1)}Â° / az ${sunPos.az.toFixed(0)}Â°`;
    const moonTxt = `Moon: alt ${moonPos.alt.toFixed(1)}Â° / az ${moonPos.az.toFixed(0)}Â°`;
    $("#barMid").textContent = `${sunTxt}   â€¢   ${moonTxt}`;

    const day0 = new Date(state.baseLocalDate);
    day0.setHours(0,0,0,0);
    const sunTimes = getSunTimes(day0, state.lat, state.lon, state.tzMin);
    const sunriseLocal = new Date(sunTimes.sunriseUTC.getTime() + state.tzMin*60000);
    const sunsetLocal  = new Date(sunTimes.sunsetUTC.getTime()  + state.tzMin*60000);
    $("#kSunTimes").textContent = `ğŸŒ… ${fmtTimeHM(sunriseLocal)}  /  ğŸŒ‡ ${fmtTimeHM(sunsetLocal)}`;

    const moonTimes = getMoonTimes(day0, state.lat, state.lon, state.tzMin);
    const mr = moonTimes.moonriseUTC ? new Date(moonTimes.moonriseUTC.getTime() + state.tzMin*60000) : null;
    const ms = moonTimes.moonsetUTC  ? new Date(moonTimes.moonsetUTC.getTime()  + state.tzMin*60000) : null;
    $("#kMoonTimes").textContent = `ğŸŒ™â†‘ ${mr ? fmtTimeHM(mr) : "â€”"}  /  ğŸŒ™â†“ ${ms ? fmtTimeHM(ms) : "â€”"}`;

    const nowSec = state.localSeconds;
    const riseSec = sunriseLocal.getHours()*3600 + sunriseLocal.getMinutes()*60 + sunriseLocal.getSeconds();
    const setSec  = sunsetLocal.getHours()*3600  + sunsetLocal.getMinutes()*60  + sunsetLocal.getSeconds();
    const dayFrac = (nowSec - riseSec) / Math.max(1, (setSec - riseSec));
    const w = clamp(dayFrac, 0, 1)*100;
    $("#dayBar").style.width = `${w}%`;
    $("#barLeft").textContent = (nowSec < riseSec || nowSec > setSec) ? "Night (now)" : "Night";
    $("#barRight").textContent = (nowSec >= riseSec && nowSec <= setSec) ? "Day (now)" : "Day";

    const earthRot = earthRotationAngle(utcDT);
    const pinPos = latLonToSphere(state.lat, state.lon, 0.58, earthRot);
    pin.position.copy(pinPos);
    pin.visible = state.showPin;

    const d = toDays(utcDT);
    const earthRev = (d / 365.25) * Math.PI*2;
    const moonRev  = (d / 27.321582) * Math.PI*2;

    const orbitR = (state.scaleMode===0) ? earthOrbitR : 5.5;
    earthOrbit.scale.set(orbitR/earthOrbitR,1,orbitR/earthOrbitR);
    earthOrbitPivot.position.set(Math.cos(earthRev)*orbitR, 0, Math.sin(earthRev)*orbitR);

    earthGroup.rotation.y = earthRot;

    const mR = (state.scaleMode===0) ? moonOrbitR : 1.25;
    moonOrbit.scale.set(mR/moonOrbitR,1,mR/moonOrbitR);
    moonPivot.position.set(Math.cos(moonRev)*mR, 0.12*Math.sin(moonRev*0.7), Math.sin(moonRev)*mR);

    moon.visible = state.showMoon;
    moonOrbit.visible = state.showMoon;

    lblSun.position.set(0, 2.2, 0);
    lblEarth.position.copy(earthOrbitPivot.position).add(new THREE.Vector3(0,1.0,0));
    lblMoon.position.copy(earthOrbitPivot.position).add(moonPivot.position).add(new THREE.Vector3(0,0.55,0));
    lblSun.visible = lblEarth.visible = (state.showLabels);
    lblMoon.visible = (state.showLabels && state.showMoon);

    const earthToSun = new THREE.Vector3().subVectors(sunGroup.position, earthOrbitPivot.position).normalize();
    const pinDir = new THREE.Vector3().copy(pinPos).normalize();
    const illum = clamp((pinDir.dot(earthToSun)+1)/2, 0, 1);
    nightSphere.material.opacity = 0.16 * (1-illum);

    const sunENU = azAltToENU(sunPos.az, sunPos.alt);
    const moonENU = azAltToENU(moonPos.az, moonPos.alt);
    const skyR = 2.35;
    sunSky.position.set(sunENU.x*skyR, sunENU.y*skyR, sunENU.z*skyR);
    moonSky.position.set(moonENU.x*skyR, moonENU.y*skyR, moonENU.z*skyR);

    const SUN_MIN_Y = 0.03, MOON_MIN_Y = 0.03;
    sunSky.material.opacity = (sunPos.alt >= 0) ? 1.0 : 0.18;
    moonSky.material.opacity = (moonPos.alt >= 0) ? 1.0 : 0.18;
    sunSky.position.y = Math.max(sunSky.position.y, SUN_MIN_Y);
    moonSky.position.y = Math.max(moonSky.position.y, MOON_MIN_Y);
    moonSky.visible = state.showMoon;

    const sAlt = sunPos.alt;
    const tt = clamp((sAlt+8)/38, 0, 1);
    dome.material.color.setRGB(lerp(0.03, 0.10, tt), lerp(0.06, 0.20, tt), lerp(0.14, 0.55, tt));
    dome.material.opacity = 0.98;

    if(state.showPaths){
      const sunPts = [];
      const moonPts = [];
      const stepSun = 8*60;
      for(let sec = riseSec; sec <= setSec; sec += stepSun){
        const lt = new Date(day0.getTime() + sec*1000);
        const ut = getDateUTCFromLocalBasis(lt);
        const sp = getSunPosition(ut, state.lat, state.lon);
        const v = azAltToENU(sp.az, sp.alt);
        sunPts.push(new THREE.Vector3(v.x*skyR, v.y*skyR, v.z*skyR));
      }
      for(let sec=0; sec<=86400; sec += 12*60){
        const lt = new Date(day0.getTime() + sec*1000);
        const ut = getDateUTCFromLocalBasis(lt);
        const mp = getMoonPosition(ut, state.lat, state.lon);
        const v = azAltToENU(mp.az, mp.alt);
        moonPts.push(new THREE.Vector3(v.x*skyR, v.y*skyR, v.z*skyR));
      }

      if(sunPathLine) skyScene.remove(sunPathLine);
      if(moonPathLine) skyScene.remove(moonPathLine);
      sunPathLine = buildPathLine(sunPts, 0xffd66b, 0.55);
      moonPathLine = buildPathLine(moonPts, 0xcfe2ff, 0.32);
      skyScene.add(sunPathLine);
      if(state.showMoon) skyScene.add(moonPathLine);
    }else{
      if(sunPathLine){ skyScene.remove(sunPathLine); sunPathLine=null; }
      if(moonPathLine){ skyScene.remove(moonPathLine); moonPathLine=null; }
    }

    const showCardinals = state.showLabels;
    N.visible = E.visible = S.visible = W.visible = showCardinals;
  }

  // -----------------------------
  // Animation loop
  // -----------------------------
  let last = performance.now();
  function tick(now){
    const dt = (now - last)/1000;
    last = now;

    if(state.playing){
      state.localSeconds += dt * state.speed;
      while(state.localSeconds < 0) state.localSeconds += 86400;
      while(state.localSeconds >= 86400) state.localSeconds -= 86400;
      $("#timeSlider").value = String(Math.round(state.localSeconds));
      updateDateTimeInput();
    }

    updateAll();
    sysControls.update();
    skyControls.update();

    sysRenderer.render(sysScene, sysCamera);
    skyRenderer.render(skyScene, skyCamera);

    requestAnimationFrame(tick);
  }

  // -----------------------------
  // URL hash
  // -----------------------------
  function pushHash(){
    const dt = getLocalDateTime();
    const y = dt.getFullYear(), m = dt.getMonth()+1, d = dt.getDate();
    const sec = Math.round(state.localSeconds);
    const p = new URLSearchParams();
    p.set("lat", state.lat.toFixed(6));
    p.set("lon", state.lon.toFixed(6));
    p.set("tz", String(state.tzMin));
    p.set("date", `${y}-${pad2(m)}-${pad2(d)}`);
    p.set("sec", String(sec));
    p.set("moon", state.showMoon ? "1":"0");
    p.set("lbl", state.showLabels ? "1":"0");
    p.set("pin", state.showPin ? "1":"0");
    p.set("path", state.showPaths ? "1":"0");
    p.set("sc", String(state.scaleMode));
    history.replaceState(null,"","#" + p.toString());
  }
  function loadHash(){
    if(!location.hash || location.hash.length < 2) return;
    const p = new URLSearchParams(location.hash.slice(1));
    const lat = Number(p.get("lat"));
    const lon = Number(p.get("lon"));
    const tz  = Number(p.get("tz"));
    const dateStr = p.get("date");
    const sec = Number(p.get("sec"));
    if(Number.isFinite(lat)) state.lat = clamp(lat, -89.9999, 89.9999);
    if(Number.isFinite(lon)) state.lon = ((lon+540)%360)-180;
    if(Number.isFinite(tz)) state.tzMin = tz;
    if(dateStr){
      const [Y,M,D] = dateStr.split("-").map(Number);
      if(Number.isFinite(Y) && Number.isFinite(M) && Number.isFinite(D)){
        state.baseLocalDate = new Date(Y, M-1, D, 0,0,0,0);
      }
    }
    if(Number.isFinite(sec)) state.localSeconds = clamp(sec, 0, 86399);

    state.showMoon = (p.get("moon") ?? "1") === "1";
    state.showLabels = (p.get("lbl") ?? "1") === "1";
    state.showPin = (p.get("pin") ?? "1") === "1";
    state.showPaths = (p.get("path") ?? "1") === "1";
    state.scaleMode = Number(p.get("sc") ?? "0") || 0;
  }

  // -----------------------------
  // UI wiring
  // -----------------------------
  function initUI(){
    loadHash();

    const now = new Date();
    if(!location.hash){
      state.baseLocalDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0,0);
      state.localSeconds = now.getHours()*3600 + now.getMinutes()*60 + now.getSeconds();
    }

    $("#timeSlider").value = String(Math.round(state.localSeconds));
    updateDateTimeInput();

    $("#lat").value = state.lat.toFixed(6);
    $("#lon").value = state.lon.toFixed(6);
    $("#tz").value = String(state.tzMin);

    $("#btnMoon").textContent = `æœˆã‚’è¡¨ç¤º: ${state.showMoon ? "ON" : "OFF"}`;
    $("#btnLabels").textContent = `ãƒ©ãƒ™ãƒ«: ${state.showLabels ? "ON" : "OFF"}`;
    $("#btnPin").textContent = `åœ°çƒãƒ”ãƒ³: ${state.showPin ? "ON" : "OFF"}`;

    $("#place").addEventListener("change", () => {
      const [la, lo] = $("#place").value.split(",").map(Number);
      state.lat = la; state.lon = lo;
      $("#lat").value = state.lat.toFixed(6);
      $("#lon").value = state.lon.toFixed(6);
      pushHash();
      toast("åœ°ç‚¹ã‚’æ›´æ–°ã—ã¾ã—ãŸ");
    });

    $("#btnApplyLL").addEventListener("click", () => {
      const la = Number($("#lat").value);
      const lo = Number($("#lon").value);
      if(!Number.isFinite(la) || !Number.isFinite(lo)) return toast("ç·¯åº¦çµŒåº¦ã‚’ç¢ºèªã—ã¦ãã ã•ã„");
      state.lat = clamp(la, -89.9999, 89.9999);
      state.lon = ((lo+540)%360)-180;
      $("#lat").value = state.lat.toFixed(6);
      $("#lon").value = state.lon.toFixed(6);
      pushHash();
      toast("ç·¯åº¦çµŒåº¦ã‚’é©ç”¨ã—ã¾ã—ãŸ");
    });

    $("#btnTokyo").addEventListener("click", () => {
      state.lat = 35.681236; state.lon = 139.767125;
      $("#lat").value = state.lat.toFixed(6);
      $("#lon").value = state.lon.toFixed(6);
      $("#place").value = "35.681236,139.767125";
      pushHash();
      toast("æ±äº¬ã«æˆ»ã—ã¾ã—ãŸ");
    });

    $("#tz").addEventListener("change", () => {
      state.tzMin = Number($("#tz").value);
      pushHash();
      toast("ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã‚’æ›´æ–°ã—ã¾ã—ãŸ");
    });

    $("#timeSlider").addEventListener("input", () => {
      state.localSeconds = Number($("#timeSlider").value);
      updateDateTimeInput();
      state.playing = false;
      $("#btnPlay").textContent = "â–¶";
    });

    $("#dt").addEventListener("change", () => {
      const v = $("#dt").value;
      if(!v) return;
      const dtLocal = new Date(v);
      setFromDateTimeLocalInput(dtLocal);
      state.playing = false;
      $("#btnPlay").textContent = "â–¶";
      pushHash();
    });

    $("#btnPlay").addEventListener("click", () => {
      state.playing = !state.playing;
      $("#btnPlay").textContent = state.playing ? "â¸" : "â–¶";
    });

    document.querySelectorAll(".speed").forEach(b=>{
      b.addEventListener("click", () => {
        state.speed = Number(b.dataset.mult);
        document.querySelectorAll(".speed").forEach(x=>x.classList.remove("btnPri"));
        b.classList.add("btnPri");
        toast(`é€Ÿåº¦ Ã—${state.speed}`);
      });
    });
    document.querySelectorAll(".speed").forEach(b=>{
      if(Number(b.dataset.mult) === state.speed) b.classList.add("btnPri");
    });

    $("#btnNow").addEventListener("click", () => {
      const now = new Date();
      state.baseLocalDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0,0);
      state.localSeconds = now.getHours()*3600 + now.getMinutes()*60 + now.getSeconds();
      $("#timeSlider").value = String(Math.round(state.localSeconds));
      updateDateTimeInput();
      pushHash();
      toast("ç¾åœ¨æ™‚åˆ»ã¸");
    });

    $("#btnMoon").addEventListener("click", () => {
      state.showMoon = !state.showMoon;
      $("#btnMoon").textContent = `æœˆã‚’è¡¨ç¤º: ${state.showMoon ? "ON" : "OFF"}`;
      pushHash();
    });

    $("#btnLabels").addEventListener("click", () => {
      state.showLabels = !state.showLabels;
      $("#btnLabels").textContent = `ãƒ©ãƒ™ãƒ«: ${state.showLabels ? "ON" : "OFF"}`;
      pushHash();
    });

    $("#btnPin").addEventListener("click", () => {
      state.showPin = !state.showPin;
      $("#btnPin").textContent = `åœ°çƒãƒ”ãƒ³: ${state.showPin ? "ON" : "OFF"}`;
      pushHash();
    });

    $("#btnTogglePaths").addEventListener("click", () => {
      state.showPaths = !state.showPaths;
      toast(`è»Œè·¡ ${state.showPaths ? "ON" : "OFF"}`);
      pushHash();
    });

    $("#btnSysReset").addEventListener("click", () => {
      sysControls.target.set(0,0,0);
      sysCamera.position.set(9.5, 5.2, 10.5);
      toast("Systemã‚«ãƒ¡ãƒ©ã‚’ãƒªã‚»ãƒƒãƒˆ");
    });

    $("#btnSkyReset").addEventListener("click", () => {
      skyControls.target.set(0, 0.25, 0);
      skyCamera.position.set(0, 0.45, 1.65);
      toast("Skyè¦–ç‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ");
    });

    $("#btnScale").addEventListener("click", () => {
      state.scaleMode = (state.scaleMode+1)%2;
      toast(`ã‚¹ã‚±ãƒ¼ãƒ«: ${state.scaleMode===0 ? "æ¨™æº–" : "ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆ"}`);
      pushHash();
    });

    $("#btnCopyLink").addEventListener("click", async () => {
      pushHash();
      try{
        await navigator.clipboard.writeText(location.href);
        toast("URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
      }catch(e){
        toast("ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã§ã—ãŸï¼ˆæ‰‹å‹•ã§URLã‚’å…±æœ‰ã—ã¦ãã ã•ã„ï¼‰");
      }
    });
  }

  // -----------------------------
  // Kick off
  // -----------------------------
  initUI();

  // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç¢ºå®šå¾Œã«ã‚‚ã†ä¸€å›ã‚µã‚¤ã‚ºã‚’åˆã‚ã›ã‚‹ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã¯ã‚„ã‚‰ãªã„ï¼‰
  resize();
  setTimeout(resize, 80);
  setTimeout(resize, 250);

  updateAll();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
