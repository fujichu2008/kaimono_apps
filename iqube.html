<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, viewport-fit=cover, user-scalable=no" />
<title>IQube</title>
<style>
:root{
  --bg:#050711;
  --bg2:#050b18;
  --card:#0f1525;
  --ink:#e8edf9;
  --muted:#a1acc7;
  --line:#252f49;
  --accent:#4da3ff;
  --accent-soft:#26385f;
  --danger:#ff4d6a;
  --forbid:#ff4d6a;
  --adv:#2fd07c;
  --normal:#5bc0ff;
  --safe:#a5ff7c;
}

*{box-sizing:border-box;margin:0;padding:0}
html,body{
  height:100%;
  background:radial-gradient(circle at top,#141b32 0,#050711 45%,#020308 100%);
  color:var(--ink);
  font-family:system-ui,-apple-system,"Hiragino Sans","Noto Sans JP",sans-serif;
  -webkit-user-select:none;
  user-select:none;
  -webkit-touch-callout:none;
}
body{
  display:flex;
  flex-direction:column;
}

/* ヘッダー */
header{
  padding:0.4rem 0.9rem 0.3rem;
  background:linear-gradient(to right,rgba(12,18,38,.96),rgba(5,10,26,.96));
  border-bottom:1px solid rgba(255,255,255,.05);
  box-shadow:0 8px 24px rgba(0,0,0,.7);
}
header h1{
  font-size:1.02rem;
  letter-spacing:0.08em;
  text-transform:uppercase;
  display:flex;
  align-items:center;
  gap:0.35rem;
}
header .logo{
  width:1rem;
  height:1rem;
  border-radius:999px;
  background:radial-gradient(circle at 30% 30%,#ffffff 0,#4da3ff 35%,#243867 75%,#050711 100%);
  box-shadow:0 0 10px rgba(77,163,255,.9);
}

/* メイン */
main{
  flex:1;
  display:flex;
  flex-direction:column;
  padding:0.4rem 0.7rem 0.7rem;
  gap:0.4rem;
  max-width:720px;
  margin:0 auto;
}

/* ステータスバー */
#status-bar{
  display:flex;
  flex-wrap:wrap;
  gap:0.28rem;
  font-size:0.7rem;
}
.status-chip{
  display:inline-flex;
  align-items:center;
  gap:0.25rem;
  padding:0.12rem 0.45rem;
  border-radius:999px;
  background:rgba(9,14,30,0.95);
  border:1px solid rgba(255,255,255,.06);
}
.status-label{
  color:var(--muted);
}
.status-value{
  font-variant-numeric:tabular-nums;
}

/* ボードラッパー */
#board-wrapper{
  flex:1;
  min-height:260px;
  max-height:480px;
  background:radial-gradient(circle at top,#18223c 0,#050a18 55%,#020308 100%);
  border-radius:18px;
  padding:0.55rem;
  box-shadow:
    0 16px 40px rgba(0,0,0,.85),
    0 0 0 1px rgba(255,255,255,.03);
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  touch-action:none;
}

/* ボード本体（真上2D） */
#board{
  width:100%;
  max-width:460px;
  aspect-ratio:1/1;
  display:grid;
  background:radial-gradient(circle at center,#11182b,#050814);
  border-radius:12px;
  padding:3px;
  gap:1px;
  box-shadow:inset 0 0 0 1px rgba(255,255,255,.03);
  touch-action:none;
}
.cell{
  position:relative;
  border-radius:6px;
  background:radial-gradient(circle at 30% 20%,rgba(255,255,255,.08),rgba(22,30,54,1));
  overflow:hidden;
}
.cell-inner{
  position:absolute;
  inset:1px;
  border-radius:5px;
  background:linear-gradient(135deg,rgba(255,255,255,.03),rgba(0,0,0,.4));
}

/* ブロック */
.block{
  position:absolute;
  inset:3px;
  border-radius:5px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:0.7rem;
  font-weight:600;
  letter-spacing:0.04em;
  text-transform:uppercase;
  color:#f7fbff;
  box-shadow:
    0 3px 6px rgba(0,0,0,.8),
    0 0 0 1px rgba(0,0,0,.35);
}
.block-normal{
  background:linear-gradient(135deg,var(--normal),#2a8bff);
}
.block-adv{
  background:linear-gradient(135deg,var(--adv),#159a52);
}
.block-forbid{
  background:linear-gradient(135deg,var(--forbid),#b01530);
}
.block-label{
  text-shadow:0 1px 2px rgba(0,0,0,.9);
}

/* 爆弾・安全地帯マーク */
.mark-bomb,
.mark-safe{
  position:absolute;
  inset:2px;
  border-radius:6px;
  pointer-events:none;
}
.mark-bomb{
  border:2px solid rgba(90,170,255,1);
  box-shadow:
    0 0 8px rgba(77,163,255,.9),
    0 0 14px rgba(77,163,255,.6);
}
.mark-safe{
  border:2px solid rgba(165,255,124,.9);
  box-shadow:
    0 0 8px rgba(165,255,124,.9),
    0 0 18px rgba(135,225,110,.6);
  background:radial-gradient(circle at center,rgba(165,255,124,.25),rgba(165,255,124,0));
}

/* クリック無効時の軽いフィードバック */
.cell-blocked-flash{
  animation:blockedFlash 0.22s ease-out;
}
@keyframes blockedFlash{
  0%{box-shadow:0 0 0 rgba(0,0,0,0);transform:scale(1);}
  40%{box-shadow:0 0 10px rgba(255,77,106,.9);transform:scale(1.02);}
  100%{box-shadow:0 0 0 rgba(0,0,0,0);transform:scale(1);}
}

/* 下部UI */
#bottom-ui{
  margin-top:0.4rem;
  display:flex;
  flex-direction:column;
  gap:0.25rem;
}
#controls{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:0.4rem;
}
#left-controls{
  display:flex;
  gap:0.25rem;
}
.btn{
  border-radius:999px;
  border:1px solid rgba(255,255,255,.18);
  padding:0.35rem 0.7rem;
  font-size:0.76rem;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:0.28rem;
  background:linear-gradient(to bottom,#151d35,#050914);
  color:var(--ink);
  box-shadow:0 6px 16px rgba(0,0,0,.85);
}
.btn-primary{
  background:linear-gradient(to bottom,#2c7eff,#1651c8);
}
.btn-ghost{
  background:linear-gradient(to bottom,#141c30,#060b19);
}
.btn-small{
  padding:0.25rem 0.55rem;
  font-size:0.7rem;
}

/* FIREボタン（右下固定） */
#btn-fire{
  position:fixed;
  right:0.9rem;
  bottom:3rem;
  z-index:30;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.28);
  padding:0.8rem 1.5rem;
  font-size:0.9rem;
  font-weight:700;
  letter-spacing:0.14em;
  text-transform:uppercase;
  background:
    radial-gradient(circle at 30% 20%,rgba(255,255,255,.28) 0,rgba(255,255,255,0) 55%),
    linear-gradient(135deg,#ff7482,#d21734);
  color:#fff8fa;
  box-shadow:
    0 18px 26px rgba(0,0,0,.9),
    0 0 18px rgba(255,116,130,.9);
}
#btn-fire:active{
  transform:translateY(1px);
  box-shadow:
    0 10px 18px rgba(0,0,0,.95),
    0 0 12px rgba(255,116,130,.85);
}
#btn-fire[disabled]{
  opacity:0.55;
  box-shadow:0 10px 18px rgba(0,0,0,.85);
}

/* ヒント */
#hint{
  font-size:0.68rem;
  color:var(--muted);
}

/* トーストメッセージ */
#toast{
  position:fixed;
  left:50%;
  bottom:1.2rem;
  transform:translateX(-50%);
  padding:0.3rem 0.7rem;
  border-radius:999px;
  background:rgba(10,16,32,0.96);
  border:1px solid rgba(255,255,255,.18);
  font-size:0.7rem;
  color:var(--ink);
  box-shadow:0 10px 22px rgba(0,0,0,.9);
  opacity:0;
  pointer-events:none;
  transition:opacity 0.18s ease-out, transform 0.18s ease-out;
  z-index:60;
}
#toast.visible{
  opacity:1;
  transform:translateX(-50%) translateY(-4px);
}

/* オーバーレイ（クリア／ゲームオーバー） */
#overlay{
  position:fixed;
  inset:0;
  background:radial-gradient(circle at top,rgba(26,34,70,.96),rgba(4,7,18,.98));
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:80;
}
#overlay.hidden{
  display:none;
}
.overlay-card{
  max-width:360px;
  margin:0 1rem;
  background:linear-gradient(to bottom,#10182b,#050712);
  border-radius:18px;
  border:1px solid rgba(255,255,255,.18);
  box-shadow:0 24px 40px rgba(0,0,0,.96);
  padding:1rem 1rem 0.85rem;
}
.overlay-title{
  font-size:1rem;
  margin-bottom:0.25rem;
}
.overlay-sub{
  font-size:0.78rem;
  color:var(--muted);
  margin-bottom:0.45rem;
}
.result-grid{
  font-size:0.78rem;
  margin-bottom:0.6rem;
}
.result-row{
  display:flex;
  justify-content:space-between;
  margin-bottom:0.18rem;
}
.result-label{
  color:var(--muted);
}
.result-value{
  font-variant-numeric:tabular-nums;
}
.overlay-buttons{
  display:flex;
  gap:0.35rem;
  margin-top:0.15rem;
}

/* フッター */
footer{
  padding:0.25rem 0.8rem 0.35rem;
  font-size:0.66rem;
  color:var(--muted);
  border-top:1px solid rgba(255,255,255,.04);
  background:linear-gradient(to right,rgba(5,7,18,.96),rgba(4,8,20,.96));
}

/* 幅広レイアウト調整 */
@media (min-width:720px){
  #btn-fire{
    right:1.5rem;
    bottom:3rem;
  }
}
</style>
</head>
<body>
<header>
  <h1><span class="logo"></span>IQube</h1>
</header>

<main>
  <!-- ステータス -->
  <div id="status-bar">
    <div class="status-chip">
      <span class="status-label">LEVEL</span>
      <span class="status-value" id="status-level">1 / 10</span>
    </div>
    <div class="status-chip">
      <span class="status-label">GRID</span>
      <span class="status-value" id="status-grid">6×6</span>
    </div>
    <div class="status-chip">
      <span class="status-label">SCORE</span>
      <span class="status-value" id="status-score">0</span>
    </div>
    <div class="status-chip">
      <span class="status-label">FORBID</span>
      <span class="status-value" id="status-forbid">0 / 3</span>
    </div>
    <div class="status-chip">
      <span class="status-label">崩落</span>
      <span class="status-value" id="status-collapse">0 / 5</span>
    </div>
    <div class="status-chip">
      <span class="status-label">BOMBS</span>
      <span class="status-value" id="status-bombs">0 / 4</span>
    </div>
    <div class="status-chip">
      <span class="status-label">WAVES</span>
      <span class="status-value" id="status-waves">0 / 0</span>
    </div>
  </div>

  <!-- ボード -->
  <div id="board-wrapper">
    <div id="board" aria-label="IQube ボード"></div>
  </div>

  <!-- 下部UI -->
  <div id="bottom-ui">
    <div id="controls">
      <div id="left-controls">
        <button class="btn btn-primary btn-small" id="btn-start">▶ START</button>
        <button class="btn btn-ghost btn-small" id="btn-restart">↻ RESTART</button>
      </div>
      <button class="btn btn-ghost btn-small" id="btn-level-up">LEVEL ➕</button>
    </div>
    <div id="hint">
      セルをタップ：爆弾→安全地帯→解除（ループ）。爆弾は同時に4つまで。FIREで起爆。緑は3×3爆破、安全地帯セルは守られる。
    </div>
  </div>
</main>

<footer>
  BGMは最初にSTARTを押すと再生されます（iPhone対応）。
</footer>

<!-- FIREボタン -->
<button id="btn-fire">FIRE</button>

<!-- トースト -->
<div id="toast"></div>

<!-- 結果オーバーレイ -->
<div id="overlay" class="hidden" aria-modal="true" role="dialog">
  <div class="overlay-card">
    <div class="overlay-title" id="overlay-title">Stage Clear!</div>
    <div class="overlay-sub" id="overlay-sub">結果</div>
    <div class="result-grid">
      <div class="result-row">
        <span class="result-label">LEVEL</span>
        <span class="result-value" id="overlay-level">1 / 10</span>
      </div>
      <div class="result-row">
        <span class="result-label">SCORE</span>
        <span class="result-value" id="overlay-score">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">FORBID 破壊</span>
        <span class="result-value" id="overlay-forbid">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">崩落回数</span>
        <span class="result-value" id="overlay-collapse">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">通常ブロック破壊</span>
        <span class="result-value" id="overlay-hit-normal">0</span>
      </div>
      <div class="result-row">
        <span class="result-label">緑ブロック破壊</span>
        <span class="result-value" id="overlay-hit-adv">0</span>
      </div>
    </div>
    <div class="overlay-buttons">
      <button class="btn btn-primary" id="overlay-next">▶ NEXT</button>
      <button class="btn btn-ghost" id="overlay-retry">↻ RETRY</button>
    </div>
  </div>
</div>

<script>
// =====================
//   定数・ステージ設定
// =====================
const TYPE_NONE   = 0;
const TYPE_NORMAL = 1;
const TYPE_ADV    = 2;
const TYPE_FORBID = 3;

const MARK_NONE = 0;
const MARK_BOMB = 1;
const MARK_SAFE = 2;

const STAGES = [
  {rows:6, cols:6, tickMs:2300, waves:10, minBlocks:2, maxBlocks:4, ratioN:0.80, ratioG:0.15, ratioF:0.05, forbidLimit:3, collapseLimit:5},
  {rows:6, cols:6, tickMs:2100, waves:11, minBlocks:3, maxBlocks:4, ratioN:0.78, ratioG:0.15, ratioF:0.07, forbidLimit:3, collapseLimit:5},
  {rows:6, cols:6, tickMs:1900, waves:12, minBlocks:3, maxBlocks:5, ratioN:0.75, ratioG:0.18, ratioF:0.07, forbidLimit:3, collapseLimit:4},
  {rows:7, cols:7, tickMs:1900, waves:13, minBlocks:3, maxBlocks:5, ratioN:0.72, ratioG:0.20, ratioF:0.08, forbidLimit:3, collapseLimit:4},
  {rows:7, cols:7, tickMs:1700, waves:14, minBlocks:4, maxBlocks:6, ratioN:0.70, ratioG:0.20, ratioF:0.10, forbidLimit:3, collapseLimit:3},
  {rows:7, cols:7, tickMs:1600, waves:15, minBlocks:4, maxBlocks:6, ratioN:0.68, ratioG:0.22, ratioF:0.10, forbidLimit:3, collapseLimit:3},
  {rows:8, cols:8, tickMs:1600, waves:16, minBlocks:4, maxBlocks:7, ratioN:0.66, ratioG:0.22, ratioF:0.12, forbidLimit:2, collapseLimit:3},
  {rows:8, cols:8, tickMs:1500, waves:17, minBlocks:5, maxBlocks:7, ratioN:0.64, ratioG:0.24, ratioF:0.12, forbidLimit:2, collapseLimit:3},
  {rows:8, cols:8, tickMs:1400, waves:18, minBlocks:5, maxBlocks:8, ratioN:0.62, ratioG:0.24, ratioF:0.14, forbidLimit:2, collapseLimit:2},
  {rows:8, cols:8, tickMs:1300, waves:20, minBlocks:5, maxBlocks:8, ratioN:0.60, ratioG:0.25, ratioF:0.15, forbidLimit:2, collapseLimit:2},
];

// =====================
//   BGM 設定（ステージ別）
//   ※すべてオリジナル旋律
// =====================
// スケールは「切なめ長調」寄り（#4など少し混ぜる）
const STAGE_BGM = [
  {
    root:220.00, // A
    tempo:72,
    patternLen:16,
    chords:[[0,7,11],[-3,4,9],[-5,2,9],[0,7,12]],
    melody:[0,2,4,7,9,7,5,4,2,0,2,4,5,7,9,7],
    counter:[-5,-3,-2,0,2,0,-2,-3,-5,-3,-2,0,2,4,2,0]
  },
  {
    root:233.08, // A#
    tempo:76,
    patternLen:16,
    chords:[[0,7,10],[-2,5,9],[-5,2,7],[0,7,12]],
    melody:[0,2,3,7,10,8,7,5,3,2,3,5,7,8,10,8],
    counter:[-5,-3,-1,0,2,0,-1,-3,-5,-3,-1,0,2,3,2,0]
  },
  {
    root:246.94, // B
    tempo:78,
    patternLen:16,
    chords:[[0,7,11],[-4,3,8],[-5,2,9],[0,7,12]],
    melody:[0,2,4,7,11,9,7,4,2,0,2,4,7,9,11,9],
    counter:[-5,-3,-2,0,2,0,-2,-3,-5,-3,-2,0,2,4,2,0]
  },
  {
    root:261.63, // C
    tempo:80,
    patternLen:16,
    chords:[[0,7,11],[-3,4,9],[-5,2,9],[0,7,12]],
    melody:[0,2,5,7,9,10,9,7,5,2,0,2,4,5,7,9],
    counter:[-5,-3,-1,0,2,3,2,0,-1,-3,-5,-3,-1,0,2,3]
  },
  {
    root:277.18, // C#
    tempo:82,
    patternLen:16,
    chords:[[0,7,11],[-4,3,8],[-6,1,8],[0,7,12]],
    melody:[0,2,4,7,11,13,11,9,7,4,2,0,2,4,7,9],
    counter:[-5,-3,-2,0,2,4,2,0,-2,-3,-5,-3,-2,0,2,4]
  },
  {
    root:293.66, // D
    tempo:84,
    patternLen:16,
    chords:[[0,7,11],[-3,4,9],[-5,2,9],[0,7,12]],
    melody:[0,2,5,7,9,11,9,7,5,2,0,2,4,7,9,11],
    counter:[-5,-3,-1,0,2,4,2,0,-1,-3,-5,-3,-1,0,2,4]
  },
  {
    root:311.13, // D#
    tempo:86,
    patternLen:16,
    chords:[[0,7,10],[-2,5,9],[-5,2,7],[0,7,12]],
    melody:[0,2,3,7,10,12,10,8,7,3,2,0,2,3,5,7],
    counter:[-5,-3,-1,0,2,3,2,0,-1,-3,-5,-3,-1,0,2,3]
  },
  {
    root:329.63, // E
    tempo:88,
    patternLen:16,
    chords:[[0,7,11],[-4,3,8],[-5,2,9],[0,7,12]],
    melody:[0,2,4,7,11,14,11,9,7,4,2,0,2,4,7,9],
    counter:[-5,-3,-2,0,2,4,2,0,-2,-3,-5,-3,-2,0,2,4]
  },
  {
    root:349.23, // F
    tempo:90,
    patternLen:16,
    chords:[[0,7,11],[-3,4,9],[-5,2,9],[0,7,12]],
    melody:[0,2,5,7,10,12,10,9,7,5,2,0,2,4,5,7],
    counter:[-5,-3,-1,0,2,4,2,0,-1,-3,-5,-3,-1,0,2,4]
  },
  {
    root:369.99, // F#
    tempo:92,
    patternLen:16,
    chords:[[0,7,11],[-4,3,8],[-6,1,8],[0,7,12]],
    melody:[0,2,4,7,11,14,16,14,11,9,7,4,2,0,2,4],
    counter:[-5,-3,-2,0,2,4,5,4,2,0,-2,-3,-5,-3,-2,0]
  }
];

// ==========
let currentStageIndex = 0;
let stage = null;
let rows = 0;
let cols = 0;

let blocks = [];
let marks = [];
let bombCount = 0;

let tickTimer = null;
let isRunning = false;
let wavesSpawned = 0;

let score = 0;
let forbidHits = 0;
let collapseCount = 0;
let hitNormal = 0;
let hitAdv = 0;

let bombReloadLock = false;

// DOM
const boardEl          = document.getElementById("board");
const statusLevelEl    = document.getElementById("status-level");
const statusGridEl     = document.getElementById("status-grid");
const statusScoreEl    = document.getElementById("status-score");
const statusForbidEl   = document.getElementById("status-forbid");
const statusCollapseEl = document.getElementById("status-collapse");
const statusBombsEl    = document.getElementById("status-bombs");
const statusWavesEl    = document.getElementById("status-waves");

const btnStart         = document.getElementById("btn-start");
const btnRestart       = document.getElementById("btn-restart");
const btnLevelUp       = document.getElementById("btn-level-up");
const btnFire          = document.getElementById("btn-fire");
const toastEl          = document.getElementById("toast");

const overlayEl        = document.getElementById("overlay");
const overlayTitleEl   = document.getElementById("overlay-title");
const overlaySubEl     = document.getElementById("overlay-sub");
const overlayLevelEl   = document.getElementById("overlay-level");
const overlayScoreEl   = document.getElementById("overlay-score");
const overlayForbidEl  = document.getElementById("overlay-forbid");
const overlayCollapseEl= document.getElementById("overlay-collapse");
const overlayHitNormalEl = document.getElementById("overlay-hit-normal");
const overlayHitAdvEl    = document.getElementById("overlay-hit-adv");
const overlayNextBtn   = document.getElementById("overlay-next");
const overlayRetryBtn  = document.getElementById("overlay-retry");

// =====================
//   BGM（WebAudio）
// =====================
let audioCtx = null;
let bgmMasterGain = null;
let bgmChordPads = [];
let bgmLeadMain = null;
let bgmLeadCounter = null;
let bgmMelodyTimer = null;
let bgmChordTimer = null;

function ensureAudioContext(){
  if(!audioCtx){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!AC) return;
    audioCtx = new AC();
    bgmMasterGain = audioCtx.createGain();
    bgmMasterGain.gain.value = 0.18;
    bgmMasterGain.connect(audioCtx.destination);
  }
  if(audioCtx.state === "suspended"){
    audioCtx.resume();
  }
}

function stopBgm(){
  if(!audioCtx || !bgmMasterGain) return;
  const now = audioCtx.currentTime;

  if(bgmMelodyTimer){
    clearInterval(bgmMelodyTimer);
    bgmMelodyTimer = null;
  }
  if(bgmChordTimer){
    clearInterval(bgmChordTimer);
    bgmChordTimer = null;
  }

  bgmMasterGain.gain.cancelScheduledValues(now);
  bgmMasterGain.gain.setValueAtTime(bgmMasterGain.gain.value, now);
  bgmMasterGain.gain.linearRampToValueAtTime(0.0, now + 0.6);

  bgmChordPads.forEach(v=>{
    v.gain.gain.cancelScheduledValues(now);
    v.gain.gain.setValueAtTime(v.gain.gain.value, now);
    v.gain.gain.linearRampToValueAtTime(0.0, now + 0.6);
    v.osc.stop(now + 0.7);
  });
  bgmChordPads = [];

  function fadeOutLead(lead){
    if(!lead) return;
    lead.gain.gain.cancelScheduledValues(now);
    lead.gain.gain.setValueAtTime(lead.gain.gain.value, now);
    lead.gain.gain.linearRampToValueAtTime(0.0, now + 0.4);
    lead.osc.stop(now + 0.5);
  }
  fadeOutLead(bgmLeadMain);
  fadeOutLead(bgmLeadCounter);
  bgmLeadMain = null;
  bgmLeadCounter = null;
}

function startBgmForStage(index){
  if(!audioCtx || !bgmMasterGain) return;

  stopBgm();

  const cfg = STAGE_BGM[index] || STAGE_BGM[STAGE_BGM.length-1];
  const base = cfg.root;
  const chords = cfg.chords;
  const melody = cfg.melody;
  const counter = cfg.counter || melody.map(v => v - 5);
  const patternLen = cfg.patternLen || melody.length;
  const tempo = cfg.tempo || 80;
  const beatSec = 60 / tempo;

  const now = audioCtx.currentTime;

  bgmMasterGain.gain.cancelScheduledValues(now);
  bgmMasterGain.gain.setValueAtTime(0.0, now);
  bgmMasterGain.gain.linearRampToValueAtTime(0.2, now + 1.0);

  // パッド（3声で持続）
  const firstChord = chords[0];
  for(let i=0;i<3;i++){
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    const semi = firstChord[i] || 0;
    const freq = base * Math.pow(2, semi/12);

    osc.type = "sine";
    osc.frequency.setValueAtTime(freq, now);

    filter.type = "lowpass";
    filter.frequency.setValueAtTime(1300 + i*400, now);
    filter.Q.value = 0.9;

    gain.gain.value = 0.0;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(bgmMasterGain);

    const startTime = now + i*0.08;
    osc.start(startTime);
    const tgt = 0.18 - i*0.05;
    gain.gain.linearRampToValueAtTime(tgt, startTime + 1.5);

    bgmChordPads.push({osc,gain});
  }

  // コード進行（数拍ごとにじわっと変える）
  let chordIndex = 0;
  const chordBeats = 4;
  bgmChordTimer = setInterval(()=>{
    if(!audioCtx || bgmChordPads.length === 0) return;
    chordIndex = (chordIndex + 1) % chords.length;
    const chord = chords[chordIndex];
    const t = audioCtx.currentTime + 0.05;
    bgmChordPads.forEach((v,i)=>{
      const semi = chord[i] || 0;
      const freq = base * Math.pow(2, semi/12);
      v.osc.frequency.setTargetAtTime(freq, t, 1.2);
    });
  }, beatSec*1000*chordBeats);

  // メイン＆カウンターメロディ
  const leadOsc1 = audioCtx.createOscillator();
  const leadGain1 = audioCtx.createGain();
  leadOsc1.type = "triangle";
  leadGain1.gain.value = 0.0;
  leadOsc1.connect(leadGain1);
  leadGain1.connect(bgmMasterGain);
  leadOsc1.start(now + 0.3);
  bgmLeadMain = {osc:leadOsc1, gain:leadGain1};

  const leadOsc2 = audioCtx.createOscillator();
  const leadGain2 = audioCtx.createGain();
  leadOsc2.type = "sine";
  leadGain2.gain.value = 0.0;
  leadOsc2.connect(leadGain2);
  leadGain2.connect(bgmMasterGain);
  leadOsc2.start(now + 0.3);
  bgmLeadCounter = {osc:leadOsc2, gain:leadGain2};

  let step = 0;
  bgmMelodyTimer = setInterval(()=>{
    if(!audioCtx || !bgmLeadMain || !bgmLeadCounter) return;
    const idx = step % patternLen;
    const mSemi = melody[idx % melody.length];
    const cSemi = counter[idx % counter.length];

    const t = audioCtx.currentTime;

    // 8拍ごとに少し強く
    const phrasePos = step % (patternLen);
    const accent = (phrasePos === 0 || phrasePos === 8) ? 1.15 : 1.0;

    const fMain = base * Math.pow(2, mSemi/12);
    const fCounter = base * Math.pow(2, cSemi/12);

    bgmLeadMain.osc.frequency.setTargetAtTime(fMain, t, 0.04);
    bgmLeadCounter.osc.frequency.setTargetAtTime(fCounter, t, 0.06);

    const g1 = 0.26 * accent;
    const g2 = 0.18;

    // それぞれ短いエンベロープ
    bgmLeadMain.gain.gain.cancelScheduledValues(t);
    bgmLeadMain.gain.gain.setValueAtTime(0.0, t);
    bgmLeadMain.gain.gain.linearRampToValueAtTime(g1, t + beatSec*0.15);
    bgmLeadMain.gain.gain.linearRampToValueAtTime(0.0, t + beatSec*0.9);

    bgmLeadCounter.gain.gain.cancelScheduledValues(t);
    bgmLeadCounter.gain.gain.setValueAtTime(0.0, t);
    bgmLeadCounter.gain.gain.linearRampToValueAtTime(g2, t + beatSec*0.2);
    bgmLeadCounter.gain.gain.linearRampToValueAtTime(0.0, t + beatSec*0.95);

    step++;
  }, beatSec*1000);
}

// =====================
//   ユーティリティ
// =====================
function randInt(min,max){
  return Math.floor(Math.random()*(max-min+1))+min;
}
function weightedType(stage){
  const r = Math.random();
  if(r < stage.ratioN) return TYPE_NORMAL;
  if(r < stage.ratioN + stage.ratioG) return TYPE_ADV;
  return TYPE_FORBID;
}
function showToast(text){
  toastEl.textContent = text;
  toastEl.classList.add("visible");
  setTimeout(() => {
    toastEl.classList.remove("visible");
  }, 800);
}
function stopTick(){
  if(tickTimer){
    clearInterval(tickTimer);
    tickTimer = null;
  }
}

// =====================
//   ステージ初期化
// =====================
function initStage(index){
  currentStageIndex = index;
  stage = STAGES[index];

  rows = stage.rows;
  cols = stage.cols;

  blocks = [];
  marks = Array.from({length:rows}, () => Array(cols).fill(MARK_NONE));
  bombCount = 0;
  wavesSpawned = 0;
  score = 0;
  forbidHits = 0;
  collapseCount = 0;
  hitNormal = 0;
  hitAdv = 0;
  bombReloadLock = false;
  isRunning = false;
  stopTick();

  boardEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

  updateStatus();
  renderBoard();

  btnStart.textContent = "▶ START";

  // すでにオーディオ解錠済みなら BGM だけ切り替え
  if(audioCtx){
    startBgmForStage(currentStageIndex);
  }
}

// =====================
//   ステータス更新
// =====================
function updateStatus(){
  statusLevelEl.textContent    = `${currentStageIndex+1} / ${STAGES.length}`;
  statusGridEl.textContent     = `${rows}×${cols}`;
  statusScoreEl.textContent    = score.toString();
  statusForbidEl.textContent   = `${forbidHits} / ${stage.forbidLimit}`;
  statusCollapseEl.textContent = `${collapseCount} / ${stage.collapseLimit}`;
  statusBombsEl.textContent    = `${bombCount} / 4`;
  statusWavesEl.textContent    = `${wavesSpawned} / ${stage.waves}`;
}

// =====================
//   ボード描画
// =====================
function renderBoard(){
  boardEl.innerHTML = "";
  for(let r = rows-1; r >= 0; r--){
    for(let c = 0; c < cols; c++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = String(r);
      cell.dataset.col = String(c);

      const inner = document.createElement("div");
      inner.className = "cell-inner";
      cell.appendChild(inner);

      const block = blocks.find(b => b.row === r && b.col === c);
      if(block){
        const bEl = document.createElement("div");
        bEl.classList.add("block");
        const lbl = document.createElement("div");
        lbl.className = "block-label";
        if(block.type === TYPE_NORMAL){
          bEl.classList.add("block-normal");
          lbl.textContent = "";
        }else if(block.type === TYPE_ADV){
          bEl.classList.add("block-adv");
          lbl.textContent = "+";
        }else if(block.type === TYPE_FORBID){
          bEl.classList.add("block-forbid");
          lbl.textContent = "X";
        }
        bEl.appendChild(lbl);
        cell.appendChild(bEl);
      }

      const mark = marks[r][c];
      if(mark === MARK_BOMB){
        const mEl = document.createElement("div");
        mEl.className = "mark-bomb";
        cell.appendChild(mEl);
      }else if(mark === MARK_SAFE){
        const mEl = document.createElement("div");
        mEl.className = "mark-safe";
        cell.appendChild(mEl);
      }

      boardEl.appendChild(cell);
    }
  }
}

// =====================
//   セルタップ処理
// =====================
function handleCellTap(r,c){
  if(!stage) return;

  const hasBlock = blocks.some(b => b.row === r && b.col === c);
  if(hasBlock){
    const idxDom = (rows-1-r)*cols + c;
    const cell = boardEl.children[idxDom];
    if(cell){
      cell.classList.add("cell-blocked-flash");
      setTimeout(() => cell.classList.remove("cell-blocked-flash"), 220);
    }
    return;
  }

  let current = marks[r][c];
  let next;
  if(current === MARK_NONE){
    next = MARK_BOMB;
  }else if(current === MARK_BOMB){
    next = MARK_SAFE;
  }else{
    next = MARK_NONE;
  }

  if(next === MARK_BOMB){
    if(bombReloadLock){
      showToast("リロード中… 少し待ってください");
      return;
    }
    if(bombCount >= 4){
      showToast("爆弾は4つまでしか設置できません");
      return;
    }
  }

  if(current === MARK_BOMB) bombCount--;
  if(next === MARK_BOMB) bombCount++;

  marks[r][c] = next;
  updateStatus();
  renderBoard();
}

// =====================
//   FIRE
// =====================
function handleFire(){
  if(!stage) return;
  if(bombReloadLock){
    showToast("リロード中です");
    return;
  }

  const bombs = [];
  for(let r = 0; r < rows; r++){
    for(let c = 0; c < cols; c++){
      if(marks[r][c] === MARK_BOMB){
        bombs.push({r,c});
      }
    }
  }
  if(bombs.length === 0){
    showToast("爆弾がありません");
    return;
  }

  const toDestroyKey = new Set();

  function markDestroyCell(rr,cc){
    if(rr < 0 || rr >= rows || cc < 0 || cc >= cols) return;
    const key = `${rr},${cc}`;
    toDestroyKey.add(key);
  }

  function findBlockAt(rr,cc){
    return blocks.find(b => b.row === rr && b.col === cc);
  }

  for(const {r,c} of bombs){
    const block = findBlockAt(r,c);
    if(!block) continue;

    if(block.type === TYPE_ADV){
      for(let rr = r-1; rr <= r+1; rr++){
        for(let cc = c-1; cc <= c+1; cc++){
          if(rr < 0 || rr >= rows || cc < 0 || cc >= cols) continue;
          if(marks[rr][cc] === MARK_SAFE) continue;
          const target = findBlockAt(rr,cc);
          if(target){
            markDestroyCell(rr,cc);
          }
        }
      }
    }else{
      if(marks[r][c] !== MARK_SAFE && block){
        markDestroyCell(r,c);
      }
    }
  }

  if(toDestroyKey.size > 0){
    const newBlocks = [];
    for(const b of blocks){
      const key = `${b.row},${b.col}`;
      if(toDestroyKey.has(key)){
        if(b.type === TYPE_NORMAL){
          score += 10;
          hitNormal++;
        }else if(b.type === TYPE_ADV){
          score += 25;
          hitAdv++;
        }else if(b.type === TYPE_FORBID){
          forbidHits++;
        }
      }else{
        newBlocks.push(b);
      }
    }
    blocks = newBlocks;

    if(forbidHits > stage.forbidLimit){
      updateStatus();
      renderBoard();
      onGameOver("禁止ブロックを破壊しすぎました…");
      return;
    }
  }

  for(let r = 0; r < rows; r++){
    for(let c = 0; c < cols; c++){
      if(marks[r][c] === MARK_BOMB){
        marks[r][c] = MARK_NONE;
      }
    }
  }
  bombCount = 0;

  updateStatus();
  renderBoard();

  bombReloadLock = true;
  btnFire.setAttribute("disabled","disabled");
  setTimeout(() => {
    bombReloadLock = false;
    btnFire.removeAttribute("disabled");
  }, 500);
}

// =====================
//   Wave生成
// =====================
function spawnWave(){
  if(wavesSpawned >= stage.waves) return;
  wavesSpawned++;

  const backRow = rows-1;
  const occupiedCols = new Set(
    blocks.filter(b => b.row === backRow).map(b => b.col)
  );

  const freeCols = [];
  for(let c = 0; c < cols; c++){
    if(!occupiedCols.has(c)){
      freeCols.push(c);
    }
  }
  if(freeCols.length === 0) return;

  const blockCount = Math.min(
    freeCols.length,
    randInt(stage.minBlocks, stage.maxBlocks)
  );
  for(let i = freeCols.length - 1; i > 0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [freeCols[i], freeCols[j]] = [freeCols[j], freeCols[i]];
  }

  for(let i = 0; i < blockCount; i++){
    const col = freeCols[i];
    const type = weightedType(stage);
    blocks.push({row:backRow, col, type});
  }
}

// =====================
//   1Tick
// =====================
function tick(){
  if(!isRunning || !stage) return;

  for(const b of blocks){
    b.row--;
  }

  let fallNormalOccurred = false;
  const remain = [];
  for(const b of blocks){
    if(b.row < 0){
      if(b.type !== TYPE_FORBID){
        fallNormalOccurred = true;
      }
    }else{
      remain.push(b);
    }
  }
  blocks = remain;

  if(fallNormalOccurred){
    collapseCount++;

    const collapseRow = 0;
    blocks = blocks.filter(b => b.row !== collapseRow);
    for(let c = 0; c < cols; c++){
      marks[collapseRow][c] = MARK_NONE;
    }

    showToast("崩落！");
  }

  if(collapseCount > stage.collapseLimit){
    updateStatus();
    renderBoard();
    onGameOver("ブロックの崩落が多すぎました…");
    return;
  }

  if(wavesSpawned < stage.waves){
    spawnWave();
  }

  if(wavesSpawned >= stage.waves && blocks.length === 0){
    updateStatus();
    renderBoard();
    onStageClear();
    return;
  }

  updateStatus();
  renderBoard();
}

// =====================
//   Start / Pause
// =====================
function toggleStart(){
  if(!stage) return;
  if(!isRunning){
    // 最初のSTARTでオーディオ解錠＆BGM開始
    ensureAudioContext();
    if(audioCtx){
      startBgmForStage(currentStageIndex);
    }

    isRunning = true;
    btnStart.textContent = "Ⅱ PAUSE";
    if(!tickTimer){
      tickTimer = setInterval(tick, stage.tickMs);
    }
  }else{
    isRunning = false;
    btnStart.textContent = "▶ START";
    stopTick();
  }
}

// =====================
//   結果
// =====================
function onStageClear(){
  isRunning = false;
  stopTick();

  overlayTitleEl.textContent = "Stage Clear!";
  overlaySubEl.textContent   = `LEVEL ${currentStageIndex+1} をクリアしました`;
  overlayLevelEl.textContent = `${currentStageIndex+1} / ${STAGES.length}`;
  overlayScoreEl.textContent = score.toString();
  overlayForbidEl.textContent = forbidHits.toString();
  overlayCollapseEl.textContent = collapseCount.toString();
  overlayHitNormalEl.textContent = hitNormal.toString();
  overlayHitAdvEl.textContent = hitAdv.toString();

  overlayNextBtn.textContent =
    (currentStageIndex < STAGES.length-1) ? "▶ NEXT LEVEL" : "▶ LEVEL 1 へ";
  overlayEl.classList.remove("hidden");
}

function onGameOver(message){
  isRunning = false;
  stopTick();

  overlayTitleEl.textContent = "Game Over";
  overlaySubEl.textContent   = message;
  overlayLevelEl.textContent = `${currentStageIndex+1} / ${STAGES.length}`;
  overlayScoreEl.textContent = score.toString();
  overlayForbidEl.textContent = forbidHits.toString();
  overlayCollapseEl.textContent = collapseCount.toString();
  overlayHitNormalEl.textContent = hitNormal.toString();
  overlayHitAdvEl.textContent = hitAdv.toString();

  overlayNextBtn.textContent = "▶ 同じLEVEL";
  overlayEl.classList.remove("hidden");
}

// =====================
//   iPhoneズーム防止
// =====================
function setupIOSZoomGuards(){
  let lastTouchEnd = 0;
  document.addEventListener("touchend", (ev) => {
    const now = Date.now();
    if(now - lastTouchEnd <= 300){
      ev.preventDefault();
    }
    lastTouchEnd = now;
  }, {passive:false});

  document.addEventListener("gesturestart", (ev) => {
    ev.preventDefault();
  });
}

// =====================
//   イベントセットアップ
// =====================
function setupEvents(){
  boardEl.addEventListener("pointerdown", (ev) => {
    const target = ev.target.closest(".cell");
    if(!target) return;
    ev.preventDefault();
    const r = Number(target.dataset.row);
    const c = Number(target.dataset.col);
    handleCellTap(r,c);
  });

  btnFire.addEventListener("click", () => {
    handleFire();
  });

  btnStart.addEventListener("click", () => {
    toggleStart();
  });

  btnRestart.addEventListener("click", () => {
    initStage(currentStageIndex);
  });

  btnLevelUp.addEventListener("click", () => {
    const nextIndex = (currentStageIndex + 1) % STAGES.length;
    initStage(nextIndex);
  });

  overlayNextBtn.addEventListener("click", () => {
    overlayEl.classList.add("hidden");
    if(overlayTitleEl.textContent === "Game Over"){
      initStage(currentStageIndex);
    }else{
      const nextIndex =
        (currentStageIndex < STAGES.length-1) ? currentStageIndex+1 : 0;
      initStage(nextIndex);
    }
  });
  overlayRetryBtn.addEventListener("click", () => {
    overlayEl.classList.add("hidden");
    initStage(currentStageIndex);
  });

  window.addEventListener("keydown", (ev) => {
    if(ev.key === " "){
      ev.preventDefault();
      toggleStart();
    }else if(ev.key === "f" || ev.key === "F"){
      ev.preventDefault();
      handleFire();
    }
  });

  setupIOSZoomGuards();
}

// =====================
//   起動
// =====================
(function(){
  setupEvents();
  initStage(0);
})();
</script>
</body>
</html>
