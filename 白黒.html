<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>白黒シューター - 精錬版</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box;font-family:"Noto Sans JP",system-ui,sans-serif;-webkit-user-select:none;user-select:none}
  body{background:#000;color:#fff;overflow:hidden;touch-action:none}
  canvas{display:block;margin:0 auto;background:#000}
  #overlay{position:absolute;top:20px;left:20px;z-index:10;display:flex;flex-direction:column;gap:12px;color:#fff;text-shadow:0 0 6px rgba(255,255,255,.6)}
  #overlay .row{display:flex;gap:24px;font-size:18px}
  #powerup{font-size:16px;color:#dedede}
  #titleScreen,#gameOver{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(circle at 50% 40%,rgba(255,255,255,.12),rgba(0,0,0,.92));color:#fff;text-align:center;z-index:30}
  #titleScreen h1{font-size:42px;letter-spacing:6px;margin-bottom:16px;text-shadow:0 0 15px rgba(255,255,255,.8)}
  #titleScreen p{max-width:520px;line-height:1.6;margin-bottom:28px;color:#ccc}
  .btn{border:2px solid #fff;background:rgba(255,255,255,.08);color:#fff;padding:14px 36px;font-size:18px;letter-spacing:4px;cursor:pointer;transition:background .2s,border .2s;}
  .btn:hover{background:rgba(255,255,255,.2);}
  #gameOver{display:none}
  #gameOver h2{font-size:40px;margin-bottom:16px;letter-spacing:8px;text-transform:uppercase}
  #gameOver p{font-size:20px;margin-bottom:24px;color:#d9d9d9}
  #stageBanner{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:18px 38px;border:1px solid rgba(255,255,255,.8);color:#000;background:rgba(255,255,255,.85);font-size:32px;letter-spacing:8px;display:none;z-index:25;text-shadow:none}
  #muteBtn{position:absolute;top:20px;right:20px;z-index:12;border:1px solid #fff;background:rgba(255,255,255,.08);color:#fff;padding:8px 16px;font-size:12px;letter-spacing:2px;cursor:pointer}
</style>
</head>
<body>
  <div id="titleScreen">
    <h1>白黒シューター</h1>
    <p>Stage2から「懺（ぜん）」：長押しで円形チャージ→解放で周囲を殲滅。ボスは出目で攻撃予告。BGMは戦況に応じて動的に変化。背景演出はステージが進むほど豪華に。</p>
    <button class="btn" id="startBtn">START</button>
  </div>
  <div id="stageBanner"></div>
  <div id="overlay">
    <div class="row">
      <div>STAGE: <span id="stage">1</span>/2</div>
      <div>スコア: <span id="score">000000</span></div>
      <div>ライフ: <span id="life">3</span></div>
      <div id="zenHud" style="display:none">懺: <span id="zenTime">0.0</span>s</div>
    </div>
    <div id="powerup"></div>
  </div>
  <button id="muteBtn">BGM: ON</button>
  <div id="gameOver">
    <h2>GAME OVER</h2>
    <p>FINAL SCORE: <span id="finalScore">0</span></p>
    <button class="btn" id="restartBtn">RESTART</button>
  </div>
  <canvas id="game"></canvas>

  <script>
  /* ===== PART 1/3: DOM・Audio基盤・Dynamic BGM骨格 ===== */
  const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
  const overlayPower=document.getElementById('powerup'), scoreEl=document.getElementById('score'), lifeEl=document.getElementById('life'), stageEl=document.getElementById('stage');
  const zenHud=document.getElementById('zenHud'), zenTimeEl=document.getElementById('zenTime');
  const titleScreen=document.getElementById('titleScreen'), gameOver=document.getElementById('gameOver'), finalScore=document.getElementById('finalScore');
  const stageBanner=document.getElementById('stageBanner');
  const startBtn=document.getElementById('startBtn'), restartBtn=document.getElementById('restartBtn'), muteBtn=document.getElementById('muteBtn');

  function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
  addEventListener('resize',resize); resize();

  // ===== Audio Core =====
  let audioCtx=null, masterGain=null, bgmMuted=false;
  let bgm={ mode:'silence', parts:[], timers:[], bus:null, beatTimer:null, intensity:0 };

  function initAudio(){
    if(audioCtx) return;
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    masterGain=audioCtx.createGain(); masterGain.gain.value=0.12; masterGain.connect(audioCtx.destination);
  }
  function makeBus(){
    const input=audioCtx.createGain(); input.gain.value=1.0;
    const low=audioCtx.createBiquadFilter(); low.type='lowpass'; low.frequency.value=2400; low.Q.value=0.7;
    const del=audioCtx.createDelay(1.0); del.delayTime.value=0.26; const fb=audioCtx.createGain(); fb.gain.value=0.24;
    const del2=audioCtx.createDelay(1.0); del2.delayTime.value=0.41; const fb2=audioCtx.createGain(); fb2.gain.value=0.18;
    input.connect(low); low.connect(masterGain);
    low.connect(del); del.connect(fb).connect(del); del.connect(masterGain);
    low.connect(del2); del2.connect(fb2).connect(del2); del2.connect(masterGain);
    return {input,low,del,fb,del2,fb2};
  }
  function stopBgm(){
    if(!audioCtx) return;
    if(bgm.beatTimer){ clearInterval(bgm.beatTimer); bgm.beatTimer=null; }
    bgm.timers.forEach(id=>clearInterval(id)); bgm.timers.length=0;
    bgm.parts.forEach(n=>{ try{ n.stop&&n.stop(); n.disconnect&&n.disconnect(); }catch{} });
    bgm.parts.length=0;
    try{ bgm.bus?.input.disconnect(); }catch{}
    bgm.mode='silence';
  }
  function toggleBgm(){
    if(!audioCtx) initAudio();
    bgmMuted=!bgmMuted;
    masterGain.gain.linearRampToValueAtTime(bgmMuted?0:0.12, audioCtx.currentTime+0.25);
    muteBtn.textContent=bgmMuted?'BGM: OFF':'BGM: ON';
  }
  muteBtn.addEventListener('click',()=>{ initAudio(); toggleBgm(); });

  // ===== SFX（既存） =====
  const sfx={
    ensure(){ if(!audioCtx) initAudio(); },
    burst(freq=440,dur=0.1,vol=0.18){ this.ensure(); const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(freq,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(vol,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+dur); o.connect(g).connect(masterGain); o.start(t); o.stop(t+dur+0.05); },
    noise(dur=0.45,vol=0.22){ this.ensure(); const t=audioCtx.currentTime; const buf=audioCtx.createBuffer(1, audioCtx.sampleRate*dur, audioCtx.sampleRate); const d=buf.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.exp(-i/d.length*7);} const src=audioCtx.createBufferSource(); src.buffer=buf; const g=audioCtx.createGain(); g.gain.setValueAtTime(0.22*vol/0.22,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur); src.connect(g).connect(masterGain); src.start(t); },
    hit(){ this.burst(160,0.15,0.22); }, shoot(){ this.burst(760,0.08,0.16); }, item(){ this.burst(1100,0.12,0.18); this.burst(1400,0.12,0.18); },
    boss(){ this.burst(280,0.4,0.28); }, clear(){ this.burst(900,0.4,0.22); },
    evolve(){ this.burst(500,0.3,0.32); this.noise(0.6,0.30); },
    fanfare(){ this.ensure(); const t=audioCtx.currentTime+0.02; const seq=[523,659,784,1046,1318,1046,1568]; let off=0; for(const f of seq){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(f,t+off); g.gain.setValueAtTime(0.0001,t+off); g.gain.exponentialRampToValueAtTime(0.22,t+off+0.03); g.gain.exponentialRampToValueAtTime(0.0001,t+off+0.32); o.connect(g).connect(masterGain); o.start(t+off); o.stop(t+off+0.38); off+=0.16; } }
  };

  // ===== BGM（Stage1固定曲 + Stage2はDynamic/Adaptive） =====
  function setBgm(mode){
    if(!audioCtx) initAudio();
    if(bgm.mode===mode) return;
    stopBgm();
    if(mode.startsWith('s2_')) return setBgmS2(mode); // Stage2は専用
    bgm.mode=mode; bgm.bus=makeBus();
    const A4=440, toHz=semi=>A4*Math.pow(2,semi/12);
    const scenes={ s1_stage:{tempo:112,root:-10,chA:[0,5,7,5],chB:[-2,3,5,3],leadA:[0,2,5,7,9,7,5,2],leadB:[0,3,5,7,10,7,5,3]},
                   s1_boss1:{tempo:126,root:-8,chA:[0,4,7,4],chB:[-1,3,7,3],leadA:[0,2,3,5,7,5,3,2],leadB:[0,3,5,7,8,7,5,3]},
                   s1_boss2:{tempo:140,root:-7,chA:[0,3,7,10],chB:[0,5,10,7],leadA:[0,3,6,10,6,3,0,-2],leadB:[0,2,5,7,10,7,5,2]}};
    const sc=scenes[mode]||scenes.s1_stage;
    function hat(v=0.1){ const t=audioCtx.currentTime; const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.06,audioCtx.sampleRate), d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,8); const s=audioCtx.createBufferSource(); s.buffer=b; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; const g=audioCtx.createGain(); g.gain.value=v; s.connect(hp).connect(g).connect(bgm.bus.input); s.start(t);}
    function kick(v=0.16){ const t=audioCtx.currentTime+0.003; const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(110,t); o.frequency.exponentialRampToValueAtTime(50,t+0.09); g.gain.value=v; g.gain.exponentialRampToValueAtTime(0.0001,t+0.12); o.connect(g).connect(bgm.bus.input); o.start(t); o.stop(t+0.14);}
    const toF=semi=>toHz(sc.root+semi);
    function chord(root){ [0,4,7,12].forEach(iv=>{ const o=audioCtx.createOscillator(); o.type='triangle'; o.frequency.value=toF(root+iv); const g=audioCtx.createGain(); g.gain.value=0.0001; o.connect(g).connect(bgm.bus.input); const t=audioCtx.currentTime; g.gain.exponentialRampToValueAtTime(0.12,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.3); o.start(t); o.stop(t+0.32); });}
    function lead(semi,vel=0.2){ const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=toF(semi+12); const g=audioCtx.createGain(); g.gain.value=0.0001; o.connect(g).connect(bgm.bus.input); const t=audioCtx.currentTime; g.gain.exponentialRampToValueAtTime(vel,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.22); o.start(t); o.stop(t+0.24); }
    const bpm=sc.tempo, beat=60/bpm, tick=beat/4; let i=0, sect=0;
    bgm.beatTimer=setInterval(()=>{ const bar=Math.floor(i/4)%8, beatI=i%4; if(beatI===0) kick(0.16); if(Math.random()<0.9) hat(0.09);
      const ch=(sect%2?sc.chB:sc.chA)[Math.floor(bar/2)%4]; if(beatI===0) chord(ch); const ld=(sect%2?sc.leadB:sc.leadA)[bar%8]; if(i%2===1) lead(ch+ld,0.18);
      if(bar===7 && beatI===3) sect++; i=(i+1)%64; }, tick*1000);
  }

  // ===== Stage2：Dynamic/Adaptive =====
  function setBgmS2(mode){
    bgm.mode=mode; bgm.bus=makeBus(); bgm.intensity=0;
    const A4=440, toHz=semi=>A4*Math.pow(2,semi/12);
    const cfg = { s2_stage:{tempo:86, hatEvery:2}, s2_boss1:{tempo:110, hatEvery:1}, s2_boss2:{tempo:122, hatEvery:1} }[mode];
    function noiseHat(vol=0.08){ const t=audioCtx.currentTime; const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.05,audioCtx.sampleRate), d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,9); const s=audioCtx.createBufferSource(); s.buffer=b; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=7000; const g=audioCtx.createGain(); g.gain.value=vol; s.connect(hp).connect(g).connect(bgm.bus.input); s.start(t); }
    function tunedKick(noteHz=70, vol=0.18){ const t=audioCtx.currentTime+0.002; const o=audioCtx.createOscillator(); o.type='sine'; const g=audioCtx.createGain(); g.gain.value=vol; o.frequency.setValueAtTime(noteHz*1.8,t); o.frequency.exponentialRampToValueAtTime(noteHz,t+0.1); g.gain.exponentialRampToValueAtTime(0.0001,t+0.14); o.connect(g).connect(bgm.bus.input); o.start(t); o.stop(t+0.16); }
    function tom(noteHz=120, vol=0.15){ const t=audioCtx.currentTime+0.002; const o=audioCtx.createOscillator(); o.type='triangle'; const g=audioCtx.createGain(); g.gain.value=vol; o.frequency.setValueAtTime(noteHz*1.2,t); o.frequency.exponentialRampToValueAtTime(noteHz,t+0.08); g.gain.exponentialRampToValueAtTime(0.0001,t+0.12); o.connect(g).connect(bgm.bus.input); o.start(t); o.stop(t+0.14); }
    function shortPluck(freq, vel=0.10, len=0.18){ const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); o.type='square'; o.frequency.value=freq; const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1200+1000*bgm.intensity; f.Q.value=0.9; const g=audioCtx.createGain(); g.gain.value=0.0001; o.connect(f).connect(g).connect(bgm.bus.input); g.gain.exponentialRampToValueAtTime(vel*(0.9+0.4*bgm.intensity), t+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t+len); o.start(t); o.stop(t+len+0.02); }
    function airyPad(freq, len=1.2, vol=0.04){ const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=freq; const g=audioCtx.createGain(); g.gain.value=0.0001; o.connect(g).connect(bgm.bus.input); const t=audioCtx.currentTime; g.gain.linearRampToValueAtTime(vol*(0.9+0.4*bgm.intensity), t+0.4); g.gain.linearRampToValueAtTime(0.0001, t+len); o.start(t); o.stop(t+len+0.05); }

    const beat=60/cfg.tempo, tick=(mode==='s2_stage'? beat/2 : beat/4);
    let i=0, bar=0, transpose=0;

    if(mode==='s2_stage'){
      const root=-9; const pent=[0,2,5,7,9], phry=[0,1,3,5,7,8,10], seq=[pent,phry,pent,phry];
      const drone=audioCtx.createOscillator(); drone.type='sine'; drone.frequency.value=toHz(root-24); const dg=audioCtx.createGain(); dg.gain.value=0.018; drone.connect(dg).connect(bgm.bus.input); drone.start();
      bgm.parts.push({stop:()=>{try{drone.stop();}catch{}},disconnect:()=>{try{drone.disconnect();}catch{}}});
      bgm.beatTimer=setInterval(()=>{ if(i%cfg.hatEvery===0 && Math.random()<0.35+0.3*bgm.intensity) noiseHat(0.05+0.05*bgm.intensity);
        if(i%2===0){ const scale=seq[Math.floor(bar/4)%seq.length]; const step=scale[Math.floor(Math.random()*scale.length)]; const sem=root+transpose+step;
          shortPluck(toHz(sem+12), 0.1+0.06*bgm.intensity, 0.16); if(Math.random()<0.6+0.2*bgm.intensity) airyPad(toHz(sem-12), 1.0, 0.03+0.03*bgm.intensity);
        }
        if(i%16===0 && i>0){ transpose=[0,1,0,-1][(bar>>1)%4]; }
        i=(i+1)%64; if(i%8===0) bar=(bar+1)%16;
      }, tick*1000);
      return;
    }

    const pattern=['K','-','T','T','T','T','T','-','T','-','T','T','T','T','T','-'];
    const isP2=(mode==='s2_boss2');
    bgm.beatTimer=setInterval(()=>{ if(i%cfg.hatEvery===0) noiseHat(isP2?0.10:0.08);
      const step=pattern[i%16];
      if(step==='K'){ tunedKick(isP2?78:72, (isP2?0.22:0.2)*(0.9+0.4*bgm.intensity)); }
      else if(step==='T'){ const seqHz=isP2?[140,170,150,185,160]:[130,155,140,170]; const hz=seqHz[(i+Math.floor(bar/2))%seqHz.length]; tom(hz, (isP2?0.18:0.16)*(0.9+0.4*bgm.intensity)); }
      if(step==='K' || (isP2 && (i%4===2))){ const base=-9-24 + (isP2?((bar%4===0)?0:-2):0); shortPluck(toHz(base), 0.11+0.06*bgm.intensity, 0.14); }
      if(i%4===1){ const root=-9, phry=[0,1,3,5,7,8,10]; const p=phry[Math.floor(Math.random()*phry.length)]; const f=toHz(root+p+12 + (isP2?(bar%2?1:0):0)); airyPad(f, isP2?0.9:1.0, 0.045+0.03*bgm.intensity); }
      i=(i+1)%16; if(i===0){ bar++; }
    }, (beat/4)*1000);
  }

  function setAdaptiveIntensity(norm){
    if(!bgm.bus) return;
    bgm.intensity = Math.max(0, Math.min(1, norm));
    const t=audioCtx.currentTime;
    const top = 1600 + 1200*bgm.intensity;
    bgm.bus.low.frequency.cancelScheduledValues(t);
    bgm.bus.low.frequency.linearRampToValueAtTime(top, t+0.25);
  }
  /* ===== /PART 1/3 ===== */
  </script>
  <!-- この下に PART 2/3 を続けて貼ってください -->
  <!-- PART 2/3：Input／State／Spawns／DiceBoss／懺（長押し殲滅）／Update -->
  <script>
  /* ===== PART 2/3 ===== */

  // Input
  let pointerX=0, pointerY=0, pointerActive=false;
  function setPointer(e){
    const r=canvas.getBoundingClientRect();
    pointerX=e.clientX-r.left; pointerY=e.clientY-r.top; pointerActive=true;
  }
  canvas.addEventListener('pointerdown',e=>{ initAudio(); setPointer(e); handleZenStart(); });
  canvas.addEventListener('pointermove',e=>{ if(pointerActive || e.buttons>0 || (e.pressure||0)>0) setPointer(e); });
  addEventListener('pointerup',()=>{ pointerActive=false; handleZenRelease(); });

  // Game State
  let state='title', testsLocked=false;
  const player={
    x:0,y:0,vx:0,vy:0,speed:8,lives:3,invul:0,
    power:'normal',powerTimer:0,beamTimer:0,combo:0,
    zenUnlocked:false, zenCharging:false, zenT:0, zenTMax:2000, zenCooldown:0, zenCooldownMax:1200,
  };
  const bullets=[], enemies=[], enemyBullets=[], particles=[], items=[];
  let backgroundScroll=0, score=0, stage=1, stageTimer=0, boss=null, spawnTimer=0, stageGoal=false;
  const victoryFX={active:false,t:0,stage:1};
  const zenVis={show:false, radius:0, alpha:0};

  // Helpers
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const lerp=(a,b,t)=>a+(b-a)*t;

  function resetGame(){
    player.x=canvas.width/2; player.y=canvas.height-140;
    player.vx=player.vy=0; player.lives=3; player.invul=0;
    player.power='normal'; player.powerTimer=0; player.beamTimer=0;
    player.zenUnlocked=false; player.zenCharging=false; player.zenT=0; player.zenCooldown=0;
    zenVis.show=false; zenVis.radius=0; zenVis.alpha=0;

    bullets.length=0; enemies.length=0; enemyBullets.length=0; particles.length=0; items.length=0;
    score=0; stage=1; stageTimer=0; boss=null; spawnTimer=0; stageGoal=false;
    overlayPower.textContent=''; updateUI();
    zenHud.style.display='none';
    setBgm('s1_stage');
  }

  function updateUI(){
    scoreEl.textContent=String(score).padStart(6,'0');
    lifeEl.textContent=player.lives;
    stageEl.textContent=stage;
    if(player.zenUnlocked){
      zenHud.style.display='';
      zenTimeEl.textContent=(player.zenT/1000).toFixed(1);
    }
  }
  function showStageBanner(text){
    stageBanner.textContent=text;
    stageBanner.style.display='block';
    setTimeout(()=>stageBanner.style.display='none',1800);
  }

  // Spawns
  function spawnEnemy(){
    const s2=(stage===2 && !boss);
    const types = s2 ? ['straight','zigzag','tank','diver','sniper','orbiter'] : ['straight','zigzag','diver'];
    const weights = s2 ? [0.32,0.32,0.20,0.14,0.015,0.005] : [0.45,0.35,0.20];
    const pick=(arr,w)=>{ const r=Math.random(); let a=0; for(let i=0;i<arr.length;i++){ a+=w[i]; if(r<=a) return arr[i]; } return arr[arr.length-1]; };
    const type=pick(types,weights);

    const x=Math.random()*(canvas.width-160)+80, y=-40;
    let hp=2, vy=1.8, vx=0, shootDelay=1600, phase=Math.random()*Math.PI*2, stop=false;
    switch(type){
      case 'straight': vy=s2?2.3:1.8; hp=s2?3:2; shootDelay=1600; break;
      case 'zigzag' : vy=s2?2.1:1.7; hp=s2?3:2; shootDelay=1400; break;
      case 'tank'   : vy=1.15; hp=s2?6:4; shootDelay=1200; break;
      case 'diver'  : vy=2.0; hp=2; shootDelay=9999; break;
      case 'sniper' : vy=1.6; hp=s2?3:2; shootDelay=2200; break;
      case 'orbiter': vy=1.7; hp=s2?4:3; shootDelay=1800; break;
    }
    enemies.push({x,y,vx,vy,hp,type,phase,shootTimer:0,shootDelay,stop});
  }

  function spawnItem(x,y){
    const pool = (stage>=2) ? ['spread','heal','beam','shield','zen'] : ['spread','heal','beam','shield'];
    const type=pool[Math.floor(Math.random()*pool.length)];
    items.push({x,y,type,vy:1.5,phase:0});
  }

  function spawnBoss(){
    if(stage===1){
      boss={x:canvas.width/2,y:160,baseX:canvas.width/2,baseY:160,hp:180,maxHp:180,type:'sentinel',cooldown:0,form:1,dropMilestones:[0.75,0.5,0.25]};
      setBgm('s1_boss1');
    }else{
      const pad=80;
      boss={
        x:canvas.width/2, y:Math.max(100, Math.min(180, canvas.height*0.28)),
        vx:0, vy:0, speed:1.9,
        minX:pad, maxX:()=>canvas.width-pad,
        minY:70 , maxY:()=>Math.min(Math.floor(canvas.height*0.55), 360),
        targetX:canvas.width/2, targetY:140, retarget:0,
        hp:260, maxHp:260, type:'dice', cooldown:0, form:1,
        face:1, faceTimer:0, spin:0, spinSpeed:0, dropMilestones:[0.8,0.55,0.3]
      };
      setBgm('s2_boss1');
    }
    sfx.boss();
  }

  function shoot(){
    if(player.power==='beam'){
      bullets.push({x:player.x-6,y:player.y-60,vx:0,vy:-18,type:'beam'});
      bullets.push({x:player.x+6,y:player.y-60,vx:0,vy:-18,type:'beam'});
    }else if(player.power==='spread'){
      bullets.push({x:player.x-18,y:player.y-40,vx:-2,vy:-13,type:'normal'});
      bullets.push({x:player.x   ,y:player.y-48,vx: 0,vy:-14,type:'normal'});
      bullets.push({x:player.x+18,y:player.y-40,vx: 2,vy:-13,type:'normal'});
    }else{
      bullets.push({x:player.x,y:player.y-48,vx:0,vy:-13,type:'normal'});
    }
    sfx.shoot();
  }
  let shootInterval=0;

  // 懺：長押し殲滅
  function handleZenStart(){
    if(!player.zenUnlocked) return;
    if(player.zenCooldown>0) return;
    player.zenCharging=true;
    zenVis.show=true; zenVis.alpha=0.22;
  }
  function handleZenRelease(){
    if(!player.zenUnlocked || !player.zenCharging) return;
    player.zenCharging=false;
    const charge=player.zenT;
    if(charge<250){ player.zenT=0; zenVis.show=false; zenVis.radius=0; return; }
    const ratio=clamp(charge/player.zenTMax,0,1);
    const radius=80 + 180*ratio;
    zenVis.radius=radius; zenVis.alpha=0.35;
    let killed=0, cleared=0;
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i]; const dx=e.x-player.x, dy=e.y-player.y;
      if(dx*dx+dy*dy<=radius*radius){ enemies.splice(i,1); spawnBurst(e.x,e.y,6); killed++; }
    }
    for(let i=enemyBullets.length-1;i>=0;i--){
      const b=enemyBullets[i]; const dx=b.x-player.x, dy=b.y-player.y;
      if(dx*dx+dy*dy<=radius*radius){ enemyBullets.splice(i,1); cleared++; }
    }
    if(boss){
      const r=(boss.type==='dice' ? (boss.form===1?52:60) : (boss.form===1?60:74));
      const dx=boss.x-player.x, dy=boss.y-player.y;
      if(dx*dx+dy*dy<=radius*radius){ boss.hp-=Math.round(18*ratio); spawnBurst(boss.x,boss.y,8); }
    }
    score += killed*150 + cleared*10;
    sfx.noise(0.5,0.35);
    player.zenCooldown=player.zenCooldownMax; player.zenT=0;
  }

  function applyItem(t){
    sfx.item();
    if(t==='spread'){ player.power='spread'; player.powerTimer=8000; overlayPower.textContent='パワーアップ：三連弾'; }
    else if(t==='beam'){ player.power='beam'; player.beamTimer=6000; overlayPower.textContent='パワーアップ：光束レーザー'; }
    else if(t==='heal'){ player.lives=Math.min(5,player.lives+1); overlayPower.textContent='ライフ回復'; }
    else if(t==='shield'){ player.power='shield'; player.powerTimer=7000; player.invul=1800; overlayPower.textContent='守護シールド展開'; }
    else if(t==='zen'){ player.zenUnlocked=true; overlayPower.textContent='新技能：懺（長押しで殲滅）'; zenHud.style.display=''; }
  }

  function damagePlayer(){ if(player.invul>0) return; player.lives-=1; player.invul=1500; spawnBurst(player.x,player.y,18); sfx.hit(); if(player.lives<=0) endGame(); }
  function spawnBurst(x,y,c){ for(let i=0;i<c;i++){ const a=Math.random()*Math.PI*2, s=1+Math.random()*3; particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:600+Math.random()*400}); } }
  function triggerVictoryFX(stg){ victoryFX.active=true; victoryFX.t=0; victoryFX.stage=stg; for(let i=0;i<120;i++){ const a=Math.random()*Math.PI*2, sp=2+Math.random()*5, col=i%2?1:0; particles.push({x:canvas.width/2,y:canvas.height*0.35,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:900+Math.random()*600,col}); } }

  // Update
  let intensityTimer=0;
  function update(delta){
    if(state!=='playing') return;
    backgroundScroll += delta*0.12;
    stageTimer += delta; spawnTimer += delta; shootInterval += delta; intensityTimer += delta;

    if(pointerActive){ player.x += (pointerX-player.x)*0.18; player.y += (pointerY-player.y)*0.12; }
    player.x=clamp(player.x,40,canvas.width-40);
    player.y=clamp(player.y,120,canvas.height-80);

    if(player.invul>0) player.invul-=delta;

    if(player.powerTimer>0){ player.powerTimer-=delta; if(player.powerTimer<=0 && player.power!=='normal'){ player.power='normal'; overlayPower.textContent=''; } }
    if(player.beamTimer>0){ player.beamTimer-=delta; if(player.beamTimer<=0 && player.power==='beam'){ player.power='normal'; overlayPower.textContent=''; } }

    if(player.zenCooldown>0) player.zenCooldown-=delta;
    if(player.zenCharging){
      player.zenT = clamp(player.zenT+delta, 0, player.zenTMax);
      const ratio=player.zenT/player.zenTMax; zenVis.radius = 60 + 220*ratio; zenVis.alpha = 0.18 + 0.20*ratio;
    }else if(zenVis.show){
      zenVis.alpha -= delta*0.0006; if(zenVis.alpha<=0){ zenVis.alpha=0; zenVis.show=false; }
    }

    if(shootInterval>120){ shoot(); shootInterval=0; }

    const spawnIv=(stage===1?680:460);
    if(!boss && spawnTimer>spawnIv){ spawnEnemy(); spawnTimer=0; }

    if(!boss){
      const targetMs=(stage===1?42000:52000);
      if(stageTimer>targetMs && !stageGoal){ stageGoal=true; spawnBoss(); }
    }

    for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx; b.y+=b.vy; if(b.type==='beam') b.vy=-22; if(b.y<-60) bullets.splice(i,1); }

    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i]; e.phase+=delta*0.0025;
      if(e.type==='zigzag'){ e.x+=Math.sin(e.phase*2.6)*3.4; e.y+=e.vy; }
      else if(e.type==='diver'){ if((e.phase%1)<0.02){ const a=Math.atan2(player.y-e.y, player.x-e.x); e.vx=Math.cos(a)*3.0; e.vy=Math.sin(a)*3.0; } e.x+=e.vx; e.y+=e.vy; }
      else if(e.type==='sniper'){ if(!e.stop && e.y<canvas.height*0.28){ e.stop=true; e.vy=0; } e.y+=e.vy; }
      else if(e.type==='orbiter'){ e.x+=Math.sin(e.phase*2.0)*2.6; e.y+=e.vy*0.9; }
      else if(e.type==='tank'){ e.y+=e.vy*0.8; }
      else { e.y+=e.vy; }

      e.shootTimer+=delta;
      if(e.type==='tank' && e.shootTimer>e.shootDelay){ e.shootTimer=0; const spread=(stage===2?[-0.28,0,0.28]:[-0.4,0,0.4]); for(const a of spread){ enemyBullets.push({x:e.x,y:e.y+12,vx:Math.sin(a)*2.8,vy:Math.cos(a)*2.8,type:'normal'}); } }
      if(e.type==='sniper' && e.stop && e.shootTimer>(stage===2?2400:1700)){ e.shootTimer=0; const a=Math.atan2(player.y-e.y, player.x-e.x); const sp=(stage===2?4.0:5.0); enemyBullets.push({x:e.x,y:e.y+10,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,type:'normal'}); }
      if(e.type==='orbiter' && e.shootTimer>(stage===2?2000:1400)){ e.shootTimer=0; const n=(stage===2?4:6), sp=2.6; for(let k=0;k<n;k++){ const a=(Math.PI*2/n)*k + e.phase*1.0; enemyBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,type:'normal'}); } }
      if((e.type==='straight'||e.type==='zigzag') && e.shootTimer> (e.type==='zigzag' ? (stage===2?1600:1300) : (stage===2?1800:1500))){ e.shootTimer=0; enemyBullets.push({x:e.x,y:e.y+10,vx:0,vy:(stage===2?3.9:4.6),type:'normal'}); }

      if(e.y>canvas.height+80 || e.x<-80 || e.x>canvas.width+80) enemies.splice(i,1);
    }

    if(boss){
      boss.cooldown-=delta;
      if(boss.type==='dice'){
        boss.faceTimer+=delta; if(boss.faceTimer>700){ boss.faceTimer=0; boss.face=1+Math.floor(Math.random()*6); }
        boss.retarget-=delta;
        const maxX=(typeof boss.maxX==='function')?boss.maxX():boss.maxX;
        const maxY=(typeof boss.maxY==='function')?boss.maxY():boss.maxY;
        if(boss.retarget<=0){
          boss.retarget=(boss.form===1?900:650);
          if(Math.random()<0.35){ boss.targetX=clamp(player.x, boss.minX, maxX); boss.targetY=clamp(player.y-80, boss.minY, maxY); }
          else { boss.targetX=rand(boss.minX,maxX); boss.targetY=rand(boss.minY,maxY); }
        }
        const ang=Math.atan2(boss.targetY-boss.y, boss.targetX-boss.x);
        const spd=(boss.form===1?boss.speed:boss.speed+0.6);
        boss.vx += (Math.cos(ang)*spd - boss.vx)*0.06;
        boss.vy += (Math.sin(ang)*spd - boss.vy)*0.06;
        boss.x+=boss.vx; boss.y+=boss.vy;
        boss.x=clamp(boss.x, boss.minX, maxX); boss.y=clamp(boss.y, boss.minY, maxY);
        if(boss.form===2){ boss.spinSpeed = lerp(boss.spinSpeed, 0.015, 0.05); boss.spin += boss.spinSpeed * delta; }
        else { boss.spinSpeed = lerp(boss.spinSpeed, 0.0, 0.05); }

        if(boss.cooldown<=0){
          boss.cooldown=(boss.form===1?820:620);
          const sp=(boss.form===1?3.2:3.8);
          if(boss.face===1){ [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=> enemyBullets.push({x:boss.x,y:boss.y,vx:dx*sp,vy:dy*sp,type:'boss'})); }
          else if(boss.face===2){ [[1,1],[-1,1],[1,-1],[-1,-1]].forEach(([dx,dy])=> enemyBullets.push({x:boss.x,y:boss.y,vx:dx*sp,vy:dy*sp,type:'boss'})); }
          else if(boss.face===3){ for(let i=0;i<8;i++){ const a=(Math.PI*2/8)*i; enemyBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,type:'boss'}); } }
          else if(boss.face===4){ const a=Math.atan2(player.y-boss.y, player.x-boss.x); for(const off of [-0.12,0,0.12]) enemyBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a+off)*sp,vy:Math.sin(a+off)*sp,type:'boss'}); }
          else if(boss.face===5){ const n=(boss.form===1?10:14); for(let i=0;i<n;i++){ const a=(Math.PI*2/n)*i + (boss.spin||0); enemyBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,type:'boss'}); } }
          else if(boss.face===6){ const a0=Math.atan2(player.y-boss.y, player.x-boss.x); for(let k=0;k<6;k++){ const a=a0 + (k-2.5)*0.12; enemyBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*(sp-0.4),vy:Math.sin(a)*(sp-0.4),type:'boss'}); } }
        }
      }else{
        const p=boss; p.phase=(p.phase||0)+(boss.form===1?delta*0.0016:delta*0.0024);
        if(p.form===1){ p.x=p.baseX+Math.sin(p.phase)*120; if(p.cooldown<=0){ p.cooldown=900; for(let a=-0.8;a<=0.8;a+=0.4){ enemyBullets.push({x:p.x,y:p.y+20,vx:Math.sin(a)*3.5,vy:Math.cos(a)*3.5,type:'boss'}); } } }
        else { p.x=p.baseX+Math.sin(p.phase*1.2)*150; p.y=p.baseY+Math.sin(p.phase*0.9)*16; if(p.cooldown<=0){ p.cooldown=520; for(let i=0;i<12;i++){ const a=(Math.PI*2/12)*i + p.phase*1.3; enemyBullets.push({x:p.x,y:p.y,vx:Math.cos(a)*4.0,vy:Math.sin(a)*4.0,type:'boss'}); } } }
      }
    }

    for(let i=enemyBullets.length-1;i>=0;i--){ const b=enemyBullets[i]; b.x+=b.vx; b.y+=b.vy; if(b.y>canvas.height+80 || b.x<-80 || b.x>canvas.width+80) enemyBullets.splice(i,1); }
    for(let i=items.length-1;i>=0;i--){ const it=items[i]; it.phase+=delta*0.0022; it.y+=it.vy; it.x+=Math.sin(it.phase)*1.8; if(it.y>canvas.height+40) items.splice(i,1); }
    for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life-=delta; p.x+=p.vx; p.y+=p.vy; if(p.life<=0) particles.splice(i,1); }

    bulletsLoop:
    for(let bi=bullets.length-1; bi>=0; bi--){
      const b=bullets[bi];
      for(let ei=enemies.length-1; ei>=0; ei--){
        const e=enemies[ei];
        if(Math.abs(b.x-e.x)<24 && Math.abs(b.y-e.y)<24){
          enemies.splice(ei,1); bullets.splice(bi,1);
          score+=120; if(Math.random()<0.18) spawnItem(e.x,e.y);
          spawnBurst(e.x,e.y,6); sfx.noise();
          break bulletsLoop;
        }
      }
      if(boss){
        const r=(boss.type==='dice' ? (boss.form===1?52:60) : (boss.form===1?60:74));
        if(Math.abs(b.x-boss.x)<r && Math.abs(b.y-boss.y)<r){
          bullets.splice(bi,1);
          boss.hp-=(b.type==='beam'?4:2);
          spawnBurst(boss.x,boss.y,2);
          if(boss.dropMilestones && boss.dropMilestones.length){
            const ratio=boss.hp/boss.maxHp;
            while(boss.dropMilestones.length && ratio<=boss.dropMilestones[0]){
              boss.dropMilestones.shift();
              const drops=1+(Math.random()<0.35?1:0);
              for(let k=0;k<drops;k++) spawnItem(boss.x+(Math.random()*60-30), boss.y+(Math.random()*40-20));
            }
          }
          if(boss.hp<=0){
            if(boss.form===1){
              sfx.evolve(); spawnBurst(boss.x,boss.y,28);
              boss.form=2; boss.maxHp=(boss.type==='dice'?280:240); boss.hp=boss.maxHp; boss.cooldown=0; boss.dropMilestones=[0.7,0.45,0.2];
              if(boss.type==='dice'){ boss.spinSpeed=0.008; boss.speed=2.6; setBgm('s2_boss2'); } else { setBgm('s1_boss2'); }
              showStageBanner('PHASE 2');
            }else{
              for(let k=0;k<3;k++) spawnItem(boss.x+(Math.random()*80-40), boss.y+(Math.random()*60-30));
              triggerVictoryFX(stage); sfx.noise(); sfx.clear(); sfx.fanfare();
              score+=4000; boss=null; stageGoal=false; enemies.length=0; enemyBullets.length=0;

              if(stage===1){
                // 直接ステージ2へ（インタールード廃止）
                setTimeout(()=>{ stage=2; stageTimer=0; spawnTimer=0; setBgm('s2_stage'); state='playing'; showStageBanner('STAGE 2'); }, 900);
              }else{
                setTimeout(()=>winGame(), 1200);
              }
            }
          }
        }
      }
    }

    for(let ei=enemies.length-1; ei>=0; ei--){ const e=enemies[ei]; if(Math.abs(player.x-e.x)<40 && Math.abs(player.y-e.y)<40){ enemies.splice(ei,1); damagePlayer(); break; } }
    for(let i=enemyBullets.length-1; i>=0; i--){ const b=enemyBullets[i]; if(Math.abs(player.x-b.x)<26 && Math.abs(player.y-b.y)<26){ enemyBullets.splice(i,1); damagePlayer(); } }
    for(let ii=items.length-1; ii>=0; ii--){ const it=items[ii]; if(Math.abs(player.x-it.x)<36 && Math.abs(player.y-it.y)<36){ applyItem(it.type); items.splice(ii,1); } }

    if(boss && boss.type==='dice'){
      const r=(boss.form===1?52:60);
      if(Math.abs(player.x-boss.x)<r && Math.abs(player.y-boss.y)<r && player.invul<=0){
        score=Math.max(0, score-500); player.invul=900; spawnBurst(player.x,player.y,12); sfx.hit(); updateUI();
      }
    }

    if(intensityTimer>500){
      intensityTimer=0;
      let norm=0.0;
      if(!boss){
        const eCount=Math.min(enemies.length, 18)/18;
        const lifeFactor=(5-player.lives)/5;
        norm=clamp(0.2*eCount + 0.3*lifeFactor + 0.1*(player.zenCharging?1:0), 0, 1);
      }else{
        norm=clamp(1 - boss.hp/boss.maxHp, 0, 1);
      }
      setAdaptiveIntensity(norm);
    }

    updateUI();
  }

  /* ===== /PART 2/3 ===== */
  </script>
  <!-- PART 3/3：Drawing／Loop／SelfTests（豪華化した白黒背景） -->
  <script>
  /* ===== PART 3/3 ===== */

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground(); // ← ステージに応じて豪華化

    if(state==='playing'){
      if(zenVis.show){
        ctx.save(); ctx.globalAlpha = zenVis.alpha; ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(player.x, player.y, zenVis.radius, 0, Math.PI*2); ctx.fill(); ctx.restore();
      }
      const flicker = player.invul>0 && Math.floor(performance.now()/120)%2===0;
      if(!flicker) drawPlayer();
    }

    bullets.forEach(drawBullet);
    enemies.forEach(drawEnemy);
    if(boss) drawBoss(boss);
    enemyBullets.forEach(drawEnemyBullet);
    items.forEach(drawItem);
    particles.forEach(drawParticle);

    if(victoryFX.active) drawVictoryFX();
  }

  // ===== 豪華化・白黒背景 =====
  function drawBackground(){
    const w=canvas.width, h=canvas.height, t=performance.now()*0.001;
    // 1) ベース縦グラデ（S1控えめ / S2コントラスト強）
    const g=ctx.createLinearGradient(0,0,0,h);
    const s2 = (stage>=2);
    g.addColorStop(0, s2?'#0e0e0e':'#111');
    g.addColorStop(1, '#000');
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);

    // 2) 星屑ストリーク（S1：少 / S2：密でレイヤー2枚）
    const rows1 = s2?110:70;
    ctx.fillStyle='rgba(255,255,255,0.06)';
    for(let i=0;i<rows1;i++){
      const y=(backgroundScroll*0.4 + i*(h/rows1))%h;
      ctx.fillRect((i*37.3)%w, y, 2, 16);
    }
    if(s2){
      ctx.fillStyle='rgba(255,255,255,0.035)';
      for(let i=0;i<90;i++){
        const y=(backgroundScroll*0.6 + i*(h/90))%h;
        ctx.fillRect((i*53.7 + 25)%w, y, 1.5, 22);
      }
    }

    // 3) 幾何パターン（S2で追加：斜めライン＋微パララックス）
    if(s2){
      ctx.save();
      ctx.globalAlpha=0.06;
      ctx.translate(w/2, h/2);
      ctx.rotate(0.1*Math.sin(t*0.2));
      const spacing=28;
      ctx.beginPath();
      for(let x=-w;x<=w;x+=spacing){ ctx.moveTo(x,-h); ctx.lineTo(x,h); }
      for(let y=-h;y<=h;y+=spacing){ ctx.moveTo(-w,y); ctx.lineTo(w,y); }
      ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke();
      ctx.restore();
    }

    // 4) 放射リング（ボス中はやや強調）
    const bossing = !!boss;
    const ringAlpha = s2 ? (bossing?0.12:0.08) : (bossing?0.08:0.05);
    const cx=w/2, cy=h*0.35;
    ctx.save();
    ctx.globalAlpha=ringAlpha;
    ctx.strokeStyle='#fff'; ctx.lineWidth=1;
    const Rmax=Math.hypot(w,h)*0.6;
    for(let r=60;r<Rmax;r+=60){
      ctx.beginPath(); ctx.arc(cx,cy,r + Math.sin(t*0.6+r*0.02)*2.0, 0, Math.PI*2); ctx.stroke();
    }
    ctx.restore();

    // 5) 微細ノイズディザ（S2のみ）
    if(s2){
      ctx.save();
      ctx.globalAlpha=0.02;
      const cell=4;
      for(let y=0;y<h;y+=cell){
        for(let x=0;x<w;x+=cell){
          if(((x^y)&15)===0) ctx.fillRect(x,y,1,1);
        }
      }
      ctx.restore();
    }

    // 6) ビネット（周辺減光：S2で強め）
    const vg=ctx.createRadialGradient(w/2,h/2, Math.min(w,h)*0.2, w/2,h/2, Math.max(w,h)*0.7);
    vg.addColorStop(0,'rgba(0,0,0,0)');
    vg.addColorStop(1, s2?'rgba(0,0,0,0.38)':'rgba(0,0,0,0.28)');
    ctx.fillStyle=vg; ctx.fillRect(0,0,w,h);
  }

  function drawPlayer(){
    ctx.save();
    ctx.translate(player.x,player.y);
    ctx.fillStyle='#fff';
    ctx.beginPath();
    ctx.moveTo(0,-28); ctx.lineTo(20,20); ctx.lineTo(0,10); ctx.lineTo(-20,20); ctx.closePath();
    ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,0.9)'; ctx.lineWidth=2; ctx.stroke();
    if(player.power==='shield'){ ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,-2,34,0,Math.PI*2); ctx.stroke(); }
    ctx.restore();
  }

  function drawBullet(b){ ctx.save(); ctx.translate(b.x,b.y); ctx.fillStyle=(b.type==='beam')?'#fefefe':'#fff'; ctx.fillRect(-3,-12,6,20); ctx.restore(); }

  function drawEnemy(e){
    ctx.save(); ctx.translate(e.x,e.y);
    ctx.strokeStyle='#000'; ctx.lineWidth=2;
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.beginPath();
    if(e.type==='tank'){ ctx.rect(-26,-18,52,36); }
    else if(e.type==='diver'){ ctx.moveTo(0,-22); ctx.lineTo(18,18); ctx.lineTo(-18,18); ctx.closePath(); }
    else if(e.type==='sniper'){ ctx.moveTo(-20,-14); ctx.lineTo(20,-14); ctx.lineTo(12,14); ctx.lineTo(-12,14); ctx.closePath(); }
    else if(e.type==='orbiter'){ ctx.arc(0,0,18,0,Math.PI*2); }
    else if(e.type==='zigzag'){ ctx.moveTo(-18,-18); ctx.lineTo(18,-18); ctx.lineTo(24,18); ctx.lineTo(-24,18); ctx.closePath(); }
    else { ctx.rect(-18,-14,36,28); }
    ctx.fill(); ctx.stroke();
    if(e.type==='tank' || e.type==='orbiter'){ ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.stroke(); }
    ctx.restore();
  }

  function drawBoss(b){
    if(b.type==='dice'){
      const size=(b.form===1?56:64);
      if(b.form===2){
        const puls = 0.5 + 0.5*Math.sin((performance.now()/240)%Math.PI*2);
        ctx.save(); ctx.translate(b.x,b.y);
        ctx.globalAlpha=0.15+0.15*puls; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(0,0,size*0.95+18*puls,0,Math.PI*2); ctx.stroke();
        ctx.globalAlpha=0.08+0.08*puls; ctx.beginPath(); ctx.arc(0,0,size*0.95+36*puls,0,Math.PI*2); ctx.stroke();
        ctx.restore();
      }
      ctx.save(); ctx.translate(b.x,b.y); if(b.form===2) ctx.rotate(b.spin||0);
      ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.strokeStyle='#000'; ctx.lineWidth=4;
      if(b.form===1){ ctx.beginPath(); ctx.rect(-size/2,-size/2,size,size); ctx.fill(); ctx.stroke(); }
      else{ const r=size*0.18, w=size, h=size; roundRect(ctx,-w/2,-h/2,w,h,r); ctx.fill(); ctx.stroke(); ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=2; roundRect(ctx,-w/2+6,-h/2+6,w-12,h-12,r*0.8); ctx.stroke(); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1.5; for(let i=0;i<4;i++){ const ang=i*Math.PI/2, cx=Math.cos(ang)*(w/2-r), cy=Math.sin(ang)*(h/2-r); ctx.beginPath(); ctx.arc(cx,cy,r,ang-0.7,ang+0.7); ctx.stroke(); } }
      const pipR=(size>60?5:4);
      const drawPip=(px,py,a=1)=>{ ctx.save(); ctx.globalAlpha=a; if(b.form===1){ ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(px,py,pipR,0,Math.PI*2); ctx.fill(); } else { ctx.fillStyle='#000'; roundRect(ctx,px-pipR,py-pipR,pipR*2,pipR*2,2.5); ctx.fill(); ctx.fillStyle='rgba(255,255,255,0.15)'; roundRect(ctx,px-pipR+1,py-pipR+1,pipR*2-2,pipR*2-2,2.0); ctx.fill(); } ctx.restore(); };
      const d=size*0.22, layouts={1:[[0,0]],2:[[-d,-d],[ d, d]],3:[[-d,-d],[0,0],[ d, d]],4:[[-d,-d],[ d,-d],[-d, d],[ d, d]],5:[[-d,-d],[ d,-d],[ 0, 0],[-d, d],[ d, d]],6:[[-d,-d],[ d,-d],[-d,0],[ d,0],[-d, d],[ d, d]]};
      const arr=(layouts[b.face]||layouts[1]); const flick=(b.form===2)?(0.8+0.2*Math.sin((performance.now()/180)%Math.PI*2)):1; arr.forEach(([px,py])=>drawPip(px,py,flick));
      if(b.form===2){ ctx.globalAlpha=0.12; ctx.strokeStyle='#000'; ctx.lineWidth=1.2; for(let i=0;i<8;i++){ const ang=i*Math.PI/4; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(ang)*(size/2-6), Math.sin(ang)*(size/2-6)); ctx.stroke(); } ctx.globalAlpha=1; }
      ctx.restore();
      ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.fillRect(canvas.width/2-160,40,320,14);
      ctx.fillStyle='#fff'; ctx.fillRect(canvas.width/2-160,40,(b.hp/b.maxHp)*320,14);
      ctx.strokeStyle='#000'; ctx.strokeRect(canvas.width/2-160,40,320,14);
      return;
    }
    // sentinel
    ctx.save(); ctx.translate(b.x,b.y); const r=b.form===1?60:74;
    ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#000'; ctx.lineWidth=4; ctx.stroke(); ctx.fillStyle='#000'; ctx.fillRect(-10,-r*0.3,20,r*0.6);
    if(b.form===2){ ctx.strokeStyle='rgba(255,255,255,0.65)'; ctx.lineWidth=2; for(let i=0;i<12;i++){ const a=(Math.PI*2/12)*i + (b.phase||0)*2; ctx.beginPath(); ctx.moveTo(Math.cos(a)*r,Math.sin(a)*r); ctx.lineTo(Math.cos(a)*(r+16),Math.sin(a)*(r+16)); ctx.stroke(); } ctx.globalAlpha=0.15; ctx.beginPath(); ctx.arc(0,0,r+22,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
    ctx.restore();
    ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.fillRect(canvas.width/2-160,40,320,14);
    ctx.fillStyle='#fff'; ctx.fillRect(canvas.width/2-160,40,(b.hp/b.maxHp)*320,14);
    ctx.strokeStyle='#000'; ctx.strokeRect(canvas.width/2-160,40,320,14);
  }

  function drawEnemyBullet(b){ ctx.save(); ctx.translate(b.x,b.y); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(0,0,b.type==='boss'?7:5,0,Math.PI*2); ctx.fill(); ctx.restore(); }

  function drawItem(it){
    ctx.save(); ctx.translate(it.x,it.y);
    ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.rect(-16,-16,32,32); ctx.stroke();
    ctx.fillStyle='#fff'; ctx.font='16px "Noto Sans JP", sans-serif';
    let text=''; switch(it.type){ case 'spread': text='三'; break; case 'beam': text='光'; break; case 'heal': text='＋'; break; case 'shield': text='盾'; break; case 'zen': text='懺'; break; }
    const m=ctx.measureText(text); ctx.fillText(text,-m.width/2,6);
    ctx.restore();
  }

  function drawParticle(p){ ctx.save(); const a=Math.max(0,p.life/900); const col=(p.col===0)?'0,0,0':'255,255,255'; ctx.fillStyle=`rgba(${col},${a.toFixed(2)})`; ctx.fillRect(p.x,p.y,3,3); ctx.restore(); }

  function drawVictoryFX(){
    victoryFX.t += 16.6; const t=victoryFX.t; const flash=Math.max(0,1 - t/300);
    if(flash>0){ ctx.save(); ctx.globalAlpha=flash*0.7; ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); }
    for(let i=0;i<4;i++){ const rr=t*0.4 + i*26; const a=Math.max(0,1 - (t-i*80)/400); if(a<=0) continue; ctx.save(); ctx.globalAlpha=a*0.6; ctx.strokeStyle=i%2?'#fff':'#000'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(canvas.width/2,canvas.height*0.35,rr,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
    ctx.save(); ctx.globalAlpha=Math.max(0,1 - t/900); ctx.lineWidth=2; for(let i=0;i<36;i++){ const ang=(Math.PI*2/36)*i, len=80+t*0.2; ctx.strokeStyle=i%2?'#fff':'#000'; ctx.beginPath(); ctx.moveTo(canvas.width/2 + Math.cos(ang)*20, canvas.height*0.35 + Math.sin(ang)*20); ctx.lineTo(canvas.width/2 + Math.cos(ang)*(20+len), canvas.height*0.35 + Math.sin(ang)*(20+len)); ctx.stroke(); } ctx.restore(); if(t>1000) victoryFX.active=false;
  }

  // Flow
  function endGame(){ state='gameover'; stopBgm(); gameOver.style.display='flex'; gameOver.querySelector('h2').textContent='GAME OVER'; finalScore.textContent=score; }
  function winGame(){ state='gameclear'; stopBgm(); sfx.fanfare(); gameOver.style.display='flex'; gameOver.querySelector('h2').textContent='GAME CLEAR'; finalScore.textContent=score+' (WHITE WORLD CLEAR)'; }

  function loop(timestamp){
    requestAnimationFrame(loop);
    if(!lastTime) lastTime=timestamp;
    const delta=timestamp-lastTime; lastTime=timestamp;
    if(state==='playing' && titleScreen.style.display!=='none'){ titleScreen.style.display='none'; }
    update(delta); draw();
  }
  let lastTime=0; requestAnimationFrame(loop);

  function startGame(){
    testsLocked=true;
    resetGame(); state='playing';
    titleScreen.style.display='none'; gameOver.style.display='none';
    showStageBanner('STAGE 1');
  }

  startBtn.addEventListener('click',()=>{ initAudio(); startGame(); });
  restartBtn.addEventListener('click',()=>{ initAudio(); startGame(); });
  addEventListener('keydown',e=>{ if(e.key===' ' && state==='title'){ initAudio(); startGame(); } if(e.key==='m'){ toggleBgm(); } });

  (function runSelfTests(){
    try{
      const snap={stage,boss,mode:bgm.mode,state,titleDisp:titleScreen.style.display,overDisp:gameOver.style.display,h2:document.querySelector('#gameOver h2').textContent};
      stage=1; spawnBoss(); console.assert(boss,'Stage1 boss');
      boss=null; stage=2; spawnBoss(); console.assert(boss && bgm.mode==='s2_boss1','Stage2 boss music set');
      setBgm('s2_stage'); console.assert(bgm.mode==='s2_stage','S2 normal music');
      if(!testsLocked){ state=snap.state; titleScreen.style.display=snap.titleDisp; gameOver.style.display=snap.overDisp; document.querySelector('#gameOver h2').textContent=snap.h2; boss=snap.boss; stage=snap.stage; try{ setBgm(snap.mode||'s1_stage'); }catch{} }
      console.log('SelfTests ok');
    }catch(e){ console.warn('SelfTests failed',e); }
  })();

  function roundRect(ctx,x,y,w,h,r){
    const rr=Math.max(0,Math.min(r,Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.lineTo(x+w-rr,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
    ctx.lineTo(x+w,y+h-rr);
    ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    ctx.lineTo(x+rr,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
    ctx.lineTo(x,y+rr);
    ctx.quadraticCurveTo(x,y,x+rr,y);
  }

  /* ===== /PART 3/3 ===== */
  </script>
</body>
</html>
