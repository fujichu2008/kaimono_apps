<!-- 白黒シューター 改（Stage2 BGMを確実に実装：通常は静寂×多音階、ボスはNier風ドラム動機） PART 1/3 -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>白黒シューター - Stage2 BGM強化</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;font-family:"Noto Sans JP",system-ui,sans-serif;-webkit-user-select:none;user-select:none}
    body{background:#000;color:#fff;overflow:hidden;touch-action:none}
    canvas{display:block;margin:0 auto;background:#000}
    #overlay{position:absolute;top:20px;left:20px;z-index:10;display:flex;flex-direction:column;gap:12px;color:#fff;text-shadow:0 0 6px rgba(255,255,255,.6)}
    #overlay .row{display:flex;gap:24px;font-size:18px}
    #powerup{font-size:16px;color:#dedede}
    #titleScreen,#gameOver{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(circle at 50% 40%,rgba(255,255,255,.12),rgba(0,0,0,.92));color:#fff;text-align:center;z-index:30}
    #titleScreen h1{font-size:42px;letter-spacing:6px;margin-bottom:16px;text-shadow:0 0 15px rgba(255,255,255,.8)}
    #titleScreen p{max-width:460px;line-height:1.6;margin-bottom:28px;color:#ccc}
    .btn{border:2px solid #fff;background:rgba(255,255,255,.08);color:#fff;padding:14px 36px;font-size:18px;letter-spacing:4px;cursor:pointer;transition:background .2s,border .2s;}
    .btn:hover{background:rgba(255,255,255,.2);}
    #gameOver{display:none}
    #gameOver h2{font-size:40px;margin-bottom:16px;letter-spacing:8px;text-transform:uppercase}
    #gameOver p{font-size:20px;margin-bottom:24px;color:#d9d9d9}
    #stageBanner{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:18px 38px;border:1px solid rgba(255,255,255,.8);color:#000;background:rgba(255,255,255,.85);font-size:32px;letter-spacing:8px;display:none;z-index:25;text-shadow:none}
    #muteBtn{position:absolute;top:20px;right:20px;z-index:12;border:1px solid #fff;background:rgba(255,255,255,.08);color:#fff;padding:8px 16px;font-size:12px;letter-spacing:2px;cursor:pointer}
  </style>
</head>
<body>
  <div id="titleScreen">
    <h1>白黒シューター</h1>
    <p>Stage2は「静寂×スタイリッシュ×不気味」を多音階で、ボスはNier風ドラム動機に音色を重ねた専用曲で演出します。</p>
    <button class="btn" id="startBtn">START</button>
  </div>
  <div id="stageBanner"></div>
  <div id="overlay">
    <div class="row">
      <div>STAGE: <span id="stage">1</span>/2</div>
      <div>スコア: <span id="score">000000</span></div>
      <div>ライフ: <span id="life">3</span></div>
    </div>
    <div id="powerup"></div>
  </div>
  <button id="muteBtn">BGM: ON</button>
  <div id="gameOver">
    <h2>GAME OVER</h2>
    <p>FINAL SCORE: <span id="finalScore">0</span></p>
    <button class="btn" id="restartBtn">RESTART</button>
  </div>
  <canvas id="game"></canvas>

  <script>
  /* ===== PART 1/3: DOM & AUDIO（Stage1既存曲 + Stage2：通常/ボス1/ボス2の専用BGM）===== */
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
  const overlayPower=document.getElementById('powerup'); const scoreEl=document.getElementById('score');
  const lifeEl=document.getElementById('life'); const stageEl=document.getElementById('stage');
  const titleScreen=document.getElementById('titleScreen'); const gameOver=document.getElementById('gameOver');
  const finalScore=document.getElementById('finalScore'); const stageBanner=document.getElementById('stageBanner');
  const startBtn=document.getElementById('startBtn'); const restartBtn=document.getElementById('restartBtn');
  const muteBtn=document.getElementById('muteBtn');

  function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; } addEventListener('resize',resize); resize();

  // ===== Audio Core =====
  let audioCtx=null, masterGain=null, bgmMuted=false;
  let bgm={ mode:'silence', parts:[], timers:[], bus:null, beatTimer:null };

  function initAudio(){ if(audioCtx) return;
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    masterGain=audioCtx.createGain(); masterGain.gain.value=0.12; masterGain.connect(audioCtx.destination);
  }
  function makeBus(){
    const input=audioCtx.createGain(); input.gain.value=1.0;
    const low=audioCtx.createBiquadFilter(); low.type='lowpass'; low.frequency.value=2400; low.Q.value=0.7;
    const del=audioCtx.createDelay(1.0); del.delayTime.value=0.26; const fb=audioCtx.createGain(); fb.gain.value=0.24;
    const del2=audioCtx.createDelay(1.0); del2.delayTime.value=0.41; const fb2=audioCtx.createGain(); fb2.gain.value=0.18;
    input.connect(low); low.connect(masterGain);
    low.connect(del); del.connect(fb).connect(del); del.connect(masterGain);
    low.connect(del2); del2.connect(fb2).connect(del2); del2.connect(masterGain);
    return {input,low,del,fb,del2,fb2};
  }
  function stopBgm(){
    if(!audioCtx) return;
    if(bgm.beatTimer){ clearInterval(bgm.beatTimer); bgm.beatTimer=null; }
    bgm.timers.forEach(id=>clearInterval(id)); bgm.timers.length=0;
    bgm.parts.forEach(n=>{ try{ n.stop&&n.stop(); n.disconnect&&n.disconnect(); }catch{} });
    bgm.parts.length=0;
    try{ bgm.bus?.input.disconnect(); }catch{}
    bgm.mode='silence';
  }
  function toggleBgm(){
    if(!audioCtx) initAudio();
    bgmMuted=!bgmMuted;
    masterGain.gain.linearRampToValueAtTime(bgmMuted?0:0.12, audioCtx.currentTime+0.25);
    muteBtn.textContent=bgmMuted?'BGM: OFF':'BGM: ON';
  }
  muteBtn.addEventListener('click',()=>{ initAudio(); toggleBgm(); });

  // ===== Tiny bell (共通) =====
  function bell(bus, freq, vel=0.12){
    const c=audioCtx.createOscillator(); c.type='sine'; c.frequency.value=freq;
    const m=audioCtx.createOscillator(); m.type='sine'; m.frequency.value=freq*2.01;
    const mg=audioCtx.createGain(); mg.gain.value=20;
    const lp=audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2200; lp.Q.value=0.4;
    const g=audioCtx.createGain(); g.gain.value=0.0001;
    m.connect(mg).connect(c.frequency); c.connect(lp).connect(g).connect(bgm.bus.input);
    const t=audioCtx.currentTime; g.gain.setValueAtTime(0.0001,t);
    g.gain.exponentialRampToValueAtTime(vel, t+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t+1.2);
    c.start(t); m.start(t); c.stop(t+1.4); m.stop(t+1.4);
    return [c,m,mg,lp,g];
  }

  // ===== Stage1（既存：曲らしい進行） =====
  function setBgm(mode){
    if(!audioCtx) initAudio();
    if(bgm.mode===mode) return;
    stopBgm();
    // Stage2は専用エンジンへ
    if(mode.startsWith('s2_')) return setBgmS2(mode);

    bgm.mode = mode; bgm.bus = makeBus();
    const A4=440, toHz=semi=>A4*Math.pow(2,semi/12);
    const scenes = {
      s1_stage: { tempo:112, root:-10, chordA:[0,5,7,5], chordB:[-2,3,5,3], leadA:[0,2,5,7,9,7,5,2], leadB:[0,3,5,7,10,7,5,3] },
      s1_boss1:{ tempo:126, root: -8, chordA:[0,4,7,4], chordB:[-1,3,7,3], leadA:[0,2,3,5,7,5,3,2], leadB:[0,3,5,7,8,7,5,3] },
      s1_boss2:{ tempo:140, root: -7, chordA:[0,3,7,10], chordB:[0,5,10,7], leadA:[0,3,6,10,6,3,0,-2], leadB:[0,2,5,7,10,7,5,2] }
    };
    const sc=scenes[mode]||scenes.s1_stage;

    // drums
    function hat(v=0.1){ const t=audioCtx.currentTime;
      const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.06,audioCtx.sampleRate), d=b.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,8);
      const s=audioCtx.createBufferSource(); s.buffer=b;
      const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
      const g=audioCtx.createGain(); g.gain.value=v; s.connect(hp).connect(g).connect(bgm.bus.input); s.start(t);
    }
    function kick(v=0.16){ const t=audioCtx.currentTime+0.003;
      const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine';
      o.frequency.setValueAtTime(110,t); o.frequency.exponentialRampToValueAtTime(50,t+0.09);
      g.gain.value=v; g.gain.exponentialRampToValueAtTime(0.0001,t+0.12);
      o.connect(g).connect(bgm.bus.input); o.start(t); o.stop(t+0.14);
    }
    function snare(v=0.18){ const t=audioCtx.currentTime;
      const o=audioCtx.createOscillator(); o.type='triangle'; o.frequency.value=220;
      const n=audioCtx.createBuffer(1,audioCtx.sampleRate*0.1,audioCtx.sampleRate), d=n.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,6);
      const ns=audioCtx.createBufferSource(); ns.buffer=n;
      const g=audioCtx.createGain(); g.gain.value=v; const g2=audioCtx.createGain(); g2.gain.value=v*0.6;
      o.connect(g).connect(bgm.bus.input); ns.connect(g2).connect(bgm.bus.input);
      o.start(t); o.stop(t+0.09); ns.start(t); ns.stop(t+0.1);
    }
    const toF=semi=>toHz(sc.root+semi);
    function chord(root){ [0,4,7,12].forEach(iv=>{ const o=audioCtx.createOscillator(); o.type='triangle'; o.frequency.value=toF(root+iv);
      const g=audioCtx.createGain(); g.gain.value=0.0001; o.connect(g).connect(bgm.bus.input);
      const t=audioCtx.currentTime; g.gain.exponentialRampToValueAtTime(0.12,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.3);
      o.start(t); o.stop(t+0.32);
    });}
    function lead(semi,vel=0.2){ const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=toF(semi+12);
      const g=audioCtx.createGain(); g.gain.value=0.0001; o.connect(g).connect(bgm.bus.input);
      const t=audioCtx.currentTime; g.gain.exponentialRampToValueAtTime(vel,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.22);
      o.start(t); o.stop(t+0.24);
    }

    const bpm=sc.tempo, beat=60/bpm, tick=beat/4; let i=0, sect=0;
    bgm.beatTimer=setInterval(()=>{
      const bar=Math.floor(i/4)%8, beatI=i%4;
      if(beatI===0) kick(0.16); if(beatI===2) snare(0.18); hat(0.09);
      const ch=(sect%2?sc.chordB:sc.chordA)[Math.floor(bar/2)%4];
      if(beatI===0) chord(ch);
      const ld=(sect%2?sc.leadB:sc.leadA)[bar%8];
      if(i%2===1) { lead(ch+ld,0.18); if(Math.random()<0.2) bgm.parts.push(...bell(bgm.bus, toF(ch+ld+24),0.14)); }
      if(bar===7 && beatI===3) sect++;
      i=(i+1)%64;
    }, tick*1000);
  }

  // ===== Stage2 BGM：通常は静寂を強調し多音階、ボスはNier風ドラム動機に音色重ね =====
  function setBgmS2(mode){
    bgm.mode=mode; bgm.bus=makeBus();
    const A4=440, toHz=semi=>A4*Math.pow(2,semi/12);
    const cfg = {
      s2_stage: { tempo:86,  hatEvery:2 },
      s2_boss1:{ tempo:110, hatEvery:1 },
      s2_boss2:{ tempo:122, hatEvery:1 }
    }[mode];

    /* --- 共通パーツ --- */
    function noiseHat(vol=0.08){ const t=audioCtx.currentTime;
      const b=audioCtx.createBuffer(1,audioCtx.sampleRate*0.05,audioCtx.sampleRate), d=b.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,9);
      const s=audioCtx.createBufferSource(); s.buffer=b; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=7000;
      const g=audioCtx.createGain(); g.gain.value=vol; s.connect(hp).connect(g).connect(bgm.bus.input); s.start(t);
    }
    function tunedKick(noteHz=70, vol=0.18){ const t=audioCtx.currentTime+0.002;
      const o=audioCtx.createOscillator(); o.type='sine'; const g=audioCtx.createGain(); g.gain.value=vol;
      o.frequency.setValueAtTime(noteHz*1.8,t); o.frequency.exponentialRampToValueAtTime(noteHz,t+0.1);
      g.gain.exponentialRampToValueAtTime(0.0001,t+0.14); o.connect(g).connect(bgm.bus.input); o.start(t); o.stop(t+0.16);
    }
    function tom(noteHz=120, vol=0.15){ const t=audioCtx.currentTime+0.002;
      const o=audioCtx.createOscillator(); o.type='triangle'; const g=audioCtx.createGain(); g.gain.value=vol;
      o.frequency.setValueAtTime(noteHz*1.2,t); o.frequency.exponentialRampToValueAtTime(noteHz,t+0.08);
      g.gain.exponentialRampToValueAtTime(0.0001,t+0.12); o.connect(g).connect(bgm.bus.input); o.start(t); o.stop(t+0.14);
    }
    function shortPluck(freq, vel=0.10, len=0.18){
      const t=audioCtx.currentTime;
      const o=audioCtx.createOscillator(); o.type='square'; o.frequency.value=freq;
      const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1400; f.Q.value=0.9;
      const g=audioCtx.createGain(); g.gain.value=0.0001;
      o.connect(f).connect(g).connect(bgm.bus.input);
      g.gain.exponentialRampToValueAtTime(vel, t+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t+len);
      o.start(t); o.stop(t+len+0.02);
    }
    function airyPad(freq, len=1.2, vol=0.05){
      const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=freq;
      const g=audioCtx.createGain(); g.gain.value=0.0001; o.connect(g).connect(bgm.bus.input);
      const t=audioCtx.currentTime; g.gain.linearRampToValueAtTime(vol, t+0.4); g.gain.linearRampToValueAtTime(0.0001, t+len);
      o.start(t); o.stop(t+len+0.05);
    }

    const beat=60/cfg.tempo; const tick=beat/2; // ♪＝8分
    let i=0, bar=0, phrase=0, transpose=0;

    /* --- Stage2 通常：静寂×多音階（和声は薄く、音階はペンタ×フリジアンを交錯） --- */
    if(mode==='s2_stage'){
      const root=-9; // D-ish
      const pent=[0,2,5,7,9];           // Dペンタ
      const phry=[0,1,3,5,7,8,10];      // Dフリジアン
      const seq=[pent,phry,pent,phry];
      // ごく薄いパッドのドローン（静寂を保ちつつ不穏）
      const drone=audioCtx.createOscillator(); drone.type='sine'; drone.frequency.value=toHz(root-24);
      const dg=audioCtx.createGain(); dg.gain.value=0.02; drone.connect(dg).connect(bgm.bus.input); drone.start();
      bgm.parts.push({stop:()=>{try{drone.stop();}catch{}},disconnect:()=>{try{drone.disconnect();}catch{}}});

      bgm.beatTimer=setInterval(()=>{
        if(i%cfg.hatEvery===0 && Math.random()<0.4) noiseHat(0.06);

        // 2拍に1音、交互にペンタとフリジアンから選び、上下2声でうっすら
        if(i%2===0){
          const scale=seq[Math.floor(bar/4)%seq.length];
          const step=scale[Math.floor(Math.random()*scale.length)];
          const sem=root+transpose+step;
          shortPluck(toHz(sem+12), 0.11, 0.16);
          if(Math.random()<0.7) airyPad(toHz(sem-12), 1.1, 0.035);
          if(Math.random()<0.25) bgm.parts.push(...bell(bgm.bus, toHz(sem+24), 0.11));
        }

        // ときおり無音の小節を作って「間」を強調
        if(bar%8===6 && i%4===0 && Math.random()<0.5){
          // 何もしない＝静寂の呼吸
        }

        // 16拍で軽く転調（上げたり下げたり）
        if(i%16===0 && i>0){ phrase++; transpose = [0,1,0,-1][phrase%4]; }

        i=(i+1)%64; if(i%8===0) bar=(bar+1)%16;
      }, tick*1000);
      return;
    }

    /* --- Stage2 ボス：Nier風ドラム動機＋音色重ね --- */
    // 「ダンッ ダッダダダダダッダッダン …」を16分基準で一小節=16に写像
    // 例パターン（K=キック/T=タム/H=ハット）:  K - T T T T T - T - T T T T T -
    const pattern = [ // 0..15
      'K','-','T','T','T','T','T','-','T','-','T','T','T','T','T','-'
    ];
    // ボス2は密度と音程上下を増やす
    const isP2 = (mode==='s2_boss2');

    bgm.beatTimer=setInterval(()=>{
      // ハット
      if(i%cfg.hatEvery===0) noiseHat(isP2?0.10:0.08);

      // ドラム動機
      const step=pattern[i%16];
      if(step==='K'){
        tunedKick(isP2?78:72, isP2?0.22:0.2);
      }else if(step==='T'){
        // 交互にピッチを変えて「旋律的ドラム」に
        const seqHz = isP2 ? [140,170,150,185,160] : [130,155,140,170];
        const hz = seqHz[(i+Math.floor(bar/2))%seqHz.length];
        tom(hz, isP2?0.18:0.16);
      }

      // ベースの短い突き（動機の強拍に）
      if(step==='K' || (isP2 && (i%4===2))){
        const baseSemi = -9 - 24 + (isP2? ( (bar%4===0)?0: -2 ) : 0);
        shortPluck(toHz(baseSemi), 0.12, 0.14);
      }

      // 上物：金属パッドとベルを控えめにレイヤー
      if(i%4===1){
        const root=-9; const phry=[0,1,3,5,7,8,10];
        const p=phry[Math.floor(Math.random()*phry.length)];
        const freq=toHz(root+p+12 + (isP2? (bar%2?1:0):0));
        airyPad(freq, isP2?0.9:1.0, isP2?0.055:0.045);
        if(Math.random()< (isP2?0.35:0.22)) bgm.parts.push(...bell(bgm.bus, toHz(root+p+24), isP2?0.16:0.13));
      }

      // 小節進行と展開
      i=(i+1)%16; if(i===0){ bar++; if(bar%8===0){ transpose=(transpose+1)%2; } }
    }, (beat/4)*1000); // 16分ごと
  }

  // ===== SFX =====
  const sfx={
    ensure(){ if(!audioCtx) initAudio(); },
    burst(freq=440,dur=0.1,vol=0.18){ this.ensure(); const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.setValueAtTime(freq,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(vol,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+dur); o.connect(g).connect(masterGain); o.start(t); o.stop(t+dur+0.05); },
    noise(dur=0.45,vol=0.22){ this.ensure(); const t=audioCtx.currentTime; const buf=audioCtx.createBuffer(1, audioCtx.sampleRate*dur, audioCtx.sampleRate); const d=buf.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.exp(-i/d.length*7);} const src=audioCtx.createBufferSource(); src.buffer=buf; const g=audioCtx.createGain(); g.gain.setValueAtTime(0.22*vol/0.22,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur); src.connect(g).connect(masterGain); src.start(t); },
    hit(){ this.burst(160,0.15,0.22); },
    shoot(){ this.burst(760,0.08,0.16); },
    item(){ this.burst(1100,0.12,0.18); this.burst(1400,0.12,0.18); },
    boss(){ this.burst(280,0.4,0.28); },
    clear(){ this.burst(900,0.4,0.22); },
    evolve(){ this.burst(500,0.3,0.32); this.noise(0.6,0.30); },
    fanfare(){ this.ensure(); const t=audioCtx.currentTime+0.02; const seq=[523,659,784,1046,1318,1046,1568]; let off=0; for(const f of seq){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(f,t+off); g.gain.setValueAtTime(0.0001,t+off); g.gain.exponentialRampToValueAtTime(0.22,t+off+0.03); g.gain.exponentialRampToValueAtTime(0.0001,t+off+0.32); o.connect(g).connect(masterGain); o.start(t+off); o.stop(t+off+0.38); off+=0.16; } }
  };
  /* ===== /PART 1/3 ===== */
  </script>
  <!-- 次は PART 2/3 をこの下に続けます -->

  <!-- PART 2/3: Input, State, Spawns, Dice Boss, Update（Stage2通常に必ずBGMを適用） -->
  <script>
  /* ===== PART 2/3 ===== */

  // ===== Input =====
  let pointerX=0, pointerY=0, pointerActive=false;
  function setPointer(e){
    const r=canvas.getBoundingClientRect();
    pointerX=e.clientX-r.left; pointerY=e.clientY-r.top; pointerActive=true;
  }
  canvas.addEventListener('pointerdown',e=>{ initAudio(); setPointer(e); });
  canvas.addEventListener('pointermove',e=>{ if(pointerActive || e.buttons>0 || (e.pressure||0)>0) setPointer(e); });
  addEventListener('pointerup',()=> pointerActive=false);

  // ===== Game State =====
  let state='title', testsLocked=false;
  const player={ x:0,y:0,vx:0,vy:0,speed:8,lives:3,invul:0,power:'normal',powerTimer:0,beamTimer:0,combo:0 };
  const bullets=[], enemies=[], enemyBullets=[], particles=[], items=[];
  let backgroundScroll=0, score=0, stage=1, stageTimer=0, boss=null, spawnTimer=0, stageGoal=false;
  const victoryFX={active:false,t:0,stage:1};

  function resetGame(){
    player.x=canvas.width/2; player.y=canvas.height-140;
    player.vx=player.vy=0; player.lives=3; player.invul=0;
    player.power='normal'; player.powerTimer=0; player.beamTimer=0;
    bullets.length=0; enemies.length=0; enemyBullets.length=0; particles.length=0; items.length=0;
    score=0; stage=1; stageTimer=0; boss=null; spawnTimer=0; stageGoal=false;
    overlayPower.textContent=''; updateUI();
    setBgm('s1_stage'); // ステージ1は既存曲
  }
  function updateUI(){ scoreEl.textContent=String(score).padStart(6,'0'); lifeEl.textContent=player.lives; stageEl.textContent=stage; }
  function showStageBanner(text){ stageBanner.textContent=text; stageBanner.style.display='block'; setTimeout(()=>stageBanner.style.display='none',1800); }

  // ===== Spawns =====
  function spawnEnemy(){
    const s2=(stage===2);
    const types = s2 ? ['straight','zigzag','tank','diver','sniper','orbiter'] : ['straight','zigzag','diver'];
    // 難易度緩和：弾幕源（sniper/orbiter）の比率を強く抑える
    const weights = s2 ? [0.32,0.32,0.20,0.14,0.015,0.005] : [0.45,0.35,0.20];
    const pick=(arr,w)=>{ const r=Math.random(); let a=0; for(let i=0;i<arr.length;i++){ a+=w[i]; if(r<=a) return arr[i]; } return arr[arr.length-1]; };
    const type=pick(types,weights);

    const x=Math.random()*(canvas.width-160)+80, y=-40;
    let hp=2, vy=1.8, vx=0, shootDelay=1600, phase=Math.random()*Math.PI*2, stop=false;
    switch(type){
      case 'straight': vy=s2?2.3:1.8; hp=s2?3:2; shootDelay=1600; break;
      case 'zigzag' : vy=s2?2.1:1.7; hp=s2?3:2; shootDelay=1400; break;
      case 'tank'   : vy=1.15; hp=s2?6:4; shootDelay=1200; break;
      case 'diver'  : vy=2.0; hp=2; shootDelay=9999; break;
      case 'sniper' : vy=1.6; hp=s2?3:2; shootDelay=2200; break;
      case 'orbiter': vy=1.7; hp=s2?4:3; shootDelay=1800; break;
    }
    enemies.push({x,y,vx,vy,hp,type,phase,shootTimer:0,shootDelay,stop});
  }

  function spawnItem(x,y){
    const t=['spread','heal','beam','shield'][Math.floor(Math.random()*4)];
    items.push({x,y,type:t,vy:1.5,phase:0});
  }

  function spawnBoss(){
    if(stage===1){
      boss={x:canvas.width/2,y:160,baseX:canvas.width/2,baseY:160,hp:180,maxHp:180,type:'sentinel',cooldown:0,form:1,dropMilestones:[0.75,0.5,0.25]};
      setBgm('s1_boss1');
    }else{
      // サイコロ（自由移動）
      const pad=80;
      boss={
        x:canvas.width/2, y:Math.max(100, Math.min(180, canvas.height*0.28)),
        vx:0, vy:0, speed:1.8,
        minX:pad, maxX:()=>canvas.width-pad,
        minY:70 , maxY:()=>Math.min(Math.floor(canvas.height*0.55), 360),
        targetX:canvas.width/2, targetY:140, retarget:0,
        hp:260, maxHp:260,
        type:'dice', cooldown:0, form:1,
        face:1, faceTimer:0, spin:0, spinSpeed:0,
        dropMilestones:[0.8,0.55,0.3]
      };
      setBgm('s2_boss1'); // ★ Stage2ボス第一：Nier風ドラム動機曲
    }
    sfx.boss();
  }

  // ===== Shooting =====
  function shoot(){
    if(player.power==='beam'){
      bullets.push({x:player.x-6,y:player.y-60,vx:0,vy:-18,type:'beam'});
      bullets.push({x:player.x+6,y:player.y-60,vx:0,vy:-18,type:'beam'});
    }else if(player.power==='spread'){
      bullets.push({x:player.x-18,y:player.y-40,vx:-2,vy:-13,type:'normal'});
      bullets.push({x:player.x   ,y:player.y-48,vx: 0,vy:-14,type:'normal'});
      bullets.push({x:player.x+18,y:player.y-40,vx: 2,vy:-13,type:'normal'});
    }else{
      bullets.push({x:player.x,y:player.y-48,vx:0,vy:-13,type:'normal'});
    }
    sfx.shoot();
  }
  let shootInterval=0;

  // ===== Update =====
  function update(delta){
    if(state!=='playing') return;
    backgroundScroll += delta*0.12;
    stageTimer += delta; spawnTimer += delta; shootInterval += delta;

    // move player
    if(pointerActive){ player.x += (pointerX-player.x)*0.18; player.y += (pointerY-player.y)*0.12; }
    player.x=Math.max(40,Math.min(canvas.width-40,player.x));
    player.y=Math.max(120,Math.min(canvas.height-80,player.y));

    // timers
    if(player.invul>0) player.invul-=delta;
    if(player.powerTimer>0){ player.powerTimer-=delta; if(player.powerTimer<=0 && player.power!=='normal'){ player.power='normal'; overlayPower.textContent=''; } }
    if(player.beamTimer>0){ player.beamTimer-=delta; if(player.beamTimer<=0 && player.power==='beam'){ player.power='normal'; overlayPower.textContent=''; } }

    // auto fire
    if(shootInterval>120){ shoot(); shootInterval=0; }

    // enemy spawn
    const spawnIv=(stage===1?680:460);
    if(!boss && spawnTimer>spawnIv){ spawnEnemy(); spawnTimer=0; }

    // boss trigger
    if(!boss){
      const targetMs=(stage===1?42000:52000);
      if(stageTimer>targetMs && !stageGoal){ stageGoal=true; spawnBoss(); }
    }

    // bullets
    for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx; b.y+=b.vy; if(b.type==='beam') b.vy=-22; if(b.y<-60) bullets.splice(i,1); }

    // enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i]; e.phase+=delta*0.0025;
      if(e.type==='zigzag'){ e.x+=Math.sin(e.phase*2.6)*3.4; e.y+=e.vy; }
      else if(e.type==='diver'){
        if((e.phase%1)<0.02){ const a=Math.atan2(player.y-e.y, player.x-e.x); e.vx=Math.cos(a)*3.0; e.vy=Math.sin(a)*3.0; }
        e.x+=e.vx; e.y+=e.vy;
      }else if(e.type==='sniper'){ if(!e.stop && e.y<canvas.height*0.28){ e.stop=true; e.vy=0; } e.y+=e.vy; }
      else if(e.type==='orbiter'){ e.x+=Math.sin(e.phase*2.0)*2.6; e.y+=e.vy*0.9; }
      else if(e.type==='tank'){ e.y+=e.vy*0.8; }
      else { e.y+=e.vy; }

      // shooting (difficulty tuned for stage 2)
      e.shootTimer+=delta;
      if(e.type==='tank' && e.shootTimer>e.shootDelay){
        e.shootTimer=0; const spread=(stage===2?[-0.28,0,0.28]:[-0.4,0,0.4]);
        for(const a of spread){ enemyBullets.push({x:e.x,y:e.y+12,vx:Math.sin(a)*2.8,vy:Math.cos(a)*2.8,type:'normal'}); }
      }
      if(e.type==='sniper' && e.stop && e.shootTimer>(stage===2?2400:1700)){
        e.shootTimer=0; const a=Math.atan2(player.y-e.y, player.x-e.x); const sp=(stage===2?4.0:5.0);
        enemyBullets.push({x:e.x,y:e.y+10,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,type:'normal'});
      }
      if(e.type==='orbiter' && e.shootTimer>(stage===2?2000:1400)){
        e.shootTimer=0; const n=(stage===2?4:6), sp=2.6;
        for(let k=0;k<n;k++){ const a=(Math.PI*2/n)*k + e.phase*1.0; enemyBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,type:'normal'}); }
      }
      if((e.type==='straight'||e.type==='zigzag') && e.shootTimer> (e.type==='zigzag' ? (stage===2?1600:1300) : (stage===2?1800:1500))){
        e.shootTimer=0; enemyBullets.push({x:e.x,y:e.y+10,vx:0,vy:(stage===2?3.9:4.6),type:'normal'});
      }

      if(e.y>canvas.height+80 || e.x<-80 || e.x>canvas.width+80) enemies.splice(i,1);
    }

    // boss logic
    if(boss){
      boss.cooldown-=delta;
      if(boss.type==='dice'){
        // retargeting
        boss.retarget-=delta;
        const maxX=(typeof boss.maxX==='function')?boss.maxX():boss.maxX;
        const maxY=(typeof boss.maxY==='function')?boss.maxY():boss.maxY;
        if(boss.retarget<=0){
          boss.retarget=(boss.form===1?900:650);
          if(Math.random()<0.35){ boss.targetX=clamp(player.x, boss.minX, maxX); boss.targetY=clamp(player.y-80, boss.minY, maxY); }
          else { boss.targetX=rand(boss.minX,maxX); boss.targetY=rand(boss.minY,maxY); }
        }
        const ang=Math.atan2(boss.targetY-boss.y, boss.targetX-boss.x);
        const spd=(boss.form===1?boss.speed:boss.speed+0.6);
        boss.vx += (Math.cos(ang)*spd - boss.vx)*0.06;
        boss.vy += (Math.sin(ang)*spd - boss.vy)*0.06;
        boss.x+=boss.vx; boss.y+=boss.vy;
        boss.x=clamp(boss.x, boss.minX, maxX); boss.y=clamp(boss.y, boss.minY, maxY);

        boss.faceTimer+=delta; if(boss.faceTimer>700){ boss.faceTimer=0; boss.face=1+Math.floor(Math.random()*6); }
        if(boss.form===2){ boss.spinSpeed = lerp(boss.spinSpeed, 0.015, 0.05); boss.spin += boss.spinSpeed * delta; }
        else { boss.spinSpeed = lerp(boss.spinSpeed, 0.0, 0.05); }

        // shooting (cross + diagonals; P2 adds light aim burst)
        if(boss.cooldown<=0){
          const base=(boss.form===1?(boss.face<=3?4:6):(boss.face<=3?6:8));
          boss.cooldown=(boss.form===1?820:620);
          const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
          if(base>=6) dirs.push([1,1],[-1,1],[1,-1],[-1,-1]);
          const sp=(boss.form===1?3.2:3.8);
          for(let i=0;i<Math.min(base,dirs.length);i++){
            const [dx,dy]=dirs[i]; enemyBullets.push({x:boss.x,y:boss.y,vx:dx*sp,vy:dy*sp,type:'boss'});
          }
          if(boss.form===2){
            const a=Math.atan2(player.y-boss.y, player.x-boss.x); for(const off of [-0.1,0,0.1]){
              enemyBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a+off)*3.5,vy:Math.sin(a+off)*3.5,type:'boss'});
            }
          }
        }
      }else{
        // 既存ボス挙動（sentinelのみ想定）
        const p=boss;
        p.phase=(p.phase||0)+(boss.form===1?delta*0.0016:delta*0.0024);
        if(p.form===1){
          p.x=p.baseX+Math.sin(p.phase)*120;
          if(p.cooldown<=0){ p.cooldown=900; for(let a=-0.8;a<=0.8;a+=0.4){ enemyBullets.push({x:p.x,y:p.y+20,vx:Math.sin(a)*3.5,vy:Math.cos(a)*3.5,type:'boss'}); } }
        }else{
          p.x=p.baseX+Math.sin(p.phase*1.2)*150; p.y=p.baseY+Math.sin(p.phase*0.9)*16;
          if(p.cooldown<=0){ p.cooldown=520; for(let i=0;i<12;i++){ const a=(Math.PI*2/12)*i + p.phase*1.3; enemyBullets.push({x:p.x,y:p.y,vx:Math.cos(a)*4.0,vy:Math.sin(a)*4.0,type:'boss'}); } }
        }
      }
    }

    // enemy bullets
    for(let i=enemyBullets.length-1;i>=0;i--){ const b=enemyBullets[i]; b.x+=b.vx; b.y+=b.vy; if(b.y>canvas.height+80 || b.x<-80 || b.x>canvas.width+80) enemyBullets.splice(i,1); }

    // items
    for(let i=items.length-1;i>=0;i--){ const it=items[i]; it.phase+=delta*0.0022; it.y+=it.vy; it.x+=Math.sin(it.phase)*1.8; if(it.y>canvas.height+40) items.splice(i,1); }

    // particles
    for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life-=delta; p.x+=p.vx; p.y+=p.vy; if(p.life<=0) particles.splice(i,1); }

    // collisions (bullets vs enemies/boss)
    bulletsLoop:
    for(let bi=bullets.length-1; bi>=0; bi--){
      const b=bullets[bi];
      for(let ei=enemies.length-1; ei>=0; ei--){
        const e=enemies[ei];
        if(Math.abs(b.x-e.x)<24 && Math.abs(b.y-e.y)<24){
          enemies.splice(ei,1); bullets.splice(bi,1);
          score+=120; if(Math.random()<0.18) spawnItem(e.x,e.y);
          spawnBurst(e.x,e.y,6); sfx.noise();
          break bulletsLoop;
        }
      }
      if(boss){
        const r=(boss.type==='dice' ? (boss.form===1?52:60) : (boss.form===1?60:74));
        if(Math.abs(b.x-boss.x)<r && Math.abs(b.y-boss.y)<r){
          bullets.splice(bi,1);
          boss.hp-=(b.type==='beam'?4:2);
          spawnBurst(boss.x,boss.y,2);

          // milestone drops
          if(boss.dropMilestones && boss.dropMilestones.length){
            const ratio=boss.hp/boss.maxHp;
            while(boss.dropMilestones.length && ratio<=boss.dropMilestones[0]){
              boss.dropMilestones.shift();
              const drops=1+(Math.random()<0.35?1:0);
              for(let k=0;k<drops;k++) spawnItem(boss.x+(Math.random()*60-30), boss.y+(Math.random()*40-20));
            }
          }

          // dead
          if(boss.hp<=0){
            if(boss.form===1){
              sfx.evolve(); spawnBurst(boss.x,boss.y,28);
              boss.form=2; boss.maxHp=(boss.type==='dice'?280:240); boss.hp=boss.maxHp; boss.cooldown=0; boss.dropMilestones=[0.7,0.45,0.2];
              if(boss.type==='dice'){ boss.spinSpeed=0.008; boss.speed=2.6; setBgm('s2_boss2'); } // ★ ボス第二曲へ
              else { setBgm('s1_boss2'); }
              showStageBanner('PHASE 2');
            }else{
              for(let k=0;k<3;k++) spawnItem(boss.x+(Math.random()*80-40), boss.y+(Math.random()*60-30));
              triggerVictoryFX(stage); sfx.noise(); sfx.clear(); sfx.fanfare();
              score+=4000; boss=null; stageGoal=false; enemies.length=0; enemyBullets.length=0;
              if(stage===1){
                stage=2; stageTimer=0; spawnTimer=0;
                // ★ ステージ2開始直後に必ず通常BGMをセット
                setTimeout(()=>{ setBgm('s2_stage'); showStageBanner('STAGE 2'); }, 900);
              }else{
                setTimeout(()=>winGame(), 1200);
              }
            }
          }
        }
      }
    }

    // collisions (player vs world)
    for(let ei=enemies.length-1; ei>=0; ei--){
      const e=enemies[ei];
      if(Math.abs(player.x-e.x)<40 && Math.abs(player.y-e.y)<40){ enemies.splice(ei,1); damagePlayer(); break; }
    }
    for(let i=enemyBullets.length-1; i>=0; i--){
      const b=enemyBullets[i];
      if(Math.abs(player.x-b.x)<26 && Math.abs(player.y-b.y)<26){ enemyBullets.splice(i,1); damagePlayer(); }
    }
    for(let ii=items.length-1; ii>=0; ii--){
      const it=items[ii];
      if(Math.abs(player.x-it.x)<36 && Math.abs(player.y-it.y)<36){ applyItem(it.type); items.splice(ii,1); }
    }

    // サイコロ接触は減点（ライフ減少なし）
    if(boss && boss.type==='dice'){
      const r=(boss.form===1?52:60);
      if(Math.abs(player.x-boss.x)<r && Math.abs(player.y-boss.y)<r && player.invul<=0){
        score=Math.max(0, score-500); player.invul=900; spawnBurst(player.x,player.y,12); sfx.hit(); updateUI();
      }
    }

    updateUI();
  }

  function damagePlayer(){ if(player.invul>0) return; player.lives-=1; player.invul=1500; spawnBurst(player.x,player.y,18); sfx.hit(); if(player.lives<=0) endGame(); }
  function applyItem(t){
    sfx.item();
    if(t==='spread'){ player.power='spread'; player.powerTimer=8000; overlayPower.textContent='パワーアップ：三連弾'; }
    else if(t==='beam'){ player.power='beam'; player.beamTimer=6000; overlayPower.textContent='パワーアップ：光束レーザー'; }
    else if(t==='heal'){ player.lives=Math.min(5,player.lives+1); overlayPower.textContent='ライフ回復'; }
    else if(t==='shield'){ player.power='shield'; player.powerTimer=7000; player.invul=1800; overlayPower.textContent='守護シールド展開'; }
  }
  function spawnBurst(x,y,c){ for(let i=0;i<c;i++){ const a=Math.random()*Math.PI*2, s=1+Math.random()*3; particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:600+Math.random()*400}); } }
  function triggerVictoryFX(stg){ victoryFX.active=true; victoryFX.t=0; victoryFX.stage=stg; for(let i=0;i<120;i++){ const a=Math.random()*Math.PI*2, sp=2+Math.random()*5, col=i%2?1:0; particles.push({x:canvas.width/2,y:canvas.height*0.35,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:900+Math.random()*600,col}); } }

  // helpers
  function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function lerp(a,b,t){ return a+(b-a)*t; }

  /* ===== /PART 2/3 ===== */
  </script>

  <!-- PART 3/3（完全版）: Drawing, Loop/Flow, SelfTests -->
  <script>
  /* ===== PART 3/3 ===== */

  // ===== Drawing =====
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();

    if(state==='playing'){
      const flicker = player.invul>0 && Math.floor(performance.now()/120)%2===0;
      if(!flicker) drawPlayer();
    }

    bullets.forEach(drawBullet);
    enemies.forEach(drawEnemy);
    if(boss) drawBoss(boss);
    enemyBullets.forEach(drawEnemyBullet);
    items.forEach(drawItem);
    particles.forEach(drawParticle);

    if(victoryFX.active) drawVictoryFX();
  }

  function drawBackground(){
    const h=canvas.height, w=canvas.width;
    const gradient=ctx.createLinearGradient(0,0,0,h);
    gradient.addColorStop(0,'#111'); gradient.addColorStop(1,'#000');
    ctx.fillStyle=gradient; ctx.fillRect(0,0,w,h);
    ctx.fillStyle='rgba(255,255,255,0.05)';
    for(let i=0;i<90;i++){
      const y=(backgroundScroll*0.4 + i*(h/90))%h;
      ctx.fillRect((i*37.3)%w,y,2,16);
    }
  }

  function drawPlayer(){
    ctx.save();
    ctx.translate(player.x,player.y);
    ctx.fillStyle='#fff';
    ctx.beginPath();
    ctx.moveTo(0,-28); ctx.lineTo(20,20); ctx.lineTo(0,10); ctx.lineTo(-20,20); ctx.closePath();
    ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,0.9)'; ctx.lineWidth=2; ctx.stroke();
    if(player.power==='shield'){
      ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(0,-2,34,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }

  function drawBullet(b){
    ctx.save(); ctx.translate(b.x,b.y);
    ctx.fillStyle=(b.type==='beam')?'#fefefe':'#fff';
    ctx.fillRect(-3,-12,6,20);
    ctx.restore();
  }

  function drawEnemy(e){
    ctx.save(); ctx.translate(e.x,e.y);
    ctx.strokeStyle='#000'; ctx.lineWidth=2;
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.beginPath();
    if(e.type==='tank'){ ctx.rect(-26,-18,52,36); }
    else if(e.type==='diver'){ ctx.moveTo(0,-22); ctx.lineTo(18,18); ctx.lineTo(-18,18); ctx.closePath(); }
    else if(e.type==='sniper'){ ctx.moveTo(-20,-14); ctx.lineTo(20,-14); ctx.lineTo(12,14); ctx.lineTo(-12,14); ctx.closePath(); }
    else if(e.type==='orbiter'){ ctx.arc(0,0,18,0,Math.PI*2); }
    else if(e.type==='zigzag'){ ctx.moveTo(-18,-18); ctx.lineTo(18,-18); ctx.lineTo(24,18); ctx.lineTo(-24,18); ctx.closePath(); }
    else { ctx.rect(-18,-14,36,28); }
    ctx.fill(); ctx.stroke();
    if(e.type==='tank' || e.type==='orbiter'){ ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.stroke(); }
    ctx.restore();
  }

  function drawBoss(b){
    if(b.type==='dice'){
      const size=(b.form===1?56:64);

      // オーラ（第2形態のみ）
      if(b.form===2){
        const puls = 0.5 + 0.5*Math.sin((performance.now()/240)%Math.PI*2);
        ctx.save();
        ctx.translate(b.x,b.y);
        ctx.globalAlpha=0.15+0.15*puls;
        ctx.beginPath(); ctx.arc(0,0,size*0.95+18*puls,0,Math.PI*2); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
        ctx.globalAlpha=0.08+0.08*puls;
        ctx.beginPath(); ctx.arc(0,0,size*0.95+36*puls,0,Math.PI*2); ctx.stroke();
        ctx.restore();
      }

      ctx.save();
      ctx.translate(b.x,b.y);
      if(b.form===2){ ctx.rotate(b.spin||0); }

      // 本体
      ctx.fillStyle='rgba(255,255,255,0.95)';
      ctx.strokeStyle='#000'; ctx.lineWidth=4;
      if(b.form===1){
        ctx.beginPath(); ctx.rect(-size/2,-size/2,size,size); ctx.fill(); ctx.stroke();
      }else{
        const r=size*0.18, w=size, h=size;
        roundRect(ctx,-w/2,-h/2,w,h,r); ctx.fill(); ctx.stroke();
        // 内側ライン
        ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=2;
        roundRect(ctx,-w/2+6,-h/2+6,w-12,h-12,r*0.8); ctx.stroke();
        // 角ハイライト
        ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1.5;
        for(let i=0;i<4;i++){
          const ang=i*Math.PI/2;
          const cx=Math.cos(ang)*(w/2-r), cy=Math.sin(ang)*(h/2-r);
          ctx.beginPath(); ctx.arc(cx,cy,r,ang-0.7,ang+0.7); ctx.stroke();
        }
      }

      // ピップ（サイコロ目）
      const pipRadius = (size>60?5:4);
      const drawPip = (px,py,alpha=1)=>{
        ctx.save();
        ctx.globalAlpha=alpha;
        if(b.form===1){
          ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(px,py,pipRadius,0,Math.PI*2); ctx.fill();
        }else{
          ctx.fillStyle='#000';
          roundRect(ctx,px-pipRadius,py-pipRadius,pipRadius*2,pipRadius*2,2.5); ctx.fill();
          ctx.fillStyle='rgba(255,255,255,0.15)';
          roundRect(ctx,px-pipRadius+1,py-pipRadius+1,pipRadius*2-2,pipRadius*2-2,2.0); ctx.fill();
        }
        ctx.restore();
      };
      const d=size*0.22;
      const layouts={
        1:[[0,0]],
        2:[[-d,-d],[ d, d]],
        3:[[-d,-d],[ 0, 0],[ d, d]],
        4:[[-d,-d],[ d,-d],[-d, d],[ d, d]],
        5:[[-d,-d],[ d,-d],[ 0, 0],[-d, d],[ d, d]],
        6:[[-d,-d],[ d,-d],[-d, 0],[ d, 0],[-d, d],[ d, d]]
      };
      const arr=(layouts[b.face]||layouts[1]);
      const flick = (b.form===2) ? (0.8 + 0.2*Math.sin((performance.now()/180)%Math.PI*2)) : 1;
      arr.forEach(([px,py])=> drawPip(px,py,flick));

      // 第2形態：放射スリット
      if(b.form===2){
        ctx.globalAlpha=0.12;
        ctx.strokeStyle='#000'; ctx.lineWidth=1.2;
        for(let i=0;i<8;i++){
          const ang=i*Math.PI/4;
          ctx.beginPath();
          ctx.moveTo(0,0);
          ctx.lineTo(Math.cos(ang)*(size/2-6), Math.sin(ang)*(size/2-6));
          ctx.stroke();
        }
        ctx.globalAlpha=1;
      }

      ctx.restore();

      // HPバー
      ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.fillRect(canvas.width/2-160,40,320,14);
      ctx.fillStyle='#fff'; ctx.fillRect(canvas.width/2-160,40,(b.hp/b.maxHp)*320,14);
      ctx.strokeStyle='#000'; ctx.strokeRect(canvas.width/2-160,40,320,14);
      return;
    }

    // 既存ボス（sentinel）
    ctx.save(); ctx.translate(b.x,b.y);
    const r=b.form===1?60:74;
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#000'; ctx.lineWidth=4; ctx.stroke();
    ctx.fillStyle='#000'; ctx.fillRect(-10,-r*0.3,20,r*0.6);
    if(b.form===2){
      ctx.strokeStyle='rgba(255,255,255,0.65)'; ctx.lineWidth=2;
      for(let i=0;i<12;i++){
        const a=(Math.PI*2/12)*i + (b.phase||0)*2;
        ctx.beginPath(); ctx.moveTo(Math.cos(a)*r,Math.sin(a)*r);
        ctx.lineTo(Math.cos(a)*(r+16),Math.sin(a)*(r+16)); ctx.stroke();
      }
      ctx.globalAlpha=0.15; ctx.beginPath(); ctx.arc(0,0,r+22,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
    }
    ctx.restore();
    ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.fillRect(canvas.width/2-160,40,320,14);
    ctx.fillStyle='#fff'; ctx.fillRect(canvas.width/2-160,40,(b.hp/b.maxHp)*320,14);
    ctx.strokeStyle='#000'; ctx.strokeRect(canvas.width/2-160,40,320,14);
  }

  function drawEnemyBullet(b){
    ctx.save();
    ctx.translate(b.x,b.y);
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.beginPath(); ctx.arc(0,0,b.type==='boss'?7:5,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawItem(it){
    ctx.save(); ctx.translate(it.x,it.y);
    ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.rect(-16,-16,32,32); ctx.stroke();
    ctx.fillStyle='#fff'; ctx.font='16px "Noto Sans JP", sans-serif';
    let text='';
    switch(it.type){
      case 'spread': text='三'; break;
      case 'beam'  : text='光'; break;
      case 'heal'  : text='＋'; break;
      case 'shield': text='盾'; break;
    }
    const m=ctx.measureText(text);
    ctx.fillText(text,-m.width/2,6);
    ctx.restore();
  }

  function drawParticle(p){
    ctx.save();
    const a=Math.max(0,p.life/900);
    const col=(p.col===0)?'0,0,0':'255,255,255';
    ctx.fillStyle=`rgba(${col},${a.toFixed(2)})`;
    ctx.fillRect(p.x,p.y,3,3);
    ctx.restore();
  }

  function drawVictoryFX(){
    victoryFX.t += 16.6;
    const t=victoryFX.t;
    const flash=Math.max(0,1 - t/300);
    if(flash>0){
      ctx.save(); ctx.globalAlpha=flash*0.7; ctx.fillStyle='#fff';
      ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();
    }
    for(let i=0;i<4;i++){
      const r=t*0.4 + i*26;
      const a=Math.max(0,1 - (t-i*80)/400);
      if(a<=0) continue;
      ctx.save(); ctx.globalAlpha=a*0.6; ctx.strokeStyle=i%2?'#fff':'#000'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(canvas.width/2,canvas.height*0.35,r,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }
    ctx.save(); ctx.globalAlpha=Math.max(0,1 - t/900); ctx.lineWidth=2;
    for(let i=0;i<36;i++){
      const ang=(Math.PI*2/36)*i, len=80+t*0.2;
      ctx.strokeStyle=i%2?'#fff':'#000';
      ctx.beginPath();
      ctx.moveTo(canvas.width/2 + Math.cos(ang)*20, canvas.height*0.35 + Math.sin(ang)*20);
      ctx.lineTo(canvas.width/2 + Math.cos(ang)*(20+len), canvas.height*0.35 + Math.sin(ang)*(20+len));
      ctx.stroke();
    }
    ctx.restore();
    if(t>1000) victoryFX.active=false;
  }

  // ===== Flow =====
  function endGame(){
    state='gameover';
    stopBgm();
    gameOver.style.display='flex';
    gameOver.querySelector('h2').textContent='GAME OVER';
    finalScore.textContent=score;
  }

  function winGame(){
    state='gameclear';
    stopBgm();
    sfx.fanfare();
    gameOver.style.display='flex';
    gameOver.querySelector('h2').textContent='GAME CLEAR';
    finalScore.textContent=score+' (WHITE WORLD CLEAR)';
  }

  function loop(timestamp){
    requestAnimationFrame(loop);
    if(!lastTime) lastTime=timestamp;
    const delta=timestamp-lastTime;
    lastTime=timestamp;

    // まれにタイトルへ戻ってしまうケースの保険
    if(state==='playing' && titleScreen.style.display!=='none'){
      titleScreen.style.display='none';
    }

    update(delta);
    draw();
  }
  let lastTime=0; requestAnimationFrame(loop);

  function startGame(){
    testsLocked=true; // SelfTestsの復元を無効化
    resetGame();
    state='playing';
    titleScreen.style.display='none';
    gameOver.style.display='none';
    showStageBanner('STAGE 1');
  }

  startBtn.addEventListener('click',()=>{ initAudio(); startGame(); });
  restartBtn.addEventListener('click',()=>{ initAudio(); startGame(); });
  addEventListener('keydown',e=>{
    if(e.key===' ' && state==='title'){ initAudio(); startGame(); }
    if(e.key==='m'){ toggleBgm(); }
  });

  // ===== SelfTests（Stage2 BGM適用の最終確認込み） =====
  (function runSelfTests(){
    try{
      console.group('SelfTests');
      const snap={ stage, boss, mode:bgm.mode, state, titleDisp:titleScreen.style.display, overDisp:gameOver.style.display, h2:document.querySelector('#gameOver h2').textContent };
      console.assert(typeof spawnBoss==='function','spawnBoss is defined');
      stage=1; spawnBoss(); console.assert(boss && (boss.type==='sentinel' || boss.type==='dice'), 'Stage1 boss spawns');
      boss=null; stage=2; spawnBoss(); console.assert(boss && boss.type==='dice' && bgm.mode.startsWith('s2_boss1'),'Stage2 dice boss spawns & S2 boss music set');
      console.assert(typeof toggleBgm==='function','toggleBgm is defined');
      const mutedBefore=bgmMuted; toggleBgm(); console.assert(bgmMuted!==mutedBefore,'toggleBgm toggles state'); toggleBgm(); console.assert(bgmMuted===mutedBefore,'toggleBgm toggles back');
      setBgm('s1_stage'); const modeBefore=bgm.mode; setBgm('s1_stage'); console.assert(bgm.mode===modeBefore,'setBgm same mode is no-op');
      const seen=new Set(); for(let j=0;j<40;j++){ spawnEnemy(); const en=enemies.pop(); if(en) seen.add(en.type); }
      console.assert(seen.size>=3,'multiple enemy types spawn');
      // ステージ2通常BGM確認
      setBgm('s2_stage'); console.assert(bgm.mode==='s2_stage','Stage2 normal music set');
      winGame(); console.assert(document.querySelector('#gameOver h2').textContent.includes('CLEAR'),'winGame shows CLEAR');

      if(!testsLocked){
        state=snap.state;
        titleScreen.style.display=snap.titleDisp;
        gameOver.style.display=snap.overDisp;
        document.querySelector('#gameOver h2').textContent=snap.h2;
        boss=snap.boss; stage=snap.stage;
        try{ setBgm(snap.mode||'s1_stage'); }catch{}
      }
      console.log('SelfTests passed'); console.groupEnd();
    }catch(e){ console.error('SelfTests failed', e); }
  })();

  // ===== util: roundRect =====
  function roundRect(ctx,x,y,w,h,r){
    const rr=Math.max(0,Math.min(r,Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.lineTo(x+w-rr,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
    ctx.lineTo(x+w,y+h-rr);
    ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    ctx.lineTo(x+rr,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
    ctx.lineTo(x,y+rr);
    ctx.quadraticCurveTo(x,y,x+rr,y);
    // 呼び出し側で fill()/stroke()
  }

  /* ===== /PART 3/3 ===== */
  </script>
</body>
</html>
