<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Monochrome Rebirth – Rhythm of Colors</title>
<style>
  :root{
    --gray: 1;
    --bg-top:#0b0f15;
    --bg-bot:#0e1220;
    --yellow:#ffd166; --green:#5af38f; --blue:#6ab8ff; --red:#ff6b6b;
    --hit-top: 75%;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(var(--bg-top),var(--bg-bot));color:#e9eefc;font-family:system-ui,-apple-system,"Hiragino Sans","Noto Sans JP",sans-serif}
  .wrap{height:100%;display:flex;align-items:center;justify-content:center;filter:grayscale(var(--gray));transition:filter .8s ease}
  .game{width:min(980px,100%);max-width:980px;padding:12px}
  .topbar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px}
  .stat{display:flex;gap:12px;font-size:14px;color:#bcd1ff;flex-wrap:wrap}
  .badge{padding:4px 10px;border:1px solid #283248;border-radius:999px;background:rgba(255,255,255,.04)}
  .title{font-weight:800;letter-spacing:.6px;color:#e9eefc;text-transform:uppercase}
  .stage{font-weight:600;opacity:.75}

  .board{
    position:relative;border:1px solid #243049;border-radius:16px;overflow:hidden;background:
      radial-gradient(1000px 400px at 50% 20%, rgba(255,255,255,.04), transparent 60%),
      linear-gradient(180deg, var(--bg-top), var(--bg-bot));
    height:70vh;min-height:460px;touch-action:none;
  }
  canvas{position:absolute;inset:0;display:block;width:100%;height:100%}

  .centerHud{position:absolute;left:0;right:0;top:8px;display:flex;justify-content:center;gap:8px;pointer-events:none;flex-wrap:wrap}
  .chip{font-size:12px;border:1px solid #3a455d;background:rgba(255,255,255,.05);padding:6px 10px;border-radius:999px}
  .chip strong{color:#fff}

  .hitLine{position:absolute; left:0; right:0; top: var(--hit-top, 75%); border-top:2px dashed rgba(255,255,255,.28);}

  .controls{position:absolute;left:0;right:0;bottom:10px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  .btn{
    -webkit-tap-highlight-color:transparent;
    border:1px solid #33415f;background:linear-gradient(180deg,#1a2234,#151b29);
    color:#e9eefc;border-radius:12px;padding:10px 14px;font-weight:700;letter-spacing:.3px;cursor:pointer;
    box-shadow:0 10px 28px rgba(0,0,0,.28), inset 0 1px 0 rgba(255,255,255,.06);
    text-transform:uppercase;
  }
  .btn:active{transform:translateY(1px)}
  .btn.primary{border-color:#6470ff;background:linear-gradient(180deg,#2b36aa,#20297e)}
  .btn.wide{min-width:160px}

  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(4,7,14,.6);backdrop-filter:blur(3px)}
  .card{width:min(680px,92%);background:linear-gradient(180deg,#0f1422,#0a0f1b);border:1px solid #2a3552;border-radius:16px;padding:20px 18px;box-shadow:0 16px 40px rgba(0,0,0,.45)}
  .card h1{margin:0 0 4px;font-size:26px;letter-spacing:.8px;text-transform:uppercase}
  .card p{margin:8px 0 0;color:#cfe0ff;font-size:14px}
  .bar{height:10px;background:#111827;border:1px solid #26324b;border-radius:999px;overflow:hidden}
  .bar > span{display:block;height:100%;width:0;background:linear-gradient(90deg,#ffd166,#5af38f,#6ab8ff,#ff6b6b)}

  .logo{display:flex;align-items:center;justify-content:center;gap:14px;margin-bottom:14px;letter-spacing:1.2px;text-transform:uppercase;font-weight:900;font-size:28px}
  .logo .dot{width:10px;height:10px;border-radius:50%;background:#fff;opacity:.12;box-shadow:0 0 20px rgba(255,255,255,.25)}
  .logo .word{opacity:.95}
  .sub{font-size:12px;opacity:.65;letter-spacing:.35px;text-transform:uppercase}

  .floatText{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-weight:800;letter-spacing:1px;pointer-events:none;text-shadow:0 2px 10px rgba(0,0,0,.45)}
  .ft-perfect{color:#fff}.ft-good{color:#cfe0ff}.ft-miss{color:#fda4af}

  /* Ending credits */
  .creditsWrap{position:absolute;inset:0;display:none;align-items:flex-end;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.55));pointer-events:none}
  .credits{width:min(640px,90%);max-height:80%;overflow:hidden}
  .scroll{display:block;white-space:pre-line;line-height:1.8;letter-spacing:.5px;font-weight:700;text-align:center;text-shadow:0 2px 12px rgba(0,0,0,.6);animation:roll 28s linear forwards}
  @keyframes roll{from{transform:translateY(100%)}to{transform:translateY(-105%)}}

  @media (max-width:560px){.btn.wide{min-width:140px}}
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="game">
    <div class="topbar">
      <div class="title">MONOCHROME REBIRTH <span class="stage">/ Rhythm of Colors</span></div>
      <div class="stat">
        <div class="badge">LEVEL: <span id="lv">1</span></div>
        <div class="badge">SCORE: <span id="sc">0</span></div>
        <div class="badge">COMBO: <span id="co">0</span></div>
        <div class="badge">ACC: <span id="ac">100%</span></div>
        <div class="badge">WORLD: <span id="wp">0%</span></div>
      </div>
    </div>

    <div class="board" id="board">
      <canvas id="cv"></canvas>

      <div class="centerHud">
        <div class="chip">BPM: <strong id="bpmTxt">80</strong></div>
        <div class="chip">LANES: <strong id="lanesTxt">4</strong></div>
        <div class="chip">WINDOW: <strong>±50ms / ±150ms</strong></div>
        <div class="chip">VFX: <strong>Fireworks / Wind / Waves / Aurora</strong></div>
      </div>

      <div class="hitLine"></div>

      <div class="controls">
        <button class="btn" id="tapBtn" title="中央レーン（Spaceでも可）">Tap / Space</button>
        <button class="btn primary wide" id="startBtn">Start</button>
      </div>

      <div class="overlay" id="ov"><div class="card" id="card"></div></div>

      <!-- Ending credits (canvas上でムービー再生しつつ前面でスクロール) -->
      <div class="creditsWrap" id="creditsWrap">
        <div class="credits"><div class="scroll" id="creditsText"></div></div>
      </div>
    </div>

    <p style="margin:8px 2px 0;font-size:12px;color:#9fb3df">操作：各レーンをタップ（スマホOK）／Space=中央付近。音が出ない場合は一度「Start」を押してください。</p>
  </div>
</div>

<script>
(() => {
  // ====== Level control ======
  let LEVEL = 1;
  const MAX_LEVEL = 5;

  // ====== Constants ======
  const MAX_LANES = 5;
  const BASE_BPM = 80;
  const BPM_STEP = 4;

  let BPM = BASE_BPM, SEC_PER_BEAT = 60/BASE_BPM;
  const LEADIN = 1.0;
  let NOTE_TRAVEL = 2.0;
  const PERFECT = 0.050, GOOD = 0.150;

  const COLOR_ORDER = ['yellow','green','blue','red'];
  const HITS_PER_COLOR = 12;

  let LANE_COUNT = 4;
  const SCALE4 = [261.63, 293.66, 329.63, 392.00];
  const SCALE5 = [246.94, 277.18, 329.63, 369.99, 440.0];
  const HIT_LINE_RATIO = 0.75, SPAWN_RATIO=0.10, BOTTOM_RATIO=0.92;

  // ====== DOM ======
  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  const boardEl = document.getElementById('board');

  const scEl = document.getElementById('sc'), coEl = document.getElementById('co'), acEl = document.getElementById('ac'), wpEl = document.getElementById('wp'), lvEl = document.getElementById('lv');
  const startBtn = document.getElementById('startBtn'), tapBtn = document.getElementById('tapBtn');
  const ov = document.getElementById('ov'), card = document.getElementById('card');

  const bpmTxt = document.getElementById('bpmTxt'), lanesTxt = document.getElementById('lanesTxt');

  const creditsWrap = document.getElementById('creditsWrap'), creditsText = document.getElementById('creditsText');

  // ====== Resize ======
  let DPR = window.devicePixelRatio || 1;
  function fitCanvas(){
    const r=canvas.getBoundingClientRect();
    DPR = window.devicePixelRatio || 1;
    canvas.width=(r.width*DPR)|0; canvas.height=(r.height*DPR)|0;
    document.documentElement.style.setProperty('--hit-top',(HIT_LINE_RATIO*100).toFixed(1)+'%');
  }
  addEventListener('resize', fitCanvas, {passive:true}); fitCanvas();

  // ====== State ======
  let audioCtx=null, masterGain=null;
  let layers={}, melodyBus=null, delayNode=null, panNodes=[];
  let bgm=null, endingBgm=null;
  let particles=[], windStreaks=[];
  let running=false, endingMode=false;

  let chart=[], songStartTime=0, score=0, combo=0, hits=0, judgedCount=0;
  let unlockedIndex=-1, goodHitsForColor=0;
  let targetScore=8000;

  // ====== Helpers ======
  const clamp=(v,min=0,max=1)=>Math.max(min,Math.min(max,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const hsl=(h,s,l,a=1)=>`hsla(${h},${(s*100).toFixed(1)}%,${(l*100).toFixed(1)}%,${a})`;
  const colorOf=c=>({'yellow':'#ffd166','green':'#5af38f','blue':'#6ab8ff','red':'#ff6b6b'}[c]||'#ffffff');
  function addAlpha(hex,a){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return hex; const r=parseInt(m[1],16), g=parseInt(m[2],16), b=parseInt(m[3],16); return `rgba(${r},${g},${b},${a})`; }

  // ====== Level params ======
  function applyLevelParams(){
    if(LEVEL>MAX_LEVEL) LEVEL=MAX_LEVEL;
    BPM = BASE_BPM + (LEVEL-1)*BPM_STEP;
    SEC_PER_BEAT = 60 / BPM;
    NOTE_TRAVEL = Math.max(1.5, 2.0 - (LEVEL-1)*0.15);
    LANE_COUNT = (LEVEL>=3)?5:4;
    bpmTxt.textContent = Math.round(BPM);
    lanesTxt.textContent = LANE_COUNT;
    lvEl.textContent = LEVEL;
  }

  // ====== Lanes ======
  function laneCenters(){ const W=canvas.width, pad=60*DPR, inner=W-pad*2, gap=inner/LANE_COUNT; return Array.from({length:LANE_COUNT},(_,i)=> pad + gap*(i+0.5)); }
  function laneFromCanvasX(cx){ const cs=laneCenters(); let b=0,m=1e9; for(let i=0;i<cs.length;i++){ const d=Math.abs(cx-cs[i]); if(d<m){m=d;b=i} } return b; }

  // ====== Audio ======
  function initAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    masterGain = audioCtx.createGain(); masterGain.gain.value=0.9; masterGain.connect(audioCtx.destination);

    const amb = makePad({freqs:[110,220,330], gain:0.05}); amb.connect(masterGain);

    layers.yellow=makeLayerGain(); layers.green=makeLayerGain(); layers.blue=makeLayerGain(); layers.red=makeLayerGain();

    melodyBus = audioCtx.createGain(); melodyBus.gain.value=0.8;
    delayNode = audioCtx.createDelay(); delayNode.delayTime.value=0.18;
    const fb=audioCtx.createGain(); fb.gain.value=clamp(0.15+(LEVEL-1)*0.05,0.15,0.5);
    melodyBus.connect(delayNode).connect(fb).connect(delayNode);
    const mix=audioCtx.createGain(); mix.gain.value=0.35+(LEVEL-1)*0.05;
    delayNode.connect(mix).connect(masterGain);
    melodyBus.connect(masterGain);

    panNodes = Array.from({length:MAX_LANES},(_,i)=>{
      const panVal = lerp(-0.8,0.8, i/(Math.max(1,MAX_LANES-1)));
      return makePanner(panVal);
    });
    panNodes.forEach(p=>p.connect(melodyBus));

    bgm=createBgmEngine();
  }
  function makeLayerGain(){ const g=audioCtx.createGain(); g.gain.value=0; g.connect(masterGain); return g; }
  function makePad({freqs,gain}){ const g=audioCtx.createGain(); g.gain.value=gain;
    freqs.forEach(f=>{ const o=audioCtx.createOscillator(), env=audioCtx.createGain(); env.gain.value=0.0008; o.type='sine'; o.frequency.value=f; o.connect(env).connect(g); o.start();
      const lfo=audioCtx.createOscillator(), lfog=audioCtx.createGain(); lfo.frequency.value=0.07; lfog.gain.value=f*0.015; lfo.connect(lfog).connect(o.frequency); lfo.start(); }); return g; }
  function makePanner(panValue){
    try{ if(audioCtx.createStereoPanner){ const p=audioCtx.createStereoPanner(); p.pan.value=panValue; return p; }
      else if(typeof StereoPannerNode!=='undefined'){ return new StereoPannerNode(audioCtx,{pan:panValue}); } }catch(e){}
    const g=audioCtx.createGain(); return g;
  }

  function playLaneTone(time, lane){
    const scale=(LANE_COUNT===4)?SCALE4:SCALE5; const freq=scale[Math.max(0,Math.min(scale.length-1,lane))];
    const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter();
    f.type='lowpass'; f.frequency.value=1800+LEVEL*300;
    const lfo=audioCtx.createOscillator(), lg=audioCtx.createGain(); lfo.frequency.value=2+LEVEL*0.5; lg.gain.value=3+LEVEL*2; lfo.connect(lg).connect(o.frequency); lfo.start(time);
    o.type='sine'; o.frequency.value=freq;
    g.gain.setValueAtTime(0.0001,time); g.gain.exponentialRampToValueAtTime(0.22+LEVEL*0.02,time+0.01); g.gain.exponentialRampToValueAtTime(0.0001,time+0.45);
    o.connect(f).connect(g).connect(panNodes[lane]||melodyBus); o.start(time); o.stop(time+0.6);
  }

  // SFX by color
  function colorSfx(t){ const name=COLOR_ORDER[Math.max(0,unlockedIndex)]; if(!name) return;
    if(name==='yellow'){ softKick(t); bell(t+0.02); } if(name==='green'){ arp(t); } if(name==='blue'){ bass(t); } if(name==='red'){ lead(t); } }
  function softKick(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(140,t); o.frequency.exponentialRampToValueAtTime(55,t+0.12);
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.28+LEVEL*0.02,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.2);}
  function bell(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=660+LEVEL*10;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16+LEVEL*0.01,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.5); o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.6);}
  function bass(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter(); o.type='sawtooth'; o.frequency.value=55; f.type='lowpass'; f.frequency.value=200+LEVEL*40;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.20+LEVEL*0.02,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.3); o.connect(f).connect(g).connect(layers.blue); o.start(t); o.stop(t+0.35);}
  function arp(t){ [440,523.25,587.33,659.25].forEach((fr,i)=>{ const tt=t+i*(0.07-LEVEL*0.003); const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='sine'; o.frequency.value=fr+LEVEL*3; g.gain.setValueAtTime(0.001,tt); g.gain.exponentialRampToValueAtTime(0.12+LEVEL*0.01,tt+0.01); g.gain.exponentialRampToValueAtTime(0.001,tt+0.18);
      o.connect(g).connect(layers.green); o.start(tt); o.stop(tt+0.22); });}
  function lead(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter(); o.type='sine'; o.frequency.value=880+LEVEL*12; f.type='lowpass'; f.frequency.value=1800+LEVEL*120;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16+LEVEL*0.01,t+0.015); g.gain.exponentialRampToValueAtTime(0.0001,t+0.5); o.connect(f).connect(g).connect(layers.red); o.start(t); o.stop(t+0.52);}

  // ====== BGM Engine ======
  function createBgmEngine(){
    const bus={drum:audioCtx.createGain(), bass:audioCtx.createGain(), pad:audioCtx.createGain(), arp:audioCtx.createGain(), lead:audioCtx.createGain(), mix:audioCtx.createGain(),
      stop(){}, start(startTime){ this.scheduleAll(startTime);} };
    [bus.drum,bus.bass,bus.pad,bus.arp,bus.lead].forEach(n=> n.gain.value=0);
    bus.drum.connect(bus.mix); bus.bass.connect(bus.mix); bus.pad.connect(bus.mix); bus.arp.connect(bus.mix); bus.lead.connect(bus.mix); bus.mix.gain.value=0.8; bus.mix.connect(masterGain);

    bus.scheduleAll=(startTime)=>{
      const beatsTotal=64;
      // ★ Lv構成：Lv1=無音, Lv2=Drum, Lv3=+Bass, Lv4=+Pad, Lv5=+Arp & Lead（最高潮）
      const useDrum=LEVEL>=2, useBass=LEVEL>=3, usePad=LEVEL>=4, useArp=LEVEL>=5, useLead=LEVEL>=5;

      const now=audioCtx.currentTime;
      const fade=(node,target)=>{ node.gain.cancelScheduledValues(now); node.gain.setValueAtTime(node.gain.value,now); node.gain.linearRampToValueAtTime(target, now+1.2); };
      fade(bus.drum,useDrum?0.9:0); fade(bus.bass,useBass?0.7:0); fade(bus.pad,usePad?0.55:0); fade(bus.arp,useArp?0.5:0); fade(bus.lead,useLead?0.4:0);

      const beatToTime=(beat)=> startTime + LEADIN + beat*SEC_PER_BEAT;

      if(useDrum){
        [0,2,4,6].forEach(b=> kick(beatToTime(b)));
        [2,6].forEach(b=> snare(beatToTime(b)));
        for(let i=0;i<beatsTotal*2;i++) hat(beatToTime(i*0.5));
        for(let m=0;m<beatsTotal;m+=8){ hat(beatToTime(m+7.5),1.5); }
      }
      if(useBass){
        const root=55;
        for(let m=0;m<beatsTotal;m+=8){
          [0,2,4,6].forEach(off=> bassEv(beatToTime(m+off),root));
          [1,5].forEach(off=> bassEv(beatToTime(m+off),root*1.5));
          [3,7].forEach(off=> bassEv(beatToTime(m+off),root*2));
        }
      }
      if(usePad){
        const prog=[[0,4,7],[2,5,9],[4,7,11],[5,9,12]];
        for(let s=0;s<beatsTotal;s+=8){ const ch=prog[(s/8)%prog.length]; padEv(beatToTime(s),ch,8*SEC_PER_BEAT); }
      }
      if(useArp){
        for(let m=0;m<beatsTotal;m+=8){ for(let b=0;b<8;b+=2){ for(let i=0;i<8;i++){ arpEv(beatToTime(m+b)+i*(SEC_PER_BEAT/4)); } } }
      }
      if(useLead){
        for(let m=16;m<beatsTotal;m+=8){ [0,1.5,3,4.5,6].forEach(off=> leadEv(beatToTime(m+off))); }
      }

      function kick(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.setValueAtTime(140,t); o.frequency.exponentialRampToValueAtTime(55,t+0.12);
        g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.28+(LEVEL-2)*0.02,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18); o.connect(g).connect(bus.drum); o.start(t); o.stop(t+0.2);}
      function snare(t){ const n=audioCtx.createBuffer(1, audioCtx.sampleRate*0.2, audioCtx.sampleRate); const d=n.getChannelData(0);
        for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.exp(-i/(audioCtx.sampleRate*0.03)); }
        const s=audioCtx.createBufferSource(), g=audioCtx.createGain(); g.gain.setValueAtTime(0.001,t); g.gain.exponentialRampToValueAtTime(0.22+(LEVEL-2)*0.02,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.2);
        s.buffer=n; s.connect(g).connect(bus.drum); s.start(t);}
      function hat(t,m=1){ const n=audioCtx.createBuffer(1, audioCtx.sampleRate*0.08, audioCtx.sampleRate); const d=n.getChannelData(0);
        for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.exp(-i/(audioCtx.sampleRate*0.01)); }
        const s=audioCtx.createBufferSource(), g=audioCtx.createGain(); g.gain.setValueAtTime(0.0008*m,t); g.gain.exponentialRampToValueAtTime(0.08*m,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.06);
        s.buffer=n; s.connect(g).connect(bus.drum); s.start(t);}
      function bassEv(t,f0){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter(); o.type='sawtooth'; o.frequency.setValueAtTime(f0,t);
        f.type='lowpass'; f.frequency.setValueAtTime(220+LEVEL*40,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.25+(LEVEL-3)*0.02,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.32);
        o.connect(f).connect(g).connect(bus.bass); o.start(t); o.stop(t+0.36);}
      function padEv(t,semis,dur){ const g=audioCtx.createGain(); g.gain.value=0.0; g.connect(bus.pad); g.gain.linearRampToValueAtTime(0.35,t+0.3); g.gain.linearRampToValueAtTime(0.0,t+dur-0.2);
        semis.forEach(se=>{ const o=audioCtx.createOscillator(), f=audioCtx.createBiquadFilter(); o.type='sine'; o.frequency.value=220*Math.pow(2,se/12); f.type='lowpass'; f.frequency.value=1200+LEVEL*200; o.connect(f).connect(g); o.start(t); o.stop(t+dur); });}
      function arpEv(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=440*Math.pow(2, ((Math.random()<0.5?0:7))/12);
        g.gain.setValueAtTime(0.0008,t); g.gain.exponentialRampToValueAtTime(0.08+(LEVEL-5)*0.01,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.14); o.connect(g).connect(bus.arp); o.start(t); o.stop(t+0.16);}
      function leadEv(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(); o.type='sine'; o.frequency.value=660+LEVEL*8;
        g.gain.setValueAtTime(0.0008,t); g.gain.exponentialRampToValueAtTime(0.12+(LEVEL-5)*0.01,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.28); o.connect(g).connect(bus.lead); o.start(t); o.stop(t+0.3);}
    };
    return bus;
  }

  // ====== Chart ======
  function buildChart(){
    chart = [];
    const blocks=8;
    const chordProb=clamp(0.10+(LEVEL-1)*0.06,0.1,0.5);
    const extraNotes=(LEVEL-1)*2;

    const slotCapPerLane=3, SLOT_Q=0.25;
    const laneSlotCount=new Map();

    let beat=0;
    for(let b=0;b<blocks;b++){
      const base=beat;
      const patt=(b%2===0)? [0,0,2, 2,1, 3, 4, 5.5, 6, 7.5] : [0,1, 1.75, 2.5, 3.25, 4.0,5.0, 6.0, 7.0];
      patt.forEach(off=>{
        const lanes=[randLane()];
        if(Math.random()<chordProb){ let l2=randLane(); if(l2===lanes[0]) l2=(l2+1)%LANE_COUNT; lanes.push(l2); }
        pushWithCap(base+off, lanes);
      });
      for(let i=0;i<extraNotes;i++){ pushWithCap(base+randRange(0,8,true), [randLane()]); }
      beat+=8;
    }
    chart.forEach(n=> n.time = LEADIN + n.beat*SEC_PER_BEAT);

    if(chart.length===0){
      for(let i=0;i<16;i++){ chart.push({beat:i*0.5, time:0, notes:[{lane:(i%LANE_COUNT)}], judged:false, hitCount:0, missed:false}); }
      chart.forEach(n=> n.time = LEADIN + n.beat*SEC_PER_BEAT);
    }
    const approx = chart.reduce((s,n)=> s+n.notes.length, 0);
    targetScore = Math.max(10000, Math.floor(approx*900*0.75));

    function pushWithCap(beat, lanes){
      const outLanes=[]; const slot=Math.round(beat/SLOT_Q)*SLOT_Q;
      for(const lane of lanes){
        if(tryPlace(lane, slot)){ outLanes.push(lane); continue; }
        const alt=(lane+1)%LANE_COUNT;
        if(tryPlace(alt, slot)){ outLanes.push(alt); continue; }
        const slot2=slot+SLOT_Q;
        if(tryPlace(lane, slot2)){ chart.push({beat:slot2, time:0, notes:[{lane}], judged:false, hitCount:0, missed:false}); continue; }
      }
      if(outLanes.length){ chart.push({beat, time:0, notes:outLanes.map(l=>({lane:l})), judged:false, hitCount:0, missed:false}); }
    }
    function tryPlace(lane, slot){ const key=`${lane}@${slot.toFixed(2)}`; const cur=laneSlotCount.get(key)||0; if(cur<slotCapPerLane){ laneSlotCount.set(key, cur+1); return true; } return false; }
    function randLane(){ return (Math.random()*LANE_COUNT)|0; }
    function randRange(a,b,half){ return half ? (a + Math.round(Math.random()*(b-a)*2)/2) : (a + Math.random()*(b-a)); }
  }

  // ====== VFX ======
  function addBurst(x,y,color,count=20,speed=2){ for(let i=0;i<count;i++){ const ang=Math.random()*Math.PI*2, sp=(Math.random()*0.8+0.2)*speed;
    particles.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,life:1,color,type:'burst'}) } }
  function addFireworks(x,y,colors){ const rings=3+Math.min(LEVEL,3); for(let r=0;r<rings;r++){ const c=colors[r%colors.length]; addBurst(x,y,c,28+r*10,2.5+r*0.8); } }
  function addConfetti(n=20){ const W=canvas.width,H=canvas.height, cols=unlockedColors();
    for(let i=0;i<n;i++){ const c=cols[i%cols.length]||'#fff'; particles.push({x:Math.random()*W,y:-20,vx:(Math.random()*2-1)*1.5,vy:Math.random()*2+1,life:1.2,color:c,type:'confetti',rot:Math.random()*Math.PI*2}); } }
  function unlockedColors(){ const arr=[]; for(let i=0;i<=unlockedIndex;i++) arr.push(colorOf(COLOR_ORDER[i])); return arr.length?arr:['#ffffff']; }
  function spawnWind(){ const W=canvas.width,H=canvas.height,n=2+LEVEL; for(let i=0;i<n;i++){ windStreaks.push({x:-50,y:Math.random()*H*0.8,vx:3+LEVEL*0.8,vy:(Math.random()*2-1)*0.2,alpha:0.03+0.02*LEVEL,life:1}); } }

  // ====== World progress ======
  function colorProgress(){ const total=COLOR_ORDER.length*HITS_PER_COLOR; return clamp(((unlockedIndex+1)*HITS_PER_COLOR+goodHitsForColor)/total); }
  const scoreProgress=()=> clamp(score/targetScore);
  const worldProgress=()=> clamp(0.4*colorProgress()+0.6*scoreProgress());
  function applyWorldVisuals(){ const p=worldProgress(); wrap.style.setProperty('--gray',(1-p).toFixed(3));
    const topHue=lerp(220,200,p), topSat=lerp(0.20,0.70,p), topLum=lerp(0.05,0.25,p); const botHue=lerp(220,45,p), botSat=lerp(0.18,0.85,p), botLum=lerp(0.08,0.42,p);
    document.documentElement.style.setProperty('--bg-top',hsl(topHue,topSat,topLum,1)); document.documentElement.style.setProperty('--bg-bot',hsl(botHue,botSat,botLum,1)); wpEl.textContent=Math.round(p*100)+'%'; }

  // ====== Game control ======
  function startGame(){
    endingMode=false; creditsWrap.style.display='none';
    applyLevelParams(); initAudio(); buildChart();
    running=true; score=0; combo=0; hits=0; judgedCount=0; unlockedIndex=-1; goodHitsForColor=0; updateStats();
    ov.style.display='none'; particles.length=0; windStreaks.length=0;
    const now=audioCtx.currentTime; Object.values(layers).forEach(g=>{ g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(0,now); }); melodyBus.gain.setValueAtTime(0.8, now);
    songStartTime = now + 0.10; applyWorldVisuals();
    if(bgm){ bgm.stop(); } if(LEVEL>=2){ bgm.start(songStartTime); }
    requestAnimationFrame(loop);
  }

  function unlockNextColor(){
    if(unlockedIndex>=COLOR_ORDER.length-1) return;
    unlockedIndex++; goodHitsForColor=0;
    const name=COLOR_ORDER[unlockedIndex], now=audioCtx.currentTime, g=layers[name]; if(g){ g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(g.gain.value,now); g.gain.linearRampToValueAtTime(0.7+0.05*LEVEL, now+1.0); }
    const cx=canvas.width/2, cy=canvas.height*0.35, cols=unlockedColors(); addFireworks(cx,cy,cols); addConfetti(25+LEVEL*8);
    floatText(`+ ${name.toUpperCase()}`,'ft-perfect'); applyWorldVisuals();
  }

  // ====== Input ======
  function onTapAtCanvas(clientX){ if(!running||!audioCtx||endingMode) return; const r=canvas.getBoundingClientRect(); const cx=(clientX-r.left)*DPR; judgeTap(laneFromCanvasX(cx)); }
  function onTapButton(){ judgeTap(Math.floor(LANE_COUNT/2)); }
  function judgeTap(lane){
    const t=audioCtx.currentTime - songStartTime;
    let best=null,bestAdt=1e9,bestIdx=-1;
    for(let i=0;i<chart.length;i++){
      const n=chart[i];
      if(n.judged && n.hitCount>=n.notes.length) continue;
      if(!n.notes.some(nt=>nt.lane===lane)) continue;
      const dt=n.time - t, adt=Math.abs(dt);
      if(adt<bestAdt){ bestAdt=adt; best=n; bestIdx=i; }
      if(dt<-GOOD && !n.missed){ n.missed=true; judgedCount++; combo=0; }
    }
    if(!best) return;
    const adiff=Math.abs(best.time - t);
    if(adiff<=PERFECT) applyHit(bestIdx,lane,'perfect');
    else if(adiff<=GOOD) applyHit(bestIdx,lane,'good');
    else { floatText('MISS','ft-miss'); combo=0; updateStats(); }
  }

  boardEl.addEventListener('pointerdown', e=>{ e.preventDefault(); if(e.pointerType==='mouse'&&e.button!==0) return; onTapAtCanvas(e.clientX); }, {passive:false});
  addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); onTapButton(); }}, {passive:false});
  tapBtn.addEventListener('click', onTapButton);
  startBtn.addEventListener('click', async ()=>{ if(!audioCtx){ initAudio(); } try{ if(audioCtx.state!=='running'){ await audioCtx.resume(); } }catch(e){} showStartOverlay(); });

  // ====== Hit / Stats ======
  function applyHit(noteIndex,lane,grade){
    const n=chart[noteIndex]; const part=n.notes.find(nt=>nt.lane===lane); if(!part||part.hit) return; part.hit=true; n.hitCount++; if(n.hitCount>=n.notes.length){ n.judged=true; judgedCount++; }
    const now=audioCtx.currentTime; const add=(grade==='perfect'?1000:650)*(1+Math.floor(combo/25)*0.1); score+=add; combo++; hits++;
    goodHitsForColor++; if(goodHitsForColor>=HITS_PER_COLOR){ unlockNextColor(); }
    playLaneTone(now,lane); colorSfx(now);
    const centers=laneCenters(), x=centers[lane], y=canvas.height*HIT_LINE_RATIO, cols=unlockedColors(); const c=cols[(lane+n.notes.length)%cols.length]||'#ffffff';
    addBurst(x,y,c, Math.round(18+worldProgress()*24)+(n.notes.length>1?8:0), 2.2);
    if([20,40,60].includes(combo)){ addFireworks(canvas.width*0.5, canvas.height*0.3, cols); spawnWind(); addConfetti(15+LEVEL*6); }
    updateStats(); applyWorldVisuals();
  }
  function updateStats(){ scEl.textContent=score|0; coEl.textContent=combo|0; const acc=judgedCount?(hits/judgedCount):1; acEl.textContent=(acc*100).toFixed(0)+'%'; wpEl.textContent=Math.round(worldProgress()*100)+'%'; }

  function floatText(txt, cls){
    const d=document.createElement('div'); d.className=`floatText ${cls}`; d.textContent=txt; d.style.opacity='0'; boardEl.appendChild(d);
    d.animate([{transform:'translate(-50%,-10%) scale(0.9)',opacity:0},{transform:'translate(-50%,-50%) scale(1.0)',opacity:1,offset:.35},{transform:'translate(-50%,-70%) scale(1.1)',opacity:0}], {duration:900,easing:'ease-out'}).onfinish=()=>d.remove();
  }

  // ====== Render ======
  let waveTime=0, auroraTime=0;
  function loop(){
    if(!running || endingMode) return;

    const W=canvas.width,H=canvas.height; ctx.clearRect(0,0,W,H);
    const p=worldProgress(), cols=unlockedColors();

    // BG glow
    const baseHue=lerp(220,60,p), baseCol=hsl(baseHue,lerp(0.25,0.85,p),lerp(0.25,0.55,p), lerp(0.10,0.35,p));
    const g0=ctx.createRadialGradient(W/2,H*0.25,10, W/2,H*0.25, Math.max(W,H)*0.9); g0.addColorStop(0,baseCol); g0.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=g0; ctx.fillRect(0,0,W,H);

    drawLanes(lerp(0.03,0.08,p));

    if(Math.random()<0.01+LEVEL*0.004) spawnWind();
    ctx.lineCap='round'; windStreaks.forEach(w=>{ ctx.globalAlpha=w.alpha; ctx.strokeStyle='white'; ctx.lineWidth=3*DPR; ctx.beginPath(); ctx.moveTo(w.x,w.y); ctx.lineTo(w.x+60,w.y+8); ctx.stroke(); w.x+=w.vx; w.y+=w.vy; w.life-=0.01; });
    windStreaks=windStreaks.filter(w=> w.x<W+80 && w.life>0); ctx.globalAlpha=1;

    if(unlockedIndex>=2){
      waveTime += 0.016 + p*0.008;
      const amp=8*DPR+16*DPR*p, layers=3+LEVEL;
      for(let li=0; li<layers; li++){
        const yy=H*(0.62+0.03*li); ctx.globalAlpha=0.05+0.05*p; ctx.fillStyle=colorOf('blue'); ctx.beginPath(); ctx.moveTo(0,H);
        for(let x=0;x<=W;x+=12*DPR){ const y=yy + Math.sin((x/(80*DPR))+waveTime*(0.6+li*0.1))*amp*(0.5+li*0.2); ctx.lineTo(x,y); }
        ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
      }
      ctx.globalAlpha=1;
    }
    if(p>0.55){
      auroraTime += 0.005 + 0.01*p;
      const bands=2+Math.floor(p*3);
      for(let b=0;b<bands;b++){
        const yy=H*(0.18+0.18*b), grad=ctx.createLinearGradient(0,yy,W,yy);
        const mixCols=cols.length?cols:['#a8b6ff'];
        grad.addColorStop(0, addAlpha(mixCols[b%mixCols.length],0.08)); grad.addColorStop(0.5, addAlpha(mixCols[(b+1)%mixCols.length],0.18)); grad.addColorStop(1, addAlpha(mixCols[(b+2)%mixCols.length],0.08));
        ctx.fillStyle=grad; ctx.globalAlpha=0.5*p; ctx.fillRect(0, yy + Math.sin(auroraTime*1.1+b)*8*DPR, W, 12*DPR); ctx.globalAlpha=1;
      }
    }

    const lineY=H*HIT_LINE_RATIO; ctx.globalAlpha=0.28; ctx.fillStyle='#ffffff'; ctx.fillRect(W*0.1,lineY-2*DPR, W*0.8,4*DPR); ctx.globalAlpha=1;

    const t = audioCtx ? (audioCtx.currentTime - songStartTime) : 0;
    const spawnY=H*SPAWN_RATIO, bottomY=H*BOTTOM_RATIO;

    for(const n of chart){
      if(!n.judged && (t - n.time) > GOOD){ n.missed=true; n.judged=true; judgedCount++; combo=0; updateStats(); }
      const progress = 1 - ((n.time - t) / NOTE_TRAVEL);
      if(progress < -0.2 || progress > 1.3) continue;
      let y; if(progress<=1){ y = spawnY + (lineY - spawnY) * Math.max(0, Math.min(1, progress)); } else { const p2 = Math.min(1,(progress-1)/0.3); y = lineY + (bottomY - lineY) * p2; }
      const centers=laneCenters(); for(const part of n.notes){ const x=centers[part.lane]; const r=16*DPR*(1+0.12*Math.cos(n.beat*0.7))*(n.notes.length>1?1.1:1);
        const cMix=(unlockedColors()[(part.lane + n.notes.length)%unlockedColors().length]||'#d0d7ea');
        ctx.save(); ctx.shadowColor=addAlpha(cMix,0.6); ctx.shadowBlur=r*0.8; ctx.fillStyle=addAlpha(cMix,0.9); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
        ctx.shadowBlur=0; ctx.fillStyle=addAlpha('#ffffff',0.85); ctx.beginPath(); ctx.arc(x,y,r*0.45,0,Math.PI*2); ctx.fill(); ctx.restore();
      }
    }

    for(const ptl of particles){
      if(ptl.type==='confetti'){ ptl.rot+=0.08; ptl.vy+=0.02; ptl.x+=ptl.vx; ptl.y+=ptl.vy; ptl.life-=0.01;
        ctx.save(); ctx.translate(ptl.x,ptl.y); ctx.rotate(ptl.rot); ctx.globalAlpha=Math.max(0,ptl.life); ctx.fillStyle=ptl.color; ctx.fillRect(-4*DPR,-2*DPR,8*DPR,4*DPR); ctx.restore();
      }else{ ptl.x+=ptl.vx; ptl.y+=ptl.vy; ptl.vy+=0.05; ptl.life-=0.02; ctx.globalAlpha=Math.max(0,ptl.life); ctx.fillStyle=ptl.color; ctx.beginPath(); ctx.arc(ptl.x,ptl.y,3*DPR,0,Math.PI*2); ctx.fill(); }
    }
    particles = particles.filter(p=>p.life>0); ctx.globalAlpha=1;

    const lastTime=chart.length?chart[chart.length-1].time:0;
    if(t > lastTime + 3){ endSong(); return; }

    requestAnimationFrame(loop);
  }
  function drawLanes(alpha=0.05){ const W=canvas.width,H=canvas.height, cs=laneCenters(); const laneW=(cs[1]-cs[0])||(W*0.6/LANE_COUNT), w=laneW*0.9;
    cs.forEach(cx=>{ const grad=ctx.createLinearGradient(cx-w/2,0,cx+w/2,0); grad.addColorStop(0,`rgba(255,255,255,${alpha})`); grad.addColorStop(0.5,`rgba(255,255,255,${alpha*1.8})`); grad.addColorStop(1,`rgba(255,255,255,${alpha})`); ctx.fillStyle=grad; ctx.fillRect(cx-w/2,0,w,H); });
  }

  // ====== Results / Ending ======
  function endSong(){
    running=false; wrap.style.setProperty('--gray','0'); applyWorldVisuals();
    const acc = judgedCount?(hits/judgedCount):1; const worldPct=Math.round(worldProgress()*100);
    if(LEVEL>=MAX_LEVEL){
      showResultCard(true, acc, worldPct);
      // 自動でエンディング再生
      setTimeout(()=> playEnding(score, acc, worldPct), 800);
    }else{
      showResultCard(false, acc, worldPct);
    }
  }

  function showResultCard(isFinal, acc, worldPct){
    const title = isFinal ? `Final Results — Lv.${LEVEL} (MAX)` : `Results — Lv.${LEVEL}`;
    const nextBtnLabel = isFinal ? 'Watch Ending' : 'Next Level';
    card.innerHTML = `
      <div class="logo"><span class="dot"></span><span class="word">MONOCHROME REBIRTH</span><span class="dot"></span></div>
      <h1>${title}</h1>
      <p>SCORE: <b>${score|0}</b></p>
      <p>COMBO: <b>${combo|0}</b> &nbsp; ACC: <b>${(acc*100).toFixed(1)}%</b></p>
      <p>WORLD: <b>${worldPct}%</b></p>
      <div class="bar" style="margin:12px 0 14px"><span style="width:${worldPct}%"></span></div>
      <div style="display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap">
        <button class="btn" id="retryBtn">Retry</button>
        <button class="btn primary" id="nextBtn">${nextBtnLabel}</button>
        <button class="btn" id="closeBtn">Close</button>
      </div>
    `;
    ov.style.display='flex';
    document.getElementById('retryBtn').onclick = ()=>{ ov.style.display='none'; startGame(); };
    document.getElementById('nextBtn').onclick  = ()=>{
      ov.style.display='none';
      if(LEVEL>=MAX_LEVEL){ playEnding(score, acc, worldPct); }
      else { LEVEL++; startGame(); }
    };
    document.getElementById('closeBtn').onclick = ()=> ov.style.display='none';
  }

  // ====== Ending Movie ======
  function playEnding(finalScore, acc, worldPct){
    endingMode=true; particles.length=0; windStreaks.length=0; ov.style.display='none';
    // ティア分岐（色・密度・エフェクト量を変える）
    const accPct = acc*100;
    const tier = (finalScore>30000 && accPct>95 && worldPct>90) ? 'AURORA'
               : (finalScore>22000 && accPct>90) ? 'WAVE'
               : 'BLOOM';

    // BGM（エンディング専用：静かなパッド＋ベル＋広いリバーブ感の擬似）
    startEndingBgm(tier);

    // ムービーの時間管理
    const duration = 26000; // ms
    const startMs = performance.now();
    const colsAll = ['#ffd166','#5af38f','#6ab8ff','#ff6b6b'];

    function renderEnding(nowMs){
      const W=canvas.width,H=canvas.height;
      ctx.clearRect(0,0,W,H);

      const t = (nowMs - startMs)/1000; // s 0 -> 26
      // グラデの世界（全色ミックス）
      const hueBase = 45 + Math.sin(t*0.15)*25;
      const top = hsl(hueBase, 0.8, 0.35, 0.6);
      const bot = hsl(hueBase+120, 0.85, 0.45, 0.85);
      const gbg = ctx.createLinearGradient(0,0,0,H);
      gbg.addColorStop(0, top); gbg.addColorStop(1, bot);
      ctx.fillStyle = gbg; ctx.fillRect(0,0,W,H);

      // レインボーリボン（Bezier帯）
      const bands = tier==='AURORA'? 6 : (tier==='WAVE'?4:3);
      for(let i=0;i<bands;i++){
        const c = colsAll[i%colsAll.length];
        const amp = (tier==='AURORA'? 80: 60) * DPR;
        const y0 = H*0.3 + Math.sin(t*0.4 + i)*amp*0.1;
        const y1 = H*0.5 + Math.sin(t*0.6 + i*0.7)*amp*0.15;
        const y2 = H*0.7 + Math.sin(t*0.8 + i*1.1)*amp*0.12;
        ctx.globalAlpha = 0.14 + 0.06*Math.sin(t*1.2+i);
        ctx.strokeStyle = addAlpha(c, 0.85);
        ctx.lineWidth = (12 + i*4) * DPR;
        ctx.beginPath();
        ctx.moveTo(0, y0);
        ctx.bezierCurveTo(W*0.33, y1, W*0.66, y2, W, H*0.5 + Math.sin(t*0.5+i)*amp*0.05);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // 花火／オーロラ／波の重ね
      if(tier!=='BLOOM'){ // WAVE/AURORA
        const waveAmp = (tier==='AURORA'? 18:14)*DPR;
        for(let li=0; li<(tier==='AURORA'? 6:4); li++){
          const yy = H*(0.60 + 0.03*li);
          ctx.globalAlpha = 0.07 + 0.05*Math.sin(t*0.7+li);
          ctx.fillStyle = colsAll[(li)%colsAll.length];
          ctx.beginPath();
          ctx.moveTo(0,H);
          for(let x=0;x<=W;x+=10*DPR){
            const y = yy + Math.sin((x/(80*DPR))+t*(0.9+li*0.12))*waveAmp*(0.6+li*0.15);
            ctx.lineTo(x,y);
          }
          ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
        }
        ctx.globalAlpha=1;
      }

      // ランダムな光の花（BLOOM向け強め、上位ティアは控えめ）
      const bloomChance = tier==='BLOOM'? 0.25 : 0.12;
      if(Math.random()<bloomChance){
        const x = Math.random()*W, y = H*(0.25 + Math.random()*0.6);
        const c = colsAll[(Math.random()*colsAll.length)|0];
        addBurst(x,y,c, 16+(tier==='AURORA'?12:6), 2.4);
      }

      // 粒子描画
      for(const ptl of particles){
        ptl.x+=ptl.vx; ptl.y+=ptl.vy; ptl.vy+=0.01; ptl.life-=0.015;
        ctx.globalAlpha=Math.max(0,ptl.life); ctx.fillStyle=ptl.color; ctx.beginPath(); ctx.arc(ptl.x,ptl.y,2.8*DPR,0,Math.PI*2); ctx.fill();
      }
      particles = particles.filter(p=>p.life>0);
      ctx.globalAlpha=1;

      // タイトルテキスト（フェードイン→アウト）
      if(t<4.5){
        const a = Math.min(1, Math.max(0, (t-0.6)/1.2 ));
        ctx.globalAlpha = a*0.9;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.font = `${Math.round(32*DPR)}px system-ui, -apple-system, sans-serif`;
        ctx.textAlign='center'; ctx.fillText('THE WORLD REBORN', W/2, H*0.22);
        ctx.globalAlpha=1;
      }

      // 終了判定
      if(nowMs - startMs < duration){
        requestAnimationFrame(renderEnding);
      }else{
        // スタッフロール表示
        showCredits(finalScore, acc, worldPct);
      }
    }
    requestAnimationFrame(renderEnding);
  }

  function startEndingBgm(tier){
    if(!audioCtx) return;
    if(endingBgm){ /* no persistent state needed */ }
    const pad = audioCtx.createGain(); pad.gain.value=0; pad.connect(masterGain);
    const bell= audioCtx.createGain(); bell.gain.value=0; bell.connect(masterGain);
    const rev  = audioCtx.createDelay(); rev.delayTime.value=0.28;
    const fb   = audioCtx.createGain(); fb.gain.value=0.45;
    bell.connect(rev).connect(fb).connect(rev); rev.connect(masterGain);

    const now=audioCtx.currentTime;
    // Soft pad chord loop
    const chord=[[0,4,7],[2,5,9],[4,7,11],[5,9,12]];
    chord.forEach((ch,idx)=>{
      const t = now + 0.6 + idx*2.5;
      const g=audioCtx.createGain(); g.gain.value=0; g.connect(pad);
      g.gain.linearRampToValueAtTime(0.45, t+0.8); g.gain.linearRampToValueAtTime(0.0, t+2.2);
      ch.forEach(se=>{ const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=220*Math.pow(2,se/12); o.connect(g); o.start(t); o.stop(t+2.4); });
    });
    pad.gain.linearRampToValueAtTime(tier==='AURORA'?0.6: tier==='WAVE'?0.5:0.42, now+1.0);

    // Bell twinkles
    for(let i=0;i<28;i++){
      const t = now + 1.0 + i*(0.45 - (tier==='AURORA'?0.08: tier==='WAVE'?0.04:0.0)) + Math.random()*0.12;
      const f = 660 * Math.pow(2, (Math.random()<0.5?0:7)/12);
      const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='triangle'; o.frequency.value=f;
      g.gain.setValueAtTime(0.0008,t); g.gain.exponentialRampToValueAtTime(0.09, t+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t+0.20);
      o.connect(g).connect(bell); o.start(t); o.stop(t+0.25);
    }
    bell.gain.linearRampToValueAtTime(0.55, now+1.2);
  }

  function showCredits(finalScore, acc, worldPct){
    // クレジット本文（指定どおり）
    const body =
`PRODUCER
Hisashi Fujinaka

DIRECTOR
Hisashi Fujinaka

ART DIRECTOR
Hisashi Fujinaka

SOUND DIRECTOR
Hisashi Fujinaka

GAME DESIGN
Hisashi Fujinaka

ENGINEERING LEAD
Hisashi Fujinaka

CODING DIRECTOR
ChatGPT

SPECIAL THANKS
All Players

SCORE ${finalScore|0}  /  ACC ${(acc*100).toFixed(1)}%  /  WORLD ${worldPct}%

MONOCHROME REBIRTH
© Hisashi Fujinaka`;

    creditsText.textContent = body;
    creditsWrap.style.display='flex';
    // クレジット終了後に再スタートUI
    setTimeout(()=>{
      ov.style.display='flex';
      card.innerHTML = `
        <div class="logo"><span class="dot"></span><span class="word">MONOCHROME REBIRTH</span><span class="dot"></span></div>
        <h1>Thank You for Playing</h1>
        <p>世界は色を取り戻した。</p>
        <div style="display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;margin-top:10px">
          <button class="btn" id="again">Play Again (Lv1)</button>
          <button class="btn primary" id="stay">Stay</button>
        </div>
      `;
      document.getElementById('again').onclick = ()=>{ creditsWrap.style.display='none'; LEVEL=1; startGame(); };
      document.getElementById('stay').onclick = ()=>{ creditsWrap.style.display='none'; ov.style.display='none'; };
    }, 29000);
  }

  // ====== Minimal Start overlay ======
  function showStartOverlay(){
    card.innerHTML = `
      <div class="logo"><span class="dot"></span><span class="word">MONOCHROME REBIRTH</span><span class="dot"></span></div>
      <div class="sub">Tap the rhythm — bring back the colors</div>
      <div style="display:flex;gap:10px;justify-content:center;margin-top:16px;flex-wrap:wrap">
        <button class="btn primary wide" id="ovStart">Start</button>
        <button class="btn" id="ovLvUp" title="難易度を1上げる">Lv+1</button>
      </div>
    `;
    ov.style.display='flex';
    document.getElementById('ovStart').onclick = async ()=>{ if(!audioCtx){ initAudio(); } try{ if(audioCtx.state!=='running'){ await audioCtx.resume(); } }catch(e){} ov.style.display='none'; startGame(); };
    document.getElementById('ovLvUp').onclick = ()=>{ if(LEVEL<MAX_LEVEL){ LEVEL++; lvEl.textContent=LEVEL; } };
  }

  // ====== Boot ======
  showStartOverlay();

})();
</script>
</body>
</html>
