<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Monochrome Rebirth – Rhythm of Colors</title>
<style>
  :root{
    --gray: 1;                /* 1 = モノクロ, 0 = フルカラー（JSで上書き） */
    --bg-top:#0b0f15;         /* 進行度に応じてJSから更新 */
    --bg-bot:#0e1220;         /* 進行度に応じてJSから更新 */
    --yellow:#ffd166; --green:#5af38f; --blue:#6ab8ff; --red:#ff6b6b;
    --hit-top: 75%;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(var(--bg-top),var(--bg-bot));color:#e9eefc;font-family:system-ui,-apple-system,"Hiragino Sans","Noto Sans JP",sans-serif}
  .wrap{height:100%;display:flex;align-items:center;justify-content:center;filter:grayscale(var(--gray));transition:filter .8s ease}
  .game{width:min(920px,100%);max-width:920px;padding:12px}
  .topbar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px}
  .stat{display:flex;gap:12px;font-size:14px;color:#bcd1ff}
  .badge{padding:4px 10px;border:1px solid #283248;border-radius:999px;background:rgba(255,255,255,.04)}
  .title{font-weight:700;letter-spacing:.4px;color:#e9eefc}
  .stage{font-size:12px;opacity:.9}

  .board{
    position:relative;border:1px solid #243049;border-radius:12px;overflow:hidden;background:
      radial-gradient(1000px 400px at 50% 20%, rgba(255,255,255,.04), transparent 60%),
      linear-gradient(180deg, var(--bg-top), var(--bg-bot));
    height:68vh;min-height:440px;touch-action:none;
  }
  canvas{position:absolute;inset:0;display:block;width:100%;height:100%}

  .centerHud{position:absolute;left:0;right:0;top:12px;display:flex;justify-content:center;gap:12px;pointer-events:none;flex-wrap:wrap}
  .chip{font-size:12px;border:1px solid #3a455d;background:rgba(255,255,255,.05);padding:6px 10px;border-radius:999px}
  .chip strong{color:#fff}

  .hitLine{
    position:absolute; left:0; right:0; top: var(--hit-top, 75%);
    border-top:2px dashed rgba(255,255,255,.28);
  }

  .controls{position:absolute;left:0;right:0;bottom:10px;display:flex;gap:10px;justify-content:center}
  .btn{
    -webkit-tap-highlight-color:transparent;
    border:1px solid #33415f;background:linear-gradient(180deg,#1a2234,#151b29);
    color:#e9eefc;border-radius:12px;padding:10px 14px;font-weight:600;letter-spacing:.3px;cursor:pointer;
    box-shadow:0 8px 24px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.06);
  }
  .btn:active{transform:translateY(1px)}
  .btn.primary{border-color:#5063ff;background:linear-gradient(180deg,#2b36aa,#20297e)}
  .btn.wide{min-width:160px}

  .overlay{
    position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter:blur(2px)
  }
  .card{width:min(560px,92%);background:linear-gradient(180deg,#131a28,#0f1422);border:1px solid #2a3552;border-radius:16px;padding:18px;box-shadow:0 16px 40px rgba(0,0,0,.45)}
  .card h1{margin:0 0 8px;font-size:24px}
  .card p{margin:6px 0;color:#cfe0ff;font-size:14px}
  .bar{height:10px;background:#111827;border:1px solid #26324b;border-radius:999px;overflow:hidden}
  .bar > span{display:block;height:100%;width:0;background:linear-gradient(90deg,#ffd166,#5af38f,#6ab8ff,#ff6b6b)}
  .colors{display:flex;gap:8px;margin-top:10px}
  .dot{width:18px;height:18px;border-radius:50%;border:1px solid #2a3552;opacity:.35}
  .dot.yellow{background:var(--yellow)}
  .dot.green{background:var(--green)}
  .dot.blue{background:var(--blue)}
  .dot.red{background:var(--red)}
  .dot.on{opacity:1;box-shadow:0 0 14px currentColor}

  .floatText{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-weight:800;letter-spacing:1px;pointer-events:none;text-shadow:0 2px 10px rgba(0,0,0,.45)}
  .ft-perfect{color:#fff}
  .ft-good{color:#cfe0ff}
  .ft-miss{color:#fda4af}

  @media (max-width:560px){
    .btn.wide{min-width:140px}
  }
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="game">
    <div class="topbar">
      <div class="title">Monochrome Rebirth – <span class="stage">Rhythm of Colors</span></div>
      <div class="stat">
        <div class="badge">SCORE: <span id="sc">0</span></div>
        <div class="badge">COMBO: <span id="co">0</span></div>
        <div class="badge">ACCURACY: <span id="ac">100%</span></div>
        <div class="badge">WORLD: <span id="wp">0%</span></div>
      </div>
    </div>

    <div class="board" id="board">
      <canvas id="cv"></canvas>
      <div class="centerHud">
        <div class="chip">BPM: <strong id="bpmTxt">80</strong></div>
        <div class="chip">LANES: <strong id="lanesTxt">4</strong></div>
        <div class="chip">WINDOW: <strong>Perfect ±50ms / Good ±150ms</strong></div>
        <div class="chip">TAP: <strong>レーン上をタップ</strong></div>
      </div>
      <div class="hitLine"></div>

      <div class="controls">
        <button class="btn" id="tapBtn" title="中央レーンを叩く（Spaceでも可）">Tap / Space</button>
        <button class="btn primary wide" id="startBtn">Start</button>
      </div>

      <div class="overlay" id="ov">
        <div class="card">
          <h1 id="ovTitle">Monochrome Rebirth</h1>
          <p id="ovMsg">白と黒の世界。リズムで色と音を取り戻そう。</p>
          <div class="colors">
            <div class="dot yellow" id="dotY"></div>
            <div class="dot green"  id="dotG"></div>
            <div class="dot blue"   id="dotB"></div>
            <div class="dot red"    id="dotR"></div>
          </div>
          <p style="margin-top:10px">色の回復度</p>
          <div class="bar"><span id="bar"></span></div>
          <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px">
            <button class="btn" id="retryBtn">Retry</button>
            <button class="btn primary" id="closeBtn">Close</button>
          </div>
        </div>
      </div>

    </div>
    <p style="margin:8px 2px 0;font-size:12px;color:#9fb3df">操作：キャンバス上の各レーンをタップ（スマホOK）／スペースキーは中央付近。音が出ない場合は「Start」を押してください。</p>
  </div>
</div>

<script>
(() => {
  // ====== Parameters ======
  const BPM = 80;
  const SEC_PER_BEAT = 60 / BPM;
  const LEADIN = 1.0;
  const NOTE_TRAVEL = 2.0;
  const PERFECT = 0.050;
  const GOOD = 0.150;
  const SONG_BEATS = 64;

  const COLOR_ORDER = ['yellow','green','blue','red'];
  const HITS_PER_COLOR = 12;

  // Lanes / melody
  const LANE_COUNT = 4;
  const LANE_SCALE = [261.63, 293.66, 329.63, 392.00]; // C4 D4 E4 G4
  const HIT_LINE_RATIO = 0.75;
  const SPAWN_RATIO    = 0.10;
  const BOTTOM_RATIO   = 0.92;

  // ====== DOM ======
  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  const boardEl = document.getElementById('board');
  const scEl = document.getElementById('sc');
  const coEl = document.getElementById('co');
  const acEl = document.getElementById('ac');
  const wpEl = document.getElementById('wp');
  const startBtn = document.getElementById('startBtn');
  const tapBtn = document.getElementById('tapBtn');
  const ov = document.getElementById('ov');
  const retryBtn = document.getElementById('retryBtn');
  const closeBtn = document.getElementById('closeBtn');
  const barEl = document.getElementById('bar');
  const dotY = document.getElementById('dotY');
  const dotG = document.getElementById('dotG');
  const dotB = document.getElementById('dotB');
  const dotR = document.getElementById('dotR');
  const bpmTxt = document.getElementById('bpmTxt');
  const lanesTxt = document.getElementById('lanesTxt');
  bpmTxt.textContent = BPM;
  lanesTxt.textContent = LANE_COUNT;

  // ====== Resize ======
  let DPR = window.devicePixelRatio || 1;
  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    DPR = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(rect.width  * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    document.documentElement.style.setProperty('--hit-top', (HIT_LINE_RATIO*100).toFixed(1)+'%');
  }
  addEventListener('resize', fitCanvas, {passive:true});
  fitCanvas();

  // ====== State ======
  let audioCtx = null, masterGain = null;
  let layers = {};
  let melodyGain = null;
  let particles = [];
  let mistTime = 0;                  // 光の筋アニメ用時間
  let running = false;

  let chart = [];
  let songStartTime = 0;
  let score = 0, combo = 0, hits = 0, judgedCount = 0;
  let unlockedIndex = -1;
  let goodHitsForColor = 0;

  let targetScore = 8000;           // 進行度用の目標スコア（buildChart後に再設定）

  // ====== Helpers ======
  const clamp = (v,min=0,max=1)=>Math.max(min,Math.min(max,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;

  function hsl(h,s,l,a=1){
    return `hsla(${h},${(s*100).toFixed(1)}%,${(l*100).toFixed(1)}%,${a})`;
  }

  // ====== Lanes geometry ======
  function laneCenters(){
    const W = canvas.width;
    const padding = 60 * DPR;
    const innerW = W - padding*2;
    const gap = innerW / (LANE_COUNT);
    const centers = [];
    for(let i=0;i<LANE_COUNT;i++){
      centers.push(padding + gap*(i+0.5));
    }
    return centers;
  }
  function laneFromCanvasX(cx){
    const centers = laneCenters();
    let best=0,min=1e9;
    for(let i=0;i<centers.length;i++){
      const d = Math.abs(cx - centers[i]);
      if(d < min){ min = d; best = i; }
    }
    return best;
  }

  // ====== Chart (multi-lane melody) ======
  function buildChart(){
    chart = [];
    let beat=0;
    for(let block=0; block<8; block++){
      const base = beat;
      if(block%2===0){
        push(base+0,0); push(base+0,2);
        push(base+2,1); push(base+3,3);
        push(base+4,0); push(base+5.5,2);
        push(base+6,1); push(base+7.5,3);
      }else{
        push(base+0,1); push(base+1,2);
        push(base+2.5,0); push(base+3.0,3);
        push(base+4.0,2); push(base+5.5,1);
        push(base+6.5,3);
      }
      beat += 8;
    }
    chart.forEach(n => n.time = LEADIN + n.beat * SEC_PER_BEAT);

    function push(beat,lane){ chart.push({ beat, time:0, lane, judged:false, hit:false, missed:false }); }

    // 目標スコア（Perfect 80%想定）
    const maxPerNote = 1000; // perfect
    targetScore = Math.max(6000, Math.floor(chart.length * maxPerNote * 0.8));
  }

  // ====== Audio ======
  function initAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.9;
    masterGain.connect(audioCtx.destination);

    // Ambient Pad
    const amb = makePad({freqs:[110, 220, 330], gain:0.06});
    amb.connect(masterGain);

    layers.yellow = makeLayerGain();
    layers.green  = makeLayerGain();
    layers.blue   = makeLayerGain();
    layers.red    = makeLayerGain();

    melodyGain = audioCtx.createGain();
    melodyGain.gain.value = 0.7;
    melodyGain.connect(masterGain);
  }
  function makeLayerGain(){ const g = audioCtx.createGain(); g.gain.value=0; g.connect(masterGain); return g; }
  function makePad({freqs, gain}){
    const g = audioCtx.createGain(); g.gain.value = gain;
    freqs.forEach(f=>{
      const o = audioCtx.createOscillator();
      const env = audioCtx.createGain(); env.gain.value = 0.0008;
      o.type='sine'; o.frequency.value=f; o.connect(env).connect(g); o.start();
      const lfo = audioCtx.createOscillator(); const lfoGain = audioCtx.createGain();
      lfo.frequency.value = 0.07; lfoGain.gain.value = f*0.015; lfo.connect(lfoGain).connect(o.frequency); lfo.start();
    });
    return g;
  }
  function playLaneTone(time, lane){
    if(!audioCtx) return;
    const freq = LANE_SCALE[Math.max(0, Math.min(LANE_SCALE.length-1, lane))];
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 1800;
    o.type='sine'; o.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.22, time+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, time+0.45);
    o.connect(f).connect(g).connect(melodyGain);
    o.start(time); o.stop(time+0.5);
  }
  function colorSfx(time){
    const name = COLOR_ORDER[Math.max(0, unlockedIndex)];
    if(!name) return;
    if(name==='yellow'){ softKick(time); bell(time+0.02); }
    if(name==='green'){ arp(time); }
    if(name==='blue'){ bass(time); }
    if(name==='red'){ lead(time); }
  }
  function softKick(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='sine'; o.frequency.setValueAtTime(130,t); o.frequency.exponentialRampToValueAtTime(55,t+0.12);
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.25,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18);
    o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.2);
  }
  function bell(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='triangle'; o.frequency.value=660;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.14,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.5);
    o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.6);
  }
  function bass(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter();
    o.type='sawtooth'; o.frequency.value=55; f.type='lowpass'; f.frequency.value=180;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.18,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.3);
    o.connect(f).connect(g).connect(layers.blue); o.start(t); o.stop(t+0.35);
  }
  function arp(t){ [440,523.25,587.33,659.25].forEach((fr,i)=>{
      const tt=t+i*0.07; const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='sine'; o.frequency.value=fr;
      g.gain.setValueAtTime(0.001,tt); g.gain.exponentialRampToValueAtTime(0.12,tt+0.01); g.gain.exponentialRampToValueAtTime(0.001,tt+0.18);
      o.connect(g).connect(layers.green); o.start(tt); o.stop(tt+0.22);
    });
  }
  function lead(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter();
    o.type='sine'; o.frequency.value=880; f.type='lowpass'; f.frequency.value=1800;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16,t+0.015); g.gain.exponentialRampToValueAtTime(0.0001,t+0.5);
    o.connect(f).connect(g).connect(layers.red); o.start(t); o.stop(t+0.52);
  }

  // ====== Particles ======
  function addBurst(x,y,color,count=20){
    for(let i=0;i<count;i++){
      particles.push({ x, y, vx:(Math.random()*2-1)*2, vy:(Math.random()*2-1)*2 - 2, life:1.0, color });
    }
  }

  // ====== World Visual Progress ======
  function colorProgress(){
    const total = COLOR_ORDER.length * HITS_PER_COLOR;
    const cur = clamp(((unlockedIndex+1)*HITS_PER_COLOR + goodHitsForColor)/total);
    return cur;
  }
  function scoreProgress(){
    return clamp(score / targetScore);
  }
  function worldProgress(){
    // スコア寄りに重み（メロディをうまく刻むほど背景が美しく）
    return clamp(0.4*colorProgress() + 0.6*scoreProgress());
  }
  function applyWorldVisuals(){
    const p = worldProgress();               // 0..1
    // 彩度：モノクロ→カラー（wrapのgrayscaleを下げる）
    wrap.style.setProperty('--gray', (1-p).toFixed(3));

    // 背景グラデーション：群青→暁→金色
    // 上（空の色）
    const topHue = lerp(220, 200, p);        // 群青→薄青
    const topSat = lerp(0.20, 0.70, p);
    const topLum = lerp(0.05, 0.25, p);
    // 下（地平の色）
    const botHue = lerp(220, 45, p);         // 群青→オレンジ/金
    const botSat = lerp(0.18, 0.85, p);
    const botLum = lerp(0.08, 0.40, p);

    const top = hsl(topHue, topSat, topLum, 1);
    const bot = hsl(botHue, botSat, botLum, 1);
    document.documentElement.style.setProperty('--bg-top', top);
    document.documentElement.style.setProperty('--bg-bot', bot);

    // 画面上HUD表示
    wpEl.textContent = Math.round(p*100)+'%';
  }

  // ====== Game Control ======
  function startGame(){
    initAudio();
    buildChart();
    running = true;
    score = 0; combo = 0; hits = 0; judgedCount = 0;
    unlockedIndex = -1; goodHitsForColor = 0;
    updateStats();
    barEl.style.width = '0%';
    ov.style.display = 'none';

    const now = audioCtx.currentTime;
    Object.values(layers).forEach(g => { g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(0, now); });
    melodyGain.gain.setValueAtTime(0.7, now);

    songStartTime = now + 0.05;
    applyWorldVisuals(); // 初期適用
    requestAnimationFrame(loop);
  }

  function unlockNextColor(){
    if(unlockedIndex >= COLOR_ORDER.length-1) return;
    unlockedIndex++;
    const name = COLOR_ORDER[unlockedIndex];
    goodHitsForColor = 0;

    // レイヤーfade-in
    const now = audioCtx.currentTime;
    const g = layers[name];
    if(g){ g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(g.gain.value, now); g.gain.linearRampToValueAtTime(0.7, now+1.0); }

    // 祝砲
    const center = canvas.height * 0.55;
    addBurst(canvas.width/2, center, colorOf(name), 48);
    floatText(`+ ${labelOf(name)} 解放！`, 'ft-perfect');
    updateDots();
    applyWorldVisuals();
  }

  function updateDots(){
    [dotY,dotG,dotB,dotR].forEach(el=>el.classList.remove('on'));
    if(unlockedIndex>=0) dotY.classList.add('on');
    if(unlockedIndex>=1) dotG.classList.add('on');
    if(unlockedIndex>=2) dotB.classList.add('on');
    if(unlockedIndex>=3) dotR.classList.add('on');
  }
  function labelOf(c){ return {yellow:'黄',green:'緑',blue:'青',red:'赤'}[c]||c; }
  function colorOf(c){ return {'yellow':'#ffd166','green':'#5af38f','blue':'#6ab8ff','red':'#ff6b6b'}[c]||'#ffffff'; }

  // ====== Input ======
  function onTapAtCanvas(clientX){
    if(!running || !audioCtx) return;
    const rect = canvas.getBoundingClientRect();
    const cx = (clientX - rect.left) * DPR;
    const lane = laneFromCanvasX(cx);
    judgeTap(lane);
  }
  function onTapButton(){
    const lane = Math.floor(LANE_COUNT/2);
    judgeTap(lane);
  }
  function judgeTap(lane){
    const t = audioCtx.currentTime - songStartTime;
    let best = null, bestAdt = 1e9;
    for(const n of chart){
      if(n.judged || n.lane !== lane) continue;
      const dt = n.time - t;
      const adt = Math.abs(dt);
      if(adt < bestAdt){ bestAdt = adt; best = n; }
      if(dt < -GOOD && !n.missed){ n.judged = true; n.missed = true; judgedCount++; }
    }
    if(!best) return;
    const adiff = Math.abs(best.time - t);
    if(adiff <= PERFECT) applyHit(best, 'perfect');
    else if(adiff <= GOOD) applyHit(best, 'good');
    else { floatText('MISS', 'ft-miss'); combo = 0; updateStats(); }
  }

  boardEl.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    onTapAtCanvas(e.clientX);
  }, {passive:false});
  addEventListener('keydown', (e)=>{ if(e.code === 'Space'){ e.preventDefault(); onTapButton(); }}, {passive:false});
  tapBtn.addEventListener('click', onTapButton);
  startBtn.addEventListener('click', ()=>{
    if(!audioCtx || audioCtx.state !== 'running'){ initAudio(); audioCtx.resume(); }
    startGame();
  });
  retryBtn.addEventListener('click', startGame);
  closeBtn.addEventListener('click', ()=> ov.style.display='none');

  // ====== Judgement ======
  function applyHit(n, grade){
    n.judged = true; n.hit = true; judgedCount++;
    const now = audioCtx.currentTime;

    const add = (grade==='perfect'? 1000 : 600) * (1 + Math.floor(combo/25)*0.1);
    score += add; combo++; hits++;

    // 色ゲージ
    goodHitsForColor++;
    if(goodHitsForColor >= HITS_PER_COLOR){ unlockNextColor(); }
    const progress = clamp(((unlockedIndex+1)*HITS_PER_COLOR + goodHitsForColor) / (COLOR_ORDER.length*HITS_PER_COLOR));
    barEl.style.width = (progress*100).toFixed(1)+'%';

    // 音と演出
    playLaneTone(now, n.lane);
    colorSfx(now);

    // 進行度に応じてパーティクルを増量
    const centers = laneCenters();
    const x = centers[n.lane];
    const y = canvas.height * HIT_LINE_RATIO;
    const cname = COLOR_ORDER[Math.max(0, unlockedIndex)];
    const c = unlockedIndex<0 ? '#ffffff' : colorOf(cname);
    const density = Math.round(16 + worldProgress()*24); // 16〜40粒
    addBurst(x, y, c, grade==='perfect'? density+10 : density);

    floatText(grade.toUpperCase(), grade==='perfect'?'ft-perfect':'ft-good');

    updateStats();
    applyWorldVisuals();
  }

  function updateStats(){
    scEl.textContent = score|0;
    coEl.textContent = combo|0;
    const acc = judgedCount ? (hits/judgedCount) : 1;
    acEl.textContent = (acc*100).toFixed(0)+'%';
    wpEl.textContent = Math.round(worldProgress()*100)+'%';
  }

  // ====== Floats ======
  function floatText(txt, cls){
    const d = document.createElement('div');
    d.className = `floatText ${cls}`;
    d.textContent = txt;
    d.style.opacity = '0';
    document.getElementById('board').appendChild(d);
    d.animate(
      [{transform:'translate(-50%,-10%) scale(0.9)',opacity:0},
       {transform:'translate(-50%,-50%) scale(1.0)',opacity:1,offset:.35},
       {transform:'translate(-50%,-70%) scale(1.1)',opacity:0}],
      {duration:900,easing:'ease-out'}
    ).onfinish = ()=> d.remove();
  }

  // ====== Render ======
  function loop(){
    if(!running) return;

    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    const p = worldProgress();

    // 背景ラディアルグロー（進行度で強度アップ）
    const baseHue = lerp(220, 60, p);
    const baseCol = hsl(baseHue, lerp(0.25,0.85,p), lerp(0.25,0.55,p), lerp(0.10,0.35,p));
    const g = ctx.createRadialGradient(W/2, H*0.25, 10, W/2, H*0.25, Math.max(W,H)*0.9);
    g.addColorStop(0, baseCol);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // レーン背景ガイド（薄く）
    drawLanes(lerp(0.03, 0.08, p));

    // 光の筋（mist）— 進行度で出現・強度増
    mistTime += 0.008 + p*0.012;
    drawMistLayers(p);

    // 花弁の装飾（0.6以降で出現、0.9で最大）
    if(p > 0.6){ drawPetals( (p-0.6)/0.4 ); }

    // 判定ライン
    const lineY = H * HIT_LINE_RATIO;
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(W*0.1, lineY-2*DPR, W*0.8, 4*DPR);
    ctx.globalAlpha = 1;

    // 時刻
    const t = audioCtx ? (audioCtx.currentTime - songStartTime) : 0;

    const spawnY  = H * SPAWN_RATIO;
    const bottomY = H * BOTTOM_RATIO;

    // ノーツ
    for(const n of chart){
      if(!n.judged && (t - n.time) > GOOD){
        n.judged = true; n.missed = true; judgedCount++; combo = 0; updateStats();
      }
      const progress = 1 - ((n.time - t) / NOTE_TRAVEL);
      if(progress < -0.2 || progress > 1.25) continue;

      let y;
      if(progress <= 1){
        y = spawnY + (lineY - spawnY) * Math.max(0, Math.min(1, progress));
      }else{
        const p2 = Math.min(1, (progress-1)/(0.25));
        y = lineY + (bottomY - lineY) * p2;
      }

      const centers = laneCenters();
      const x = centers[n.lane];
      const r = 18*DPR * (1 + 0.12*Math.cos(n.beat*0.7));

      let col = '#d0d7ea';
      if(unlockedIndex>=0){ col = colorOf(COLOR_ORDER[Math.min(unlockedIndex, COLOR_ORDER.length-1)]); }
      drawNote(x, y, r, col);
    }

    // パーティクル
    for(const ptl of particles){ ptl.x+=ptl.vx; ptl.y+=ptl.vy; ptl.vy+=0.05; ptl.life-=0.02; }
    particles = particles.filter(ptl=>ptl.life>0);
    for(const ptl of particles){
      ctx.globalAlpha = Math.max(0,ptl.life);
      ctx.fillStyle = ptl.color;
      ctx.beginPath(); ctx.arc(ptl.x, ptl.y, 3*DPR, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // 終了
    const lastTime = chart.length ? chart[chart.length-1].time : 0;
    if(t > lastTime + 3){
      endSong();
      return;
    }

    requestAnimationFrame(loop);
  }

  function drawLanes(alpha=0.05){
    const W = canvas.width, H = canvas.height;
    const centers = laneCenters();
    const laneW = (centers[1]-centers[0]) || (W*0.6/LANE_COUNT);
    const w = laneW*0.9;

    centers.forEach((cx)=>{
      const grad = ctx.createLinearGradient(cx-w/2,0,cx+w/2,0);
      grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
      grad.addColorStop(0.5, `rgba(255,255,255,${alpha*1.8})`);
      grad.addColorStop(1, `rgba(255,255,255,${alpha})`);
      ctx.fillStyle = grad;
      ctx.fillRect(cx-w/2, 0, w, H);
    });
  }

  function drawMistLayers(p){
    if(p <= 0.15) return;
    const W = canvas.width, H = canvas.height;
    const layers = 3;
    for(let i=0;i<layers;i++){
      const yy = H*(0.25 + 0.18*i + 0.05*Math.sin(mistTime*0.9 + i));
      const alpha = (0.03 + i*0.02) * clamp((p-0.1)/0.9);
      ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
      ctx.lineWidth = 2*DPR;
      ctx.beginPath();
      for(let x=0;x<=W;x+=24*DPR){
        const y = yy + 18*DPR*Math.sin((x/(90*DPR)) + mistTime*(0.6+0.2*i));
        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
  }

  function drawPetals(q){ // q: 0..1
    const W = canvas.width, H = canvas.height;
    const count = Math.round(6 + q*18);
    const hueBase = lerp(220, 50, worldProgress());
    for(let i=0;i<count;i++){
      const t = i/count + (mistTime*0.05);
      const x = W*(0.1 + 0.8*((i%count)/count));
      const y = H*(0.15 + 0.65*((i*37%count)/count)); // 黄金比っぽくばらけさせる
      const r = 10*DPR + 18*DPR*q*Math.abs(Math.sin(t*Math.PI*2));
      const hue = hueBase + (i*7)%40;
      const col = hsl(hue, 0.6, 0.7, 0.15+0.25*q);
      petal(x,y,r,col);
    }
  }
  function petal(x,y,r,fill){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate((Math.sin(mistTime*0.7 + x*0.001 + y*0.001)*0.4));
    ctx.fillStyle = fill;
    ctx.beginPath();
    for(let a=0;a<Math.PI*2;a+=Math.PI/5){
      const px = Math.cos(a)*r;
      const py = Math.sin(a)*r*0.55;
      if(a===0) ctx.moveTo(px,py); else ctx.quadraticCurveTo(0,0,px,py);
    }
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  function drawNote(x,y,r,color){
    ctx.save();
    ctx.shadowColor = addAlpha(color, 0.6);
    ctx.shadowBlur = r*0.8;
    ctx.fillStyle = addAlpha(color, 0.9);
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = addAlpha('#ffffff', 0.8);
    ctx.beginPath(); ctx.arc(x, y, r*0.45, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function endSong(){
    running = false;
    // 最終的に世界100%
    wrap.style.setProperty('--gray','0');
    applyWorldVisuals();

    const acc = judgedCount ? (hits/judgedCount) : 1;
    document.getElementById('ovTitle').textContent = '結果';
    document.getElementById('ovMsg').innerHTML = `
      SCORE: <b>${score|0}</b><br/>
      COMBO（現行値）: <b>${(combo|0)}</b><br/>
      ACCURACY: <b>${(acc*100).toFixed(1)}%</b><br/>
      World Restored: <b>${Math.round(worldProgress()*100)}%</b><br/>
      Colors Restored: <b>${unlockedIndex+1}/${COLOR_ORDER.length}</b>
    `;
    ov.style.display = 'flex';
  }

  // ====== Utils ======
  function addAlpha(hex, a){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if(!m) return hex;
    const r = parseInt(m[1],16), g=parseInt(m[2],16), b=parseInt(m[3],16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // 初回：イントロ表示
  (function showIntro(){
    document.getElementById('ovTitle').textContent = 'Monochrome Rebirth';
    document.getElementById('ovMsg').innerHTML = `
      失われた色と音。<br/>
      レーン上をタップして、色の精霊と世界の色を取り戻そう。<br/>
      背景はスコア／進行度に応じて<strong>じわじわ美しく</strong>変化します。<br/>
      解放順：<b>黄 → 緑 → 青 → 赤</b>
    `;
    ov.style.display = 'flex';
    applyWorldVisuals();
  })();

})();
</script>
</body>
</html>



