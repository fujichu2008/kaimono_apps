<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Monochrome Rebirth – Rhythm of Colors</title>
<style>
  :root{
    --gray: 1; /* 1=モノクロ, 0=フルカラー（JSが更新） */
    --bg-top:#0b0f15; /* 進行で更新 */
    --bg-bot:#0e1220; /* 進行で更新 */
    --yellow:#ffd166; --green:#5af38f; --blue:#6ab8ff; --red:#ff6b6b;
    --hit-top: 75%;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(var(--bg-top),var(--bg-bot));color:#e9eefc;font-family:system-ui,-apple-system,"Hiragino Sans","Noto Sans JP",sans-serif}
  .wrap{height:100%;display:flex;align-items:center;justify-content:center;filter:grayscale(var(--gray));transition:filter .8s ease}
  .game{width:min(980px,100%);max-width:980px;padding:12px}
  .topbar{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px}
  .stat{display:flex;gap:12px;font-size:14px;color:#bcd1ff;flex-wrap:wrap}
  .badge{padding:4px 10px;border:1px solid #283248;border-radius:999px;background:rgba(255,255,255,.04)}
  .title{font-weight:700;letter-spacing:.4px;color:#e9eefc}
  .stage{font-size:12px;opacity:.9}

  .board{
    position:relative;border:1px solid #243049;border-radius:12px;overflow:hidden;background:
      radial-gradient(1000px 400px at 50% 20%, rgba(255,255,255,.04), transparent 60%),
      linear-gradient(180deg, var(--bg-top), var(--bg-bot));
    height:70vh;min-height:460px;touch-action:none;
  }
  canvas{position:absolute;inset:0;display:block;width:100%;height:100%}

  .centerHud{position:absolute;left:0;right:0;top:8px;display:flex;justify-content:center;gap:8px;pointer-events:none;flex-wrap:wrap}
  .chip{font-size:12px;border:1px solid #3a455d;background:rgba(255,255,255,.05);padding:6px 10px;border-radius:999px}
  .chip strong{color:#fff}

  .hitLine{position:absolute; left:0; right:0; top: var(--hit-top, 75%);
    border-top:2px dashed rgba(255,255,255,.28);}

  .controls{position:absolute;left:0;right:0;bottom:10px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  .btn{
    -webkit-tap-highlight-color:transparent;
    border:1px solid #33415f;background:linear-gradient(180deg,#1a2234,#151b29);
    color:#e9eefc;border-radius:12px;padding:10px 14px;font-weight:600;letter-spacing:.3px;cursor:pointer;
    box-shadow:0 8px 24px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.06);
  }
  .btn:active{transform:translateY(1px)}
  .btn.primary{border-color:#5063ff;background:linear-gradient(180deg,#2b36aa,#20297e)}
  .btn.wide{min-width:160px}

  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter:blur(2px)}
  .card{width:min(620px,92%);background:linear-gradient(180deg,#131a28,#0f1422);border:1px solid #2a3552;border-radius:16px;padding:18px;box-shadow:0 16px 40px rgba(0,0,0,.45)}
  .card h1{margin:0 0 8px;font-size:24px}
  .card p{margin:6px 0;color:#cfe0ff;font-size:14px}
  .bar{height:10px;background:#111827;border:1px solid #26324b;border-radius:999px;overflow:hidden}
  .bar > span{display:block;height:100%;width:0;background:linear-gradient(90deg,#ffd166,#5af38f,#6ab8ff,#ff6b6b)}
  .colors{display:flex;gap:8px;margin-top:10px}
  .dot{width:18px;height:18px;border-radius:50%;border:1px solid #2a3552;opacity:.35}
  .dot.yellow{background:var(--yellow)} .dot.green{background:var(--green)}
  .dot.blue{background:var(--blue)}   .dot.red{background:var(--red)}
  .dot.on{opacity:1;box-shadow:0 0 14px currentColor}

  .floatText{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-weight:800;letter-spacing:1px;pointer-events:none;text-shadow:0 2px 10px rgba(0,0,0,.45)}
  .ft-perfect{color:#fff}.ft-good{color:#cfe0ff}.ft-miss{color:#fda4af}

  @media (max-width:560px){.btn.wide{min-width:140px}}
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="game">
    <div class="topbar">
      <div class="title">Monochrome Rebirth – <span class="stage">Rhythm of Colors</span></div>
      <div class="stat">
        <div class="badge">LEVEL: <span id="lv">1</span></div>
        <div class="badge">SCORE: <span id="sc">0</span></div>
        <div class="badge">COMBO: <span id="co">0</span></div>
        <div class="badge">ACC: <span id="ac">100%</span></div>
        <div class="badge">WORLD: <span id="wp">0%</span></div>
      </div>
    </div>

    <div class="board" id="board">
      <canvas id="cv"></canvas>
      <div class="centerHud">
        <div class="chip">BPM: <strong id="bpmTxt">80</strong></div>
        <div class="chip">LANES: <strong id="lanesTxt">4</strong></div>
        <div class="chip">WINDOW: <strong>±50ms / ±150ms</strong></div>
        <div class="chip">演出: <strong>花火・風・青波・オーロラ</strong></div>
      </div>
      <div class="hitLine"></div>

      <div class="controls">
        <button class="btn" id="tapBtn" title="中央レーンを叩く（Spaceでも可）">Tap / Space</button>
        <button class="btn primary wide" id="startBtn">Start</button>
      </div>

      <div class="overlay" id="ov">
        <div class="card">
          <h1 id="ovTitle">Monochrome Rebirth</h1>
          <p id="ovMsg">白と黒の世界。リズムで色と音を取り戻そう。</p>
          <div class="colors">
            <div class="dot yellow" id="dotY"></div>
            <div class="dot green"  id="dotG"></div>
            <div class="dot blue"   id="dotB"></div>
            <div class="dot red"    id="dotR"></div>
          </div>
          <p style="margin-top:10px">色の回復度</p>
          <div class="bar"><span id="bar"></span></div>
          <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:14px;flex-wrap:wrap">
            <button class="btn" id="retryBtn">Retry</button>
            <button class="btn primary" id="nextBtn">Next Level</button>
            <button class="btn" id="closeBtn">Close</button>
          </div>
        </div>
      </div>

    </div>
    <p style="margin:8px 2px 0;font-size:12px;color:#9fb3df">操作：キャンバス上の各レーンをタップ（スマホOK）／スペースキーは中央付近。音が出ない場合は「Start」を押してください。</p>
  </div>
</div>

<script>
(() => {
  // ====== Level & Difficulty ======
  let LEVEL = 1;               // 1..∞
  const MAX_LANES = 5;         // Lv3以降で5レーンに拡張
  const BASE_BPM = 80;         // ゆったりベース
  const BPM_STEP = 4;          // レベルごとの微増

  // ====== Parameters (some derive from level) ======
  let BPM = BASE_BPM;
  let SEC_PER_BEAT = 60 / BPM;
  let LEADIN = 1.0;
  let NOTE_TRAVEL = 2.0;       // 到達時間（Lvで短縮）
  const PERFECT = 0.050;
  const GOOD = 0.150;

  // カラー解放順
  const COLOR_ORDER = ['yellow','green','blue','red'];
  const HITS_PER_COLOR = 12;

  // Lanes / melody
  let LANE_COUNT = 4;
  const SCALE4 = [261.63, 293.66, 329.63, 392.00];        // C4 D4 E4 G4
  const SCALE5 = [246.94, 277.18, 329.63, 369.99, 440.0]; // B3 C#4 E4 F#4 A4（開放感）
  const HIT_LINE_RATIO = 0.75;
  const SPAWN_RATIO    = 0.10;
  const BOTTOM_RATIO   = 0.92;

  // ====== DOM ======
  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d');
  const boardEl = document.getElementById('board');
  const scEl = document.getElementById('sc');
  const coEl = document.getElementById('co');
  const acEl = document.getElementById('ac');
  const wpEl = document.getElementById('wp');
  const lvEl = document.getElementById('lv');
  const startBtn = document.getElementById('startBtn');
  const tapBtn = document.getElementById('tapBtn');
  const ov = document.getElementById('ov');
  const retryBtn = document.getElementById('retryBtn');
  const closeBtn = document.getElementById('closeBtn');
  const nextBtn = document.getElementById('nextBtn');
  const barEl = document.getElementById('bar');
  const dotY = document.getElementById('dotY');
  const dotG = document.getElementById('dotG');
  const dotB = document.getElementById('dotB');
  const dotR = document.getElementById('dotR');
  const bpmTxt = document.getElementById('bpmTxt');
  const lanesTxt = document.getElementById('lanesTxt');

  // ====== Resize ======
  let DPR = window.devicePixelRatio || 1;
  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    DPR = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(rect.width  * DPR);
    canvas.height = Math.floor(rect.height * DPR);
    document.documentElement.style.setProperty('--hit-top', (HIT_LINE_RATIO*100).toFixed(1)+'%');
  }
  addEventListener('resize', fitCanvas, {passive:true});
  fitCanvas();

  // ====== State ======
  let audioCtx = null, masterGain = null;
  let layers = {};
  let melodyBus = null;        // メロディ用バス
  let delayNode = null;        // レベルに応じたショートディレイ
  let panNodes = [];           // レーンごとのステレオパン
  let particles = [];
  let windStreaks = [];        // 風演出
  let running = false;

  let chart = [];              // {beat,time,notes:[{lane}],judged/hit/missed}
  let songStartTime = 0;
  let score = 0, combo = 0, hits = 0, judgedCount = 0;
  let unlockedIndex = -1;
  let goodHitsForColor = 0;

  let targetScore = 8000;      // 進行度用の目標スコア

  // ====== Helpers ======
  const clamp = (v,min=0,max=1)=>Math.max(min,Math.min(max,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  function hsl(h,s,l,a=1){ return `hsla(${h},${(s*100).toFixed(1)}%,${(l*100).toFixed(1)}%,${a})`; }
  function colorOf(c){ return {'yellow':'#ffd166','green':'#5af38f','blue':'#6ab8ff','red':'#ff6b6b'}[c]||'#ffffff'; }
  function labelOf(c){ return {yellow:'黄',green:'緑',blue:'青',red:'赤'}[c]||c; }

  // ====== Level -> Parameters ======
  function applyLevelParams(){
    BPM = BASE_BPM + (LEVEL-1)*BPM_STEP;          // 微増
    SEC_PER_BEAT = 60 / BPM;
    NOTE_TRAVEL = Math.max(1.5, 2.0 - (LEVEL-1)*0.15); // じわっと速く
    LANE_COUNT = (LEVEL>=3) ? 5 : 4;               // Lv3から5レーン
    bpmTxt.textContent = Math.round(BPM);
    lanesTxt.textContent = LANE_COUNT;
    lvEl.textContent = LEVEL;
  }

  // ====== Lanes geometry ======
  function laneCenters(){
    const W = canvas.width;
    const padding = 60 * DPR;
    const innerW = W - padding*2;
    const gap = innerW / LANE_COUNT;
    return Array.from({length: LANE_COUNT}, (_,i)=> padding + gap*(i+0.5));
  }
  function laneFromCanvasX(cx){
    const centers = laneCenters();
    let best=0,min=1e9;
    for(let i=0;i<centers.length;i++){
      const d = Math.abs(cx - centers[i]);
      if(d < min){ min = d; best = i; }
    }
    return best;
  }

  // ====== Chart (density scales with level, allow chords) ======
  function buildChart(){
    chart = [];
    const blocks = 8;
    const chordProb = clamp(0.10 + (LEVEL-1)*0.06, 0.1, 0.5); // Lvで和音確率UP
    const extraNotes = (LEVEL-1)*2;                           // ブロック当たり追加ノーツ
    const lanesScale = (LANE_COUNT===4)? SCALE4 : SCALE5;

    let beat=0;
    for(let b=0;b<blocks;b++){
      const base=beat;
      // 基本パターン
      const patt = (b%2===0)
        ? [0,0,2, 2,1, 3, 4, 5.5, 6, 7.5]
        : [0,1, 1.75, 2.5, 3.25, 4.0,5.0, 6.0, 7.0];
      // 生成
      patt.forEach((off,idx)=>{
        const lanes = [randLane()];
        // 和音にする？
        if(Math.random() < chordProb){
          let l2 = randLane();
          if(l2===lanes[0]) l2 = (l2+1)%LANE_COUNT;
          lanes.push(l2);
        }
        push(base+off, lanes);
      });
      // レベルに応じた追加ノーツ
      for(let i=0;i<extraNotes;i++){
        push(base + randRange(0,8,true), [randLane()]);
      }
      beat+=8;
    }
    chart.forEach(n=> n.time = LEADIN + n.beat * SEC_PER_BEAT);

    function push(beat, lanes){ chart.push({beat,time:0,notes:lanes.map(l=>({lane:l})), judged:false, hitCount:0, missed:false}); }
    function randLane(){ return (Math.random()*LANE_COUNT)|0; }
    function randRange(a,b,half){ return half? (a + Math.round(Math.random()*(b-a)*2)/2) : (a + Math.random()*(b-a)); }

    // 目標スコア（Perfect 75%想定）
    const approxNotes = chart.reduce((s,n)=> s + n.notes.length, 0);
    targetScore = Math.max(8000, Math.floor(approxNotes * 900 * 0.75));
  }

  // ====== Audio ======
  function initAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9; masterGain.connect(audioCtx.destination);

    // Ambient Pad（世界の息吹）
    const amb = makePad({freqs:[110, 220, 330], gain:0.06}); amb.connect(masterGain);

    // 色レイヤー
    layers.yellow = makeLayerGain();
    layers.green  = makeLayerGain();
    layers.blue   = makeLayerGain();
    layers.red    = makeLayerGain();

    // メロディバス + ディレイ（レベルでフィードバック増）
    melodyBus = audioCtx.createGain(); melodyBus.gain.value = 0.8;
    delayNode = audioCtx.createDelay(); delayNode.delayTime.value = 0.18; // short echo
    const fb = audioCtx.createGain(); fb.gain.value = clamp(0.15 + (LEVEL-1)*0.05, 0.15, 0.45);
    melodyBus.connect(delayNode).connect(fb).connect(delayNode);
    const mix = audioCtx.createGain(); mix.gain.value = 0.35 + (LEVEL-1)*0.05;
    delayNode.connect(mix).connect(masterGain);
    melodyBus.connect(masterGain); // 原音

    // レーンPAN
    panNodes = Array.from({length: MAX_LANES}, (_,i)=>{
      const p = new (audioCtx.createStereoPanner||StereoPannerNode)(audioCtx, {pan: lerp(-0.8,0.8, i/(Math.max(1,MAX_LANES-1)))});
      p.connect(melodyBus); return p;
    });
  }
  function makeLayerGain(){ const g = audioCtx.createGain(); g.gain.value=0; g.connect(masterGain); return g; }
  function makePad({freqs, gain}){
    const g = audioCtx.createGain(); g.gain.value = gain;
    freqs.forEach(f=>{
      const o = audioCtx.createOscillator(); const env = audioCtx.createGain();
      env.gain.value = 0.0008; o.type='sine'; o.frequency.value=f;
      o.connect(env).connect(g); o.start();
      const lfo = audioCtx.createOscillator(); const lfoGain = audioCtx.createGain();
      lfo.frequency.value = 0.07; lfoGain.gain.value = f*0.015; lfo.connect(lfoGain).connect(o.frequency); lfo.start();
    });
    return g;
  }

  // メロディ音（レーン毎にパン・軽いフィルタ・レベルでコーラス風LFO）
  function playLaneTone(time, lane){
    if(!audioCtx) return;
    const scale = (LANE_COUNT===4) ? SCALE4 : SCALE5;
    const freq = scale[Math.max(0, Math.min(scale.length-1, lane))];
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 1800 + LEVEL*300;
    const lfo = audioCtx.createOscillator(); const lfoGain = audioCtx.createGain();
    lfo.frequency.value = 2 + LEVEL*0.5; lfoGain.gain.value = 3 + LEVEL*2; lfo.connect(lfoGain).connect(o.frequency); lfo.start(time);

    o.type='sine'; o.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.22 + LEVEL*0.02, time+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, time+0.45);

    const pan = panNodes[lane] || melodyBus;
    o.connect(f).connect(g).connect(pan);
    o.start(time); o.stop(time+0.6);
  }

  // 色ごとのSFX（ミックスがレベルでリッチに）
  function colorSfx(time){
    const name = COLOR_ORDER[Math.max(0, unlockedIndex)];
    if(!name) return;
    if(name==='yellow'){ softKick(time); bell(time+0.02); }
    if(name==='green'){ arp(time); }
    if(name==='blue'){ bass(time); }
    if(name==='red'){ lead(time); }
  }
  function softKick(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='sine'; o.frequency.setValueAtTime(140,t); o.frequency.exponentialRampToValueAtTime(55,t+0.12);
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.28 + LEVEL*0.02,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.18);
    o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.2);
  }
  function bell(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type='triangle'; o.frequency.value=660 + LEVEL*10;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16 + LEVEL*0.01,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.5);
    o.connect(g).connect(layers.yellow); o.start(t); o.stop(t+0.6);
  }
  function bass(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter();
    o.type='sawtooth'; o.frequency.value=55; f.type='lowpass'; f.frequency.value=200 + LEVEL*40;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.20 + LEVEL*0.02,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.3);
    o.connect(f).connect(g).connect(layers.blue); o.start(t); o.stop(t+0.35);
  }
  function arp(t){ [440,523.25,587.33,659.25].forEach((fr,i)=>{
      const tt=t+i*(0.07 - LEVEL*0.003); const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type='sine'; o.frequency.value=fr + LEVEL*3;
      g.gain.setValueAtTime(0.001,tt); g.gain.exponentialRampToValueAtTime(0.12 + LEVEL*0.01,tt+0.01); g.gain.exponentialRampToValueAtTime(0.001,tt+0.18);
      o.connect(g).connect(layers.green); o.start(tt); o.stop(tt+0.22);
    });
  }
  function lead(t){ const o=audioCtx.createOscillator(), g=audioCtx.createGain(), f=audioCtx.createBiquadFilter();
    o.type='sine'; o.frequency.value=880 + LEVEL*12; f.type='lowpass'; f.frequency.value=1800 + LEVEL*120;
    g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.16 + LEVEL*0.01,t+0.015); g.gain.exponentialRampToValueAtTime(0.0001,t+0.5);
    o.connect(f).connect(g).connect(layers.red); o.start(t); o.stop(t+0.52);
  }

  // ====== Particles / VFX ======
  function addBurst(x,y,color,count=20, speed=2){
    for(let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      const sp = (Math.random()*0.8+0.2)*speed;
      particles.push({ x, y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, life:1.0, color, type:'burst' });
    }
  }
  function addFireworks(x,y,colors){
    // 大花火（レベルアップ・色解放・大コンボで）
    const rings = 3 + Math.min(LEVEL,3);
    for(let r=0;r<rings;r++){
      const c = colors[r % colors.length];
      addBurst(x, y, c, 28 + r*10, 2.5 + r*0.8);
    }
  }
  function addConfetti(colorCount=20){
    const W=canvas.width, H=canvas.height;
    const cols = unlockedColors();
    for(let i=0;i<colorCount;i++){
      const c = cols[i%cols.length] || '#ffffff';
      particles.push({
        x: Math.random()*W, y: -20, vx:(Math.random()*2-1)*1.5, vy: Math.random()*2+1,
        life: 1.2, color:c, type:'confetti', rot: Math.random()*Math.PI*2
      });
    }
  }
  function unlockedColors(){
    const arr=[];
    for(let i=0;i<=unlockedIndex;i++) arr.push(colorOf(COLOR_ORDER[i]));
    return arr.length?arr:['#ffffff'];
  }
  function spawnWind(){
    // 風のストリーク（レベルに応じて本数/速度）
    const W=canvas.width, H=canvas.height;
    const n = 2 + LEVEL;
    for(let i=0;i<n;i++){
      windStreaks.push({
        x: -50, y: Math.random()*H*0.8,
        vx: 3 + LEVEL*0.8, vy: (Math.random()*2-1)*0.2,
        alpha: 0.03 + 0.02*LEVEL, life: 1.0
      });
    }
  }

  // ====== World Visual Progress ======
  function colorProgress(){
    const total = COLOR_ORDER.length * HITS_PER_COLOR;
    const cur = clamp(((unlockedIndex+1)*HITS_PER_COLOR + goodHitsForColor)/total);
    return cur;
  }
  function scoreProgress(){ return clamp(score / targetScore); }
  function worldProgress(){ return clamp(0.4*colorProgress() + 0.6*scoreProgress()); }
  function applyWorldVisuals(){
    const p = worldProgress();
    wrap.style.setProperty('--gray', (1-p).toFixed(3));
    // 背景グラデ：群青→暁→金
    const topHue = lerp(220, 200, p), topSat = lerp(0.20, 0.70, p), topLum = lerp(0.05, 0.25, p);
    const botHue = lerp(220, 45,  p), botSat = lerp(0.18, 0.85, p), botLum = lerp(0.08, 0.42, p);
    document.documentElement.style.setProperty('--bg-top', hsl(topHue, topSat, topLum, 1));
    document.documentElement.style.setProperty('--bg-bot', hsl(botHue, botSat, botLum, 1));
    wpEl.textContent = Math.round(p*100)+'%';
  }

  // ====== Game Control ======
  function startGame(){
    applyLevelParams();
    initAudio();
    buildChart();
    running = true;
    score = 0; combo = 0; hits = 0; judgedCount = 0;
    unlockedIndex = -1; goodHitsForColor = 0;
    updateStats();
    barEl.style.width = '0%';
    ov.style.display = 'none';

    const now = audioCtx.currentTime;
    Object.values(layers).forEach(g => { g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(0, now); });
    melodyBus.gain.setValueAtTime(0.8, now);

    particles.length = 0; windStreaks.length = 0;
    songStartTime = now + 0.05;
    applyWorldVisuals();
    requestAnimationFrame(loop);
  }

  function unlockNextColor(){
    if(unlockedIndex >= COLOR_ORDER.length-1) return;
    unlockedIndex++;
    const name = COLOR_ORDER[unlockedIndex];
    goodHitsForColor = 0;

    // レイヤーfade-in
    const now = audioCtx.currentTime;
    const g = layers[name];
    if(g){ g.gain.cancelScheduledValues(now); g.gain.setValueAtTime(g.gain.value, now); g.gain.linearRampToValueAtTime(0.7 + 0.05*LEVEL, now+1.0); }

    // 祝砲（色混合花火＋紙吹雪）
    const cx = canvas.width/2, cy = canvas.height*0.35;
    const cols = unlockedColors();
    addFireworks(cx, cy, cols);
    addConfetti(25 + LEVEL*8);

    floatText(`+ ${labelOf(name)} 解放！`, 'ft-perfect');
    updateDots();
    applyWorldVisuals();
  }

  function updateDots(){
    [dotY,dotG,dotB,dotR].forEach(el=>el.classList.remove('on'));
    if(unlockedIndex>=0) dotY.classList.add('on');
    if(unlockedIndex>=1) dotG.classList.add('on');
    if(unlockedIndex>=2) dotB.classList.add('on');
    if(unlockedIndex>=3) dotR.classList.add('on');
  }

  // ====== Input ======
  function onTapAtCanvas(clientX){
    if(!running || !audioCtx) return;
    const rect = canvas.getBoundingClientRect();
    const cx = (clientX - rect.left) * DPR;
    const lane = laneFromCanvasX(cx);
    judgeTap(lane);
  }
  function onTapButton(){
    const lane = Math.floor(LANE_COUNT/2);
    judgeTap(lane);
  }
  function judgeTap(lane){
    const t = audioCtx.currentTime - songStartTime;
    // もっとも近い未判定のノート（かつそのノート内にlaneを含む）を探す
    let best=null, bestAdt=1e9, bestIdx=-1;
    for(let i=0;i<chart.length;i++){
      const n = chart[i];
      if(n.judged && n.hitCount>=n.notes.length) continue;
      if(!n.notes.some(nt=>nt.lane===lane)) continue;
      const dt = n.time - t;
      const adt = Math.abs(dt);
      if(adt < bestAdt){ bestAdt = adt; best = n; bestIdx=i; }
      if(dt < -GOOD && !n.missed){ n.missed = true; judgedCount++; combo = 0; }
    }
    if(!best) return;
    const adiff = Math.abs(best.time - t);
    if(adiff <= PERFECT) applyHit(bestIdx, lane, 'perfect');
    else if(adiff <= GOOD) applyHit(bestIdx, lane, 'good');
    else { floatText('MISS', 'ft-miss'); combo=0; updateStats(); }
  }

  boardEl.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    onTapAtCanvas(e.clientX);
  }, {passive:false});
  addEventListener('keydown', (e)=>{ if(e.code === 'Space'){ e.preventDefault(); onTapButton(); }}, {passive:false});
  tapBtn.addEventListener('click', onTapButton);

  startBtn.addEventListener('click', ()=>{
    if(!audioCtx || audioCtx.state !== 'running'){ initAudio(); audioCtx.resume(); }
    startGame();
  });
  retryBtn.addEventListener('click', startGame);
  nextBtn.addEventListener('click', ()=>{
    LEVEL++; startGame();
  });
  closeBtn.addEventListener('click', ()=> ov.style.display='none');

  // ====== Judgement ======
  function applyHit(noteIndex, lane, grade){
    const n = chart[noteIndex];
    // そのノート内の対象レーンが未HITならカウント
    const part = n.notes.find(nt=>nt.lane===lane);
    if(!part || part.hit) return;
    part.hit = true;
    n.hitCount++;
    if(n.hitCount >= n.notes.length){ n.judged = true; judgedCount++; }

    const now = audioCtx.currentTime;
    const add = (grade==='perfect'? 1000 : 650) * (1 + Math.floor(combo/25)*0.1);
    score += add; combo++; hits++;

    // 色ゲージ
    goodHitsForColor++;
    if(goodHitsForColor >= HITS_PER_COLOR){ unlockNextColor(); }
    const progress = clamp(((unlockedIndex+1)*HITS_PER_COLOR + goodHitsForColor) / (COLOR_ORDER.length*HITS_PER_COLOR));
    barEl.style.width = (progress*100).toFixed(1)+'%';

    // 音と演出
    playLaneTone(now, lane);
    colorSfx(now);

    // パーティクル（判定ライン位置・色ミックス）
    const centers = laneCenters();
    const x = centers[lane], y = canvas.height * HIT_LINE_RATIO;
    const cols = unlockedColors();
    const c = cols[(lane + n.notes.length)%cols.length] || '#ffffff';
    const density = Math.round(18 + worldProgress()*24) + (n.notes.length>1?8:0);
    addBurst(x, y, c, grade==='perfect'? density+10 : density, 2.2);

    floatText(grade.toUpperCase(), grade==='perfect'?'ft-perfect':'ft-good');

    // 大コンボで花火
    if(combo===20 || combo===40 || combo===60){
      addFireworks(canvas.width*0.5, canvas.height*0.3, cols);
      spawnWind();
      addConfetti(15 + LEVEL*6);
    }

    updateStats();
    applyWorldVisuals();
  }

  function updateStats(){
    scEl.textContent = score|0;
    coEl.textContent = combo|0;
    const acc = judgedCount ? (hits/judgedCount) : 1;
    acEl.textContent = (acc*100).toFixed(0)+'%';
    wpEl.textContent = Math.round(worldProgress()*100)+'%';
  }

  // ====== Floats ======
  function floatText(txt, cls){
    const d = document.createElement('div');
    d.className = `floatText ${cls}`;
    d.textContent = txt;
    d.style.opacity = '0';
    document.getElementById('board').appendChild(d);
    d.animate(
      [{transform:'translate(-50%,-10%) scale(0.9)',opacity:0},
       {transform:'translate(-50%,-50%) scale(1.0)',opacity:1,offset:.35},
       {transform:'translate(-50%,-70%) scale(1.1)',opacity:0}],
      {duration:900,easing:'ease-out'}
    ).onfinish = ()=> d.remove();
  }

  // ====== Render & VFX ======
  let mistTime = 0, waveTime = 0, auroraTime = 0;
  function loop(){
    if(!running) return;

    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    const p = worldProgress();
    const cols = unlockedColors();

    // 背景ラディアルグロー（解放色ミックス）
    const baseHue = lerp(220, 60, p);
    const baseCol = hsl(baseHue, lerp(0.25,0.85,p), lerp(0.25,0.55,p), lerp(0.10,0.35,p));
    const g0 = ctx.createRadialGradient(W/2, H*0.25, 10, W/2, H*0.25, Math.max(W,H)*0.9);
    g0.addColorStop(0, baseCol); g0.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g0; ctx.fillRect(0,0,W,H);

    // レーン背景（薄）
    drawLanes(lerp(0.03, 0.08, p));

    // 風（Wind）— レベルに応じて強化
    if(Math.random() < 0.01 + LEVEL*0.004) spawnWind();
    ctx.lineCap='round';
    windStreaks.forEach(w=>{
      ctx.globalAlpha = w.alpha;
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 3*DPR;
      ctx.beginPath(); ctx.moveTo(w.x, w.y); ctx.lineTo(w.x+60, w.y+8); ctx.stroke();
      w.x += w.vx; w.y += w.vy; w.life -= 0.01;
    });
    windStreaks = windStreaks.filter(w=>w.x < W+80 && w.life>0);
    ctx.globalAlpha=1;

    // 青い波（Blue Waves）— 青解放以降
    if(unlockedIndex>=2){
      waveTime += 0.016 + p*0.008;
      const amp = 8*DPR + 16*DPR*p;
      const layers = 3 + LEVEL;
      for(let li=0; li<layers; li++){
        const yy = H*(0.62 + 0.03*li);
        ctx.globalAlpha = 0.05 + 0.05*p;
        ctx.fillStyle = colorOf('blue');
        ctx.beginPath();
        ctx.moveTo(0,H);
        for(let x=0;x<=W;x+=12*DPR){
          const y = yy + Math.sin((x/(80*DPR))+waveTime*(0.6+li*0.1)) * amp*(0.5+li*0.2);
          ctx.lineTo(x,y);
        }
        ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // オーロラ（Aurora）— 全色解放近いと強化
    if(p>0.55){
      auroraTime += 0.005 + 0.01*p;
      const bands = 2 + Math.floor(p*3);
      for(let b=0;b<bands;b++){
        const yy = H*(0.18 + 0.18*b);
        const grad = ctx.createLinearGradient(0,yy,W,yy);
        const mixCols = cols.length? cols : ['#a8b6ff'];
        grad.addColorStop(0, addAlpha(mixCols[b%mixCols.length], 0.08));
        grad.addColorStop(0.5, addAlpha(mixCols[(b+1)%mixCols.length], 0.18));
        grad.addColorStop(1, addAlpha(mixCols[(b+2)%mixCols.length], 0.08));
        ctx.fillStyle = grad;
        ctx.globalAlpha = 0.5*p;
        ctx.fillRect(0, yy + Math.sin(auroraTime*1.1 + b)*8*DPR, W, 12*DPR);
        ctx.globalAlpha = 1;
      }
    }

    // 判定ライン
    const lineY = H * HIT_LINE_RATIO;
    ctx.globalAlpha = 0.28; ctx.fillStyle = '#ffffff';
    ctx.fillRect(W*0.1, lineY-2*DPR, W*0.8, 4*DPR); ctx.globalAlpha = 1;

    // 時刻
    const t = audioCtx ? (audioCtx.currentTime - songStartTime) : 0;
    const spawnY  = H * SPAWN_RATIO;
    const bottomY = H * BOTTOM_RATIO;

    // ノーツ描画（上→判定→最下部へ）
    for(const n of chart){
      if(!n.judged && (t - n.time) > GOOD){
        n.missed = true; n.judged = true; judgedCount++; combo = 0; updateStats();
      }
      const progress = 1 - ((n.time - t) / NOTE_TRAVEL);
      if(progress < -0.2 || progress > 1.3) continue;

      let y;
      if(progress <= 1){
        y = spawnY + (lineY - spawnY) * Math.max(0, Math.min(1, progress));
      }else{
        const p2 = Math.min(1, (progress-1)/(0.3));
        y = lineY + (bottomY - lineY) * p2;
      }

      const centers = laneCenters();
      for(const part of n.notes){
        const x = centers[part.lane];
        const r = 16*DPR * (1 + 0.12*Math.cos(n.beat*0.7)) * (n.notes.length>1?1.1:1);
        const cMix = cols[(part.lane + n.notes.length)%cols.length] || '#d0d7ea';
        drawNote(x, y, r, cMix);
      }
    }

    // 花火/紙吹雪/通常粒子
    for(const ptl of particles){
      if(ptl.type==='confetti'){
        ptl.rot += 0.08; ptl.vy += 0.02;
        ptl.x += ptl.vx; ptl.y += ptl.vy; ptl.life -= 0.01;
        ctx.save(); ctx.translate(ptl.x, ptl.y); ctx.rotate(ptl.rot);
        ctx.globalAlpha = Math.max(0,ptl.life);
        ctx.fillStyle = ptl.color; ctx.fillRect(-4*DPR, -2*DPR, 8*DPR, 4*DPR);
        ctx.restore();
      }else{
        ptl.x+=ptl.vx; ptl.y+=ptl.vy; ptl.vy+=0.05; ptl.life-=0.02;
        ctx.globalAlpha = Math.max(0,ptl.life);
        ctx.fillStyle = ptl.color;
        ctx.beginPath(); ctx.arc(ptl.x, ptl.y, 3*DPR, 0, Math.PI*2); ctx.fill();
      }
    }
    particles = particles.filter(ptl=>ptl.life>0);
    ctx.globalAlpha = 1;

    // 終了
    const lastTime = chart.length ? chart[chart.length-1].time : 0;
    if(t > lastTime + 3){
      endSong();
      return;
    }

    requestAnimationFrame(loop);
  }

  function drawLanes(alpha=0.05){
    const W = canvas.width, H = canvas.height;
    const centers = laneCenters();
    const laneW = (centers[1]-centers[0]) || (W*0.6/LANE_COUNT);
    const w = laneW*0.9;
    centers.forEach((cx)=>{
      const grad = ctx.createLinearGradient(cx-w/2,0,cx+w/2,0);
      grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
      grad.addColorStop(0.5, `rgba(255,255,255,${alpha*1.8})`);
      grad.addColorStop(1, `rgba(255,255,255,${alpha})`);
      ctx.fillStyle = grad; ctx.fillRect(cx-w/2, 0, w, H);
    });
  }
  function drawNote(x,y,r,color){
    ctx.save();
    ctx.shadowColor = addAlpha(color, 0.6);
    ctx.shadowBlur = r*0.8;
    ctx.fillStyle = addAlpha(color, 0.9);
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = addAlpha('#ffffff', 0.85);
    ctx.beginPath(); ctx.arc(x, y, r*0.45, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function endSong(){
    running = false;
    wrap.style.setProperty('--gray','0');
    applyWorldVisuals();

    const acc = judgedCount ? (hits/judgedCount) : 1;
    const cols = unlockedColors();
    addFireworks(canvas.width*0.5, canvas.height*0.3, cols);
    addConfetti(35 + LEVEL*10);

    document.getElementById('ovTitle').textContent = `結果（Level ${LEVEL})`;
    document.getElementById('ovMsg').innerHTML = `
      SCORE: <b>${score|0}</b><br/>
      COMBO（現行値）: <b>${(combo|0)}</b><br/>
      ACCURACY: <b>${(acc*100).toFixed(1)}%</b><br/>
      World Restored: <b>${Math.round(worldProgress()*100)}%</b><br/>
      Colors Restored: <b>${unlockedIndex+1}/${COLOR_ORDER.length}</b><br/>
      次のレベルでは、<b>ノーツ密度↑・落下速度↑・演出↑</b>！
    `;
    ov.style.display = 'flex';
  }

  // ====== Utils ======
  function addAlpha(hex, a){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if(!m) return hex;
    const r = parseInt(m[1],16), g=parseInt(m[2],16), b=parseInt(m[3],16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // 初回：イントロ表示
  (function showIntro(){
    document.getElementById('ovTitle').textContent = 'Monochrome Rebirth';
    document.getElementById('ovMsg').innerHTML = `
      失われた色と音。<br/>
      レーン上をタップして、色の精霊と世界の色を取り戻そう。<br/>
      レベルが上がるほど、<b>音は精錬</b>され、<b>花火・風・青い波・オーロラ</b>などの演出が強化。<br/>
      難易度も上がり、ノーツ密度や落下速度、同時押しが増えていきます。
    `;
    ov.style.display = 'flex';
    applyWorldVisuals();
  })();

})();
</script>
</body>
</html>

