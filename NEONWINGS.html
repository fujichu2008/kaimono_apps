<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON WINGS: TOUCH STRIKER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #020204; 
            font-family: 'Orbitron', sans-serif; 
            user-select: none; 
            touch-action: none; /* Disable browser touch actions */
        }
        
        /* UI Layers */
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        .hud-panel { text-shadow: 0 0 10px rgba(0, 255, 255, 0.8); color: #00ffff; }
        .score-val { font-size: 2rem; font-weight: 900; }
        
        /* Bars */
        .bar-wrap { width: 300px; max-width: 40vw; height: 12px; background: rgba(255,255,255,0.1); border: 1px solid #00ffff; margin-top: 5px; transform: skewX(-20deg); overflow: hidden; position: relative; }
        .bar-fill { height: 100%; background: linear-gradient(90deg, #00ffff, #0088ff); width: 100%; transition: width 0.1s; box-shadow: 0 0 15px #00ffff; }
        .bar-fill.warning { background: linear-gradient(90deg, #ff5500, #ff0000); box-shadow: 0 0 15px #ff0000; }
        
        /* Buff Timer */
        #buff-ui { opacity: 0; transition: opacity 0.3s; margin-top: 10px; }
        .buff-label { color: #ffff00; font-size: 0.8rem; letter-spacing: 2px; }
        .buff-bar-fill { background: linear-gradient(90deg, #ffff00, #ffaa00); box-shadow: 0 0 15px #ffff00; }

        /* Notification */
        #item-notify {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%) scale(0);
            text-align: center; pointer-events: none; opacity: 0; z-index: 15; width: 100%;
        }
        #item-notify.active { animation: notifyPop 2s forwards; }
        .notify-title { font-size: 3rem; font-weight: 900; color: #fff; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; letter-spacing: 5px; -webkit-text-stroke: 1px #00ffff; }
        .notify-sub { font-size: 1.2rem; color: #ffff00; letter-spacing: 8px; margin-top: 5px; text-shadow: 0 0 10px #ffaa00; }

        @keyframes notifyPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            10% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            20% { transform: translate(-50%, -50%) scale(1.0); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1.0); opacity: 1; filter: blur(0px); }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; filter: blur(10px); }
        }

        /* Boss HUD */
        #boss-ui { position: absolute; top: 15%; left: 50%; transform: translateX(-50%); width: 60%; display: none; text-align: center; }
        .boss-bar-wrap { width: 100%; height: 20px; background: rgba(0,0,0,0.5); border: 1px solid #ff0055; transform: skewX(-20deg); }
        .boss-bar-fill { height: 100%; background: linear-gradient(90deg, #ff0055, #ff5500); width: 100%; transition: width 0.1s; box-shadow: 0 0 15px #ff0055; }

        /* Screens */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 2, 4, 0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; pointer-events: auto; backdrop-filter: blur(8px); }
        .hidden { display: none !important; }
        
        button.cyber-btn {
            background: rgba(0, 255, 255, 0.1); border: 2px solid #00ffff; color: #00ffff; padding: 15px 40px; font-size: 1.2rem; font-family: 'Orbitron', sans-serif;
            text-transform: uppercase; letter-spacing: 3px; cursor: pointer; transition: 0.3s; margin-top: 20px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3); clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        button.cyber-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 40px #00ffff; }
        
        h1 { font-size: clamp(2rem, 8vw, 4rem); margin: 0; background: linear-gradient(to bottom, #fff, #aaa); -webkit-background-clip: text; color: transparent; text-shadow: 0 0 30px rgba(0,255,255,0.5); text-align: center;}
    </style>
</head>
<body>

    <div id="canvas-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>

    <div id="item-notify">
        <div class="notify-title" id="notify-main">WEAPON UP</div>
        <div class="notify-sub" id="notify-sub">TRIPLE SHOT</div>
    </div>

    <div id="game-ui">
        <div class="flex justify-between items-start">
            <div class="hud-panel">
                <div class="text-xs tracking-widest opacity-70">SCORE</div>
                <div id="score" class="score-val">000000</div>
                <div class="mt-2 text-yellow-400 font-bold tracking-widest">STAGE <span id="stage">1</span></div>
            </div>
            <div class="hud-panel text-right">
                <div class="text-xs tracking-widest opacity-70">ARMOR</div>
                <div class="bar-wrap"><div id="hp-bar" class="bar-fill"></div></div>
                
                <div id="buff-ui">
                    <div class="flex justify-between items-end mb-1">
                        <span class="buff-label" id="buff-name">BOOST</span>
                        <span class="buff-label" id="buff-time">00.0s</span>
                    </div>
                    <div class="bar-wrap" style="height: 6px; width: 200px; max-width:40vw; margin-left: auto;">
                        <div id="buff-bar" class="bar-fill buff-bar-fill" style="width: 100%;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="boss-ui">
            <div class="text-red-500 font-bold tracking-[5px] text-lg animate-pulse">WARNING: BOSS DETECTED</div>
            <div class="boss-bar-wrap"><div id="boss-hp-bar" class="boss-bar-fill"></div></div>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>NEON WINGS</h1>
        <p class="text-gray-400 tracking-[5px] mb-5 text-sm">TOUCH / MOUSE EDITION</p>
        <button class="cyber-btn" onclick="game.start()">ENGAGE</button>
        <div class="text-gray-500 text-xs mt-8 text-center">
            DRAG TO MOVE<br>AUTO FIRE ENGAGED
        </div>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <h1 style="color:#ff0055; text-shadow:0 0 30px #ff0000;">SYSTEM FAIL</h1>
        <p class="text-white text-xl tracking-widest mb-5">SCORE: <span id="final-score">0</span></p>
        <button class="cyber-btn" onclick="game.reset()">REBOOT</button>
    </div>

    <div id="victory-screen" class="overlay hidden">
        <h1 style="color:#ffff00; text-shadow:0 0 30px #ffff00;">COMPLETE</h1>
        <p class="text-white text-xl tracking-widest mb-5">ALL TARGETS CLEARED</p>
        <button class="cyber-btn" onclick="game.reset()">RETURN</button>
    </div>

<script>
/**
 * AUDIO SYSTEM
 */
const AudioSys = {
    ctx: null,
    
    init() { 
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
    },
    
    tone(freq, type, dur, vol=0.1) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
    },
    
    shoot() { this.tone(300 + Math.random()*200, 'sawtooth', 0.1, 0.03); },
    hit() { this.tone(150, 'square', 0.1, 0.1); },
    powerup() { 
        this.tone(600, 'sine', 0.1, 0.2); 
        setTimeout(()=>this.tone(1200, 'sine', 0.3, 0.2), 100);
    },
    explode() {
        if(!this.ctx) return;
        const buf = this.ctx.createBuffer(1, this.ctx.sampleRate*0.5, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1);
        const src=this.ctx.createBufferSource();
        src.buffer=buf;
        const g=this.ctx.createGain();
        g.gain.setValueAtTime(0.4, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+0.4);
        src.connect(g); g.connect(this.ctx.destination);
        src.start();
    }
};

/**
 * GAME ENGINE
 */
const Game = {
    scene: null, camera: null, renderer: null,
    player: null,
    enemies: [], bullets: [], items: [], particles: [],
    frame: 0, isActive: false, score: 0, stage: 1,
    boss: null,
    
    // Input State
    targetPos: { x: 0, y: 0 },
    
    // Config
    SCENE_W: 40, SCENE_H: 26, 
    
    init() {
        // Setup Three.js
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x000000, 0.025);
        
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 8, 18);
        this.camera.rotation.x = -0.3;
        
        this.renderer = new THREE.WebGLRenderer({antialias:true});
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);
        
        // Lights
        this.scene.add(new THREE.AmbientLight(0x404040));
        const dl = new THREE.DirectionalLight(0xffffff, 1);
        dl.position.set(0, 20, 10);
        this.scene.add(dl);
        
        // Environment
        const grid = new THREE.GridHelper(200, 100, 0xff00ff, 0x110033);
        grid.position.set(0, -10, -50);
        this.scene.add(grid);
        this.grid = grid;
        
        // Stars
        const starGeo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0;i<800;i++) pos.push((Math.random()-0.5)*300, (Math.random()-0.5)*200, (Math.random()-0.5)*300 - 50);
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
        this.scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:0.5})));
        
        this.createPlayer();
        
        // Input Listeners
        window.addEventListener('resize', ()=>this.onResize());
        
        // Mouse / Touch
        const updateInput = (cx, cy) => {
            // Normalize to -1 ~ 1
            const nx = (cx / window.innerWidth) * 2 - 1;
            const ny = -(cy / window.innerHeight) * 2 + 1;
            
            // Map to Scene Dimensions (with some clamping)
            this.targetPos.x = Math.max(-this.SCENE_W/2, Math.min(this.SCENE_W/2, nx * (this.SCENE_W/2 + 2)));
            this.targetPos.y = Math.max(-this.SCENE_H/2, Math.min(this.SCENE_H/2, ny * (this.SCENE_H/2 + 4)));
        };

        window.addEventListener('mousemove', e => {
            if(this.isActive) updateInput(e.clientX, e.clientY);
        });
        
        window.addEventListener('touchmove', e => {
            if(this.isActive) {
                // Prevent scrolling
                e.preventDefault(); 
                updateInput(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });
        
        window.addEventListener('touchstart', e => {
            // Initial touch to set position immediately if game active
            if(this.isActive) {
                updateInput(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        this.animate();
    },
    
    createPlayer() {
        const geo = new THREE.ConeGeometry(1, 3, 4);
        geo.rotateX(Math.PI/2);
        geo.rotateY(Math.PI/4);
        const mat = new THREE.MeshStandardMaterial({color:0x00ffff, emissive:0x0044aa, roughness:0.2, metalness:0.8});
        this.player = new THREE.Mesh(geo, mat);
        this.player.data = { hp: 100, power: 1, powerTime: 0, invincible: 0 };
        this.scene.add(this.player);
    },
    
    clearScene() {
        this.enemies.forEach(e => this.scene.remove(e.mesh)); this.enemies = [];
        this.bullets.forEach(b => this.scene.remove(b.mesh)); this.bullets = [];
        this.items.forEach(i => this.scene.remove(i.mesh)); this.items = [];
        this.particles.forEach(p => this.scene.remove(p.mesh)); this.particles = [];
        if (this.boss) { this.scene.remove(this.boss.mesh); this.boss = null; }
    },

    start() {
        AudioSys.init();
        if(AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
        
        this.clearScene();
        this.isActive = true;
        this.score = 0;
        this.stage = 1;
        this.player.position.set(0,0,0);
        this.targetPos = {x: 0, y: 0};
        this.player.rotation.z = 0;
        this.player.data = { hp: 100, power: 1, powerTime: 0, invincible: 0 };
        
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('victory-screen').classList.add('hidden');
        document.getElementById('boss-ui').style.display = 'none';
        document.getElementById('buff-ui').style.opacity = '0';
        this.updateHUD();
    },
    
    spawnEnemy() {
        if(this.boss) return;
        if(this.frame % (this.stage===1?45:25) !== 0) return;
        
        const r = Math.random();
        let type = 'BASIC';
        if(this.stage > 1 && r > 0.7) type = 'CHASER';
        else if (r > 0.85) type = 'SHOOTER';
        else if (r > 0.95) type = 'HEAVY';

        let geo, mat, hp, speed;
        
        switch(type) {
            case 'CHASER':
                geo = new THREE.ConeGeometry(0.8, 2, 3); geo.rotateX(Math.PI/2);
                mat = new THREE.MeshStandardMaterial({color: 0x00ff00, wireframe: true});
                hp = 2; speed = 0.6;
                break;
            case 'SHOOTER':
                geo = new THREE.OctahedronGeometry(1.2);
                mat = new THREE.MeshStandardMaterial({color: 0xffaa00, emissive: 0x552200});
                hp = 3; speed = 0.3;
                break;
            case 'HEAVY':
                geo = new THREE.BoxGeometry(2, 2, 2);
                mat = new THREE.MeshStandardMaterial({color: 0xff00ff, metalness: 0.9});
                hp = 12; speed = 0.2;
                break;
            default: // BASIC
                geo = new THREE.BoxGeometry(1.5, 0.5, 1.5);
                mat = new THREE.MeshStandardMaterial({color: 0xff0055, wireframe: false});
                hp = 1; speed = 0.45;
                break;
        }
        
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set((Math.random()-0.5)*(this.SCENE_W-5), (Math.random()-0.5)*(this.SCENE_H-5), -60);
        
        this.scene.add(mesh);
        this.enemies.push({ mesh, type, hp, speed, timer: 0 });
    },
    
    spawnBoss() {
        const hp = this.stage===1 ? 500 : 1000;
        const group = new THREE.Group();
        
        const core = new THREE.Mesh(
            new THREE.IcosahedronGeometry(3,1),
            new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xaa0000, wireframe:true})
        );
        group.add(core);
        const shell = new THREE.Mesh(
            new THREE.TorusGeometry(6, 1, 8, 50),
            new THREE.MeshStandardMaterial({color:0x444444, metalness:1})
        );
        group.add(shell);
        
        group.position.set(0,0,-60);
        this.scene.add(group);
        
        this.boss = { mesh: group, core, shell, hp, maxHp: hp, phase: 1, timer: 0 };
        document.getElementById('boss-ui').style.display = 'block';
    },

    spawnItem(pos) {
        const isPower = Math.random() > 0.4;
        const geo = new THREE.DodecahedronGeometry(0.8);
        const mat = new THREE.MeshBasicMaterial({color: isPower?0xffff00:0x00ffff, wireframe:true});
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);
        this.scene.add(mesh);
        this.items.push({mesh, type: isPower?'POWER':'HEAL'});
    },

    showNotify(main, sub) {
        const el = document.getElementById('item-notify');
        document.getElementById('notify-main').innerText = main;
        document.getElementById('notify-sub').innerText = sub;
        el.classList.remove('active');
        void el.offsetWidth;
        el.classList.add('active');
    },

    update() {
        if(!this.isActive) return;
        this.frame++;
        
        // --- Player Move (Lerp for smooth follow) ---
        const p = this.player;
        p.position.x += (this.targetPos.x - p.position.x) * 0.15;
        p.position.y += (this.targetPos.y - p.position.y) * 0.15;
        
        // Tilt
        p.rotation.z = (p.position.x - this.targetPos.x) * 0.1;
        
        // Power Timer
        if(p.data.power > 1) {
            p.data.powerTime--;
            const pct = (p.data.powerTime / 600) * 100;
            document.getElementById('buff-bar').style.width = pct + '%';
            document.getElementById('buff-time').innerText = (p.data.powerTime/60).toFixed(1) + 's';
            if(p.data.powerTime <= 0) {
                p.data.power = 1;
                document.getElementById('buff-ui').style.opacity = '0';
                this.showNotify("POWER DOWN", "WEAPON NORMALIZED");
            }
        }
        
        // --- Auto Shoot ---
        if(this.frame % 8 === 0) {
            AudioSys.shoot();
            this.spawnBullet(true, p.position, new THREE.Vector3(0,0,-1.5));
            if(p.data.power > 1) {
                this.spawnBullet(true, p.position, new THREE.Vector3(-0.3,0,-1.5));
                this.spawnBullet(true, p.position, new THREE.Vector3(0.3,0,-1.5));
            }
        }
        
        // --- Environment ---
        this.grid.position.z += 0.5;
        if(this.grid.position.z > 0) this.grid.position.z = -50;
        
        // --- Enemies ---
        if(!this.boss) {
            this.spawnEnemy();
            if(this.score > (this.stage*3500)) this.spawnBoss();
        } else {
            const b = this.boss;
            b.timer++;
            if(b.mesh.position.z < -20) b.mesh.position.z += 0.2;
            b.mesh.position.x = Math.sin(b.timer*0.02) * 12;
            b.mesh.position.y = Math.cos(b.timer*0.03) * 6;
            b.shell.rotation.z += 0.05;
            
            if(b.phase===1 && b.hp < b.maxHp*0.5) {
                b.phase = 2;
                b.core.material.emissive.setHex(0xffff00);
            }
            if(b.timer % (b.phase===1?50:25) === 0) {
                const dir = new THREE.Vector3().subVectors(p.position, b.mesh.position).normalize();
                this.spawnBullet(false, b.mesh.position, dir);
                if(b.phase===2) {
                    this.spawnBullet(false, b.mesh.position, dir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), 0.3));
                    this.spawnBullet(false, b.mesh.position, dir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), -0.3));
                }
            }
            document.getElementById('boss-hp-bar').style.width = (b.hp/b.maxHp*100)+'%';
        }
        
        // Update Enemies
        for(let i=this.enemies.length-1; i>=0; i--) {
            const e = this.enemies[i];
            if(e.type === 'CHASER') {
                e.mesh.position.z += e.speed;
                e.mesh.position.x += (p.position.x - e.mesh.position.x) * 0.02;
            } else if (e.type === 'SHOOTER') {
                e.mesh.position.z += e.speed;
                e.timer++;
                if(e.timer % 90 === 0) {
                    const dir = new THREE.Vector3().subVectors(p.position, e.mesh.position).normalize().multiplyScalar(0.6);
                    this.spawnBullet(false, e.mesh.position, dir);
                }
            } else {
                e.mesh.position.z += e.speed;
            }
            e.mesh.rotation.x += 0.05; e.mesh.rotation.z += 0.05;
            
            if(e.mesh.position.distanceTo(p.position) < 2) {
                this.damagePlayer(20);
                this.explode(e.mesh.position, 0xff0055);
                this.scene.remove(e.mesh);
                this.enemies.splice(i,1);
                continue;
            }
            if(e.mesh.position.z > 10) {
                this.scene.remove(e.mesh); this.enemies.splice(i,1);
            }
        }
        
        // --- Bullets ---
        for(let i=this.bullets.length-1; i>=0; i--) {
            const b = this.bullets[i];
            b.mesh.position.add(b.vel);
            if(Math.abs(b.mesh.position.z) > 100 || Math.abs(b.mesh.position.x) > 50) {
                this.scene.remove(b.mesh); this.bullets.splice(i,1); continue;
            }
            
            let hit = false;
            if(b.isPlayer) {
                if(this.boss && b.mesh.position.distanceTo(this.boss.mesh.position) < 4) {
                    this.boss.hp -= 10;
                    this.explode(b.mesh.position, 0xffaa00);
                    hit = true;
                    if(this.boss.hp <= 0) this.killBoss();
                }
                if(!hit) {
                    for(let j=this.enemies.length-1; j>=0; j--) {
                        const e = this.enemies[j];
                        if(b.mesh.position.distanceTo(e.mesh.position) < 2.5) {
                            e.hp--;
                            hit = true;
                            this.explode(e.mesh.position, 0xff0055);
                            AudioSys.hit();
                            if(e.hp<=0) {
                                this.score += (e.type==='HEAVY'?500:100);
                                if(Math.random()<0.1) this.spawnItem(e.mesh.position);
                                this.scene.remove(e.mesh); this.enemies.splice(j,1);
                            }
                            break;
                        }
                    }
                }
            } else {
                if(b.mesh.position.distanceTo(p.position) < 1.2) {
                    this.damagePlayer(10); hit = true;
                }
            }
            if(hit) { this.scene.remove(b.mesh); this.bullets.splice(i,1); }
        }
        
        // --- Items ---
        for(let i=this.items.length-1; i>=0; i--) {
            const it = this.items[i];
            it.mesh.position.z += 0.5; it.mesh.rotation.y += 0.1;
            if(it.mesh.position.distanceTo(p.position) < 2.5) {
                AudioSys.powerup();
                if(it.type === 'POWER') {
                    p.data.power = 2; p.data.powerTime = 600;
                    this.showNotify("WEAPON UP", "SPREAD SHOT ENABLED");
                    document.getElementById('buff-ui').style.opacity = '1';
                } else {
                    p.data.hp = Math.min(100, p.data.hp+30);
                    this.showNotify("REPAIR", "HULL RESTORED");
                }
                this.scene.remove(it.mesh); this.items.splice(i,1);
                this.updateHUD();
            } else if(it.mesh.position.z > 10) {
                this.scene.remove(it.mesh); this.items.splice(i,1);
            }
        }
        
        // --- Particles ---
        for(let i=this.particles.length-1; i>=0; i--) {
            const pt = this.particles[i];
            pt.mesh.position.add(pt.vel);
            pt.life -= 0.05;
            pt.mesh.scale.setScalar(pt.life);
            if(pt.life <= 0) { this.scene.remove(pt.mesh); this.particles.splice(i,1); }
        }
        
        if(p.data.invincible > 0) p.data.invincible--;
    },
    
    spawnBullet(isPlayer, pos, vel) {
        const geo = new THREE.BoxGeometry(0.3, 0.3, 1.2);
        const color = isPlayer ? 0x00ffff : 0xff0000;
        const mat = new THREE.MeshBasicMaterial({color});
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);
        this.scene.add(mesh);
        this.bullets.push({mesh, vel, isPlayer});
    },
    
    explode(pos, color) {
        AudioSys.explode();
        for(let i=0; i<8; i++) {
            const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const mat = new THREE.MeshBasicMaterial({color});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            this.scene.add(mesh);
            this.particles.push({
                mesh, 
                vel: new THREE.Vector3((Math.random()-0.5),(Math.random()-0.5),(Math.random()-0.5)),
                life: 1.0
            });
        }
    },
    
    damagePlayer(amount) {
        if(this.player.data.invincible > 0) return;
        this.player.data.hp -= amount;
        this.player.data.invincible = 60;
        AudioSys.hit();
        this.updateHUD();
        this.camera.position.x += (Math.random()-0.5);
        setTimeout(()=>this.camera.position.set(0,8,18), 50);
        
        if(this.player.data.hp <= 0) {
            this.isActive = false;
            document.getElementById('final-score').innerText = this.score;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }
    },
    
    killBoss() {
        this.explode(this.boss.mesh.position, 0xffffff);
        this.scene.remove(this.boss.mesh);
        this.boss = null;
        document.getElementById('boss-ui').style.display = 'none';
        this.score += 5000;
        if(this.stage === 1) {
            this.stage = 2;
            this.showNotify("STAGE 2", "THREAT LEVEL RISING");
        } else {
            this.isActive = false;
            document.getElementById('victory-screen').classList.remove('hidden');
        }
        this.updateHUD();
    },
    
    updateHUD() {
        document.getElementById('score').innerText = this.score.toString().padStart(6,'0');
        document.getElementById('stage').innerText = this.stage;
        const hpBar = document.getElementById('hp-bar');
        hpBar.style.width = Math.max(0, this.player.data.hp) + '%';
        if(this.player.data.hp < 30) hpBar.classList.add('warning'); else hpBar.classList.remove('warning');
    },
    
    onResize() {
        this.camera.aspect = window.innerWidth/window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    },
    
    animate() {
        requestAnimationFrame(()=>this.animate());
        this.update();
        this.renderer.render(this.scene, this.camera);
    },
    
    reset() { this.start(); }
};

window.game = Game;
window.onload = ()=>Game.init();

</script>

<script id="lfs-meta" type="application/json">
{
  "appId": "eb28112f6b8c1abd7bf3bd902eafff65",
  "createdAt": "2026-01-03T21:55:32.873Z",
  "schema": 2,
  "title": "NEON WINGS: TOUCH STRIKER",
  "savedAt": "2026-01-03T21:55:32.873Z",
  "aiInstruction": "",
  "comment": "",
  "sourceMode": "project",
  "runId": "69d1919332048e242c1f9eb02310dd4c"
}
</script>
</body>
</html>